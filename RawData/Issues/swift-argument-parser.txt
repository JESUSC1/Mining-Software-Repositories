Issue 562 - Author: anton-plebanovich
I have an option of an optional array type
```swift
@Option(name: [.customShort("d"), .customLong("date")], help: "help!")
private var dates: [String]?
```
if I call my command with arguments like `-d 2020-10-02 -d 2021-05-11` it only will be initialized with the last `["2021-05-11"]` argument. Non-optional array argument works properly.

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
Something like that:
```swift
import ArgumentParser
import Foundation

struct Bug: ParsableCommand {
    static let configuration = CommandConfiguration(
        abstract: "bug!",
        subcommands: [BugSubcommand.self],
        defaultSubcommand: BugSubcommand.self)
    
    init() {}
}

struct BugSubcommand: ParsableCommand {
    @Option(name: [.customShort("d"), .customLong("date")], help: "help!")
    private var dates: [String]?
    
    func run() throws {
        print(dates!)
    }
}

Bug.main()
```

Execution command: `bug --date 2020-10-02 --date 2021-05-11`

### Expected behavior
I expected to receive `dates` property with `["2020-10-02", "2021-05-11"]` value

### Actual behavior
I received `dates` property with `["2021-05-11"]` value


Issue 561 - Author: robertmryan
Right now, if you supply an `async` rendition of `run()` in conjunction with `ParsableCommand`, it produces no warning or error, but whenever you run the app, you simply see the “USAGE” text. It took a surprising/unnecessary amount of time pouring through the class library and looking at a particular code sample, before I stumbled across `AsyncParsableCommand`. 

* Ideally, it would be great to produce a meaningful warning/error when a valid `run()` is not found. It obviously fell through to a point where “USAGE” text was displayed. Is it possible to give us some warning *why* we got the “USAGE” text?

* I would suggest that the `README.md` and the [documentation](https://swiftpackageindex.com/apple/swift-argument-parser/1.2.2/documentation/argumentparser) introduction make some reference to `AsyncParsableCommand` for `async` renditions of `run()`. This should be more easily discovered. 

If you would like me to take a pass at a PR to that end, please let me know.

Issue 560 - Author: revolter
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace the paragraph
    below with information about your proposed feature.
-->

Similar to how `pod cache` works, meaning, it outputs the same thing as `pod cache --help`, it would be nice if this package would support it as well.

I tried this hacky workaround:
```swift
@Flag
var help = true
```
but it fails with the error
```
ArgumentParser/ParsableArguments.swift:256: Fatal error: Validation failed for `ConfigCommand`:

- One or more Boolean flags is declared with an initial value of `true`.
This results in the flag always being `true`, no matter whether the user
specifies the flag or not.

To resolve this error, change the default to `false`, provide a value
for the `inversion:` parameter, or remove the `@Flag` property wrapper
altogether.

Affected flag(s):
--help
```

Issue 559 - Author: hassila
Current SAP can generate a custom list of completions (which is nice!), it'd be even cooler if this could be expanded to real "live" completions with approaches similar to (https://unix.stackexchange.com/questions/227826/how-to-implement-dynamic-bash-auto-completion) - if I'm not misunderstanding the current state of affairs, the custom completions currently are run only once when the completion script is generated - what I'm after is that the completion would run the tool and dynamically generate the completions.

Sample use cases:

* Completion of e.g. available table names in a database names (that can change between invocations)
* Completion of internal state of a server (a client CLI tool can connect to the server and complete state dynamically), could be useful for introspection tools - this is what I'm looking at at the moment and this would have been quite useful

I think most of the infrastructure is in place, there just needs to be some way to invoke the SAP tool and get it to return the list of completions in a way the shell needs (as the link above does for example) and tweak the completion scripts to do 'live' queries when desired. 

Extra nice would be to support caching of the dynamic results in an easy way (for cases where it is potentially expensive, the dynamic query could choose to just return cached results).

WDYT?

Issue 558 - Author: MaxDesiatov
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace each paragraph
    below with the relevant details for your bug, and complete
    the steps in the checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

`@OptionGroup` behaves in an unexpected way with nested groups when `title:` argument value is specified.

**ArgumentParser version:** 1.2.2
**Swift version:** 
swift-driver version: 1.62.15 Apple Swift version 5.7.2 (swiftlang-5.7.2.135.5 clang-1400.0.29.51)
Target: arm64-apple-macosx13.0

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
Create a type that has properties using `@OptionGroup` property wrapper with `title:` argument passed. Uses this type then as `@OptionGroup` itself. This top level may specify or not specify its own `title:` argument, this doesn't make a difference on the observed outcome.

### Expected behavior
Nested `@OptionGroup`s have their `title:` values displayed and options grouped by these titles in help output.

### Actual behavior
Nested `@OptionGroup`s don't have their `title:` values displayed and options grouped by these titles in help output. All of the options are displayed within the top-level group, `title:` values on nested groups have no effect whatsoever.


Issue 557 - Author: tarbaiev-smg
### Description
Currently it's only possible to use initial value if the property type has a non-`Optional` type (by means of the `wrappedValue` parameter).
In some cases we might need to provide an optional default value, e.g when reading it from the environment.
To allow this we introduce the `initial` argument in the initializers of the `Argument` and `Option` property wrappers which do not contain the `wrappedValue` argument.

Resolves https://github.com/apple/swift-argument-parser/issues/556

### Detailed Design
As an example, adding the `initial` parameter to the `Option` initializer:
```swift
  public init(
    name: NameSpecification = .long,
    parsing parsingStrategy: SingleValueParsingStrategy = .next,
    help: ArgumentHelp? = nil,
    completion: CompletionKind? = nil,
    initial: Value? = nil // <-- Using default value preserves backward compatibility
  ) {
    self.init(_parsedValue: .init { key in
      let arg = ArgumentDefinition(
        container: Bare<Value>.self,
        key: key,
        kind: .name(key: key, specification: name),
        help: help,
        parsingStrategy: parsingStrategy.base,
        initial: initial, // <-- injecting the initial value
        completion: completion)

      return ArgumentSet(arg)
    })
```

would allow us to use it as follows:

```swift
@Option(initial: ProcessInfo.processInfo["REQUIRED_OPTION"])
var requiredOption: String

@Option(initial: ProcessInfo.processInfo["OPTIONAL_OPTION"])
var optionalOption: String?
```

The argument requirement therefore remains defined by it's nullability. A `nil` initial value in a non-`Optional` property would fail the command if the argument is not provided in the command line.

### Documentation Plan
The initialzers' documentation has been updated.

### Test Plan
Relevant tests added.

### Source Impact
The change is backward-compatible.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 556 - Author: tarbaiev-smg
Currently it's only possible to use initial value if the property type is non-`Optional`.
I'd like to use environment variable as a fallback value for a command line argument (similar how it's done in Fastlane), but keep the argument required. To allow this I'd like to propose adding the `initial` argument to initializers of non-`Optional` type property wrappers which do not contain the `wrappedValue` argument.

For example adjusting the `Option` initializer:
```swift
  public init(
    name: NameSpecification = .long,
    parsing parsingStrategy: SingleValueParsingStrategy = .next,
    help: ArgumentHelp? = nil,
    completion: CompletionKind? = nil,
    initial: Value? = nil // <-- Using default value preserves backward compatibility
  ) {
    self.init(_parsedValue: .init { key in
      let arg = ArgumentDefinition(
        container: Bare<Value>.self,
        key: key,
        kind: .name(key: key, specification: name),
        help: help,
        parsingStrategy: parsingStrategy.base,
        initial: initial, // <-- injecting the initial value
        completion: completion)

      return ArgumentSet(arg)
    })
```

would allow us to use it as follows:

```swift
@Option(initial: ProcessInfo.processInfo["REQUIRED_OPTION"])
var requiredOption: String
```

Issue 555 - Author: thafner0
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace the paragraph
    below with information about your proposed feature.
-->

At the moment the `custom` case of the `CompletionKind` enumeration supports being given a custom closure to generate completions on the command line. However, since the provided closure must be synchronous, it is difficult to incorporate functionality that requires swift's concurrency features. The lack of this functionality prevents certain tasks from being possible with these completions and causes other tasks to be possible, but only in a non-thread safe way. Examples of this include working with databases (such as those managed by Apple's Core Data framework).

Example:

```swift
struct SomeCommand: AsyncParseableCommand {

@Argument(help: "<Helpful help>", completion: .custom({ arguments in
return try? await completionGenerator(arguments: arguments) ?? []
}))
var argument: String

mutating func run() async throws {
// Code that makes the command Run
}
}

@MainActor
private func completionGenerator(arguments: [String]) async throws -> [String] {
// Code that generates completions that has some asynchronous system in use and/or must be run on the main actor.
}
```

Issue 554 - Author: gwynne
As initially demonstrated in #553, the existing `ArgumentDecoder` logic fails when presented with a property which:

- Is unparsed
- Is not optional
- Has a default value, and
- Requests a keyed container during decoding

This occurs because while the actual property in question is properly assessed as having `.defaultValue` as an `InputOrigin`, the request for a keyed decoding container bypasses the logic which would otherwise return said default value, and since the `ArgumentDefinition` logic is (correctly) not recursive, the type fails to decode any keys it contains due to a "missing value".

The most straightforward solution I could find, one which covers all cases without negatively affecting handling of parsed properties (to the best of my ability to determine), was to apply the "default value" handling from the `decodeIfPresent<T>(_:forKey:)` method of the keyed decoding container (which ensured that _optional_ properties of this sort already worked correctly) to the more fundamental "bottleneck" `decode<T>(_:forKey:)` method as well, modified to throw a `wrongType` error instead of returning nil on type mismatch.

I additionally added a functioning `allKeys` property accessor for additional robustness against custom `Decodable.init(from:)` implementations. (The choice not to do the same for `nestedContainer(keyedBy:)`, `nestedUnkeyedContainer()`, `superDecoder()`, and `superDecoder(forKey:)` was simply pragmatic - it's not even close to worth the effort.)

Fixes #553 

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 553 - Author: hassila
Swift argument parser crashes when adding a dictionary property - see attached reproducer.

**ArgumentParser version:** `1.2.2` (reproduced with `main` too)
**Swift version:**  `swift-driver version: 1.62.15 Apple Swift version 5.7.1 (swiftlang-5.7.1.135.3 clang-1400.0.29.51)
Target: arm64-apple-macosx13.0
`
### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
Unpack the attached reproducible project and run from command line with:
`swift run swift-argument-parser-reproducer --command run`

The complete code is simply:
```swift
import ArgumentParser

typealias BenchmarkIdentifier=Int

struct BenchmarkResult: Codable {
    var x:Int
}

@main
struct BenchmarkTool: AsyncParsableCommand {
    @Option(name: .long, help: "The command to perform")
    var command: String

    var benchmarkResults: [BenchmarkIdentifier: [BenchmarkResult]] = [:] // comment this out to not crash

    mutating func run() async throws {
    }
}
```

### Expected behavior
```
hassila@ice ~/G/swift-argument-parser-reproducer> swift run swift-argument-parser-reproducer --command run
Building for debugging...
[3/3] Linking swift-argument-parser-reproducer
Build complete! (0.39s)
USAGE: benchmark-tool --command <command>

OPTIONS:
  --command <command>     The command to perform
  -h, --help              Show help information.

hassila@ice ~/G/swift-argument-parser-reproducer> 
```

### Actual behavior
```
hassila@ice ~/G/swift-argument-parser-reproducer> swift run swift-argument-parser-reproducer --command run
Building for debugging...
[47/47] Linking swift-argument-parser-reproducer
Build complete! (4.50s)
ArgumentParser/ArgumentDecoder.swift:89: Fatal error
fish: Job 1, 'swift run swift-argument-pars...' terminated by signal SIGTRAP (Trace or breakpoint trap)
```

[swift-argument-parser-reproducer.zip](https://github.com/apple/swift-argument-parser/files/10731814/swift-argument-parser-reproducer.zip)


Issue 552 - Author: rauhul
Fixes #551

- Fixes a bug where signle-page manuals did not include subcommand abstracts because the DSL logic did not take to account root commands vs subcommands. This change adds a "root" property to the DSL element to allow for styling differences in the two cases.

Thanks @Nef10 for reporting this issue. If you have time could you try this branch and verify it solves the issue in your project.

Issue 551 - Author: Nef10
When I run swift package plugin generate-manual in the default single page mode, I was expecting that the resulting man page would include the abstract of the sub commands. The multi-page mode includes these in the different pages as expected. Without it, the help just has the sub command name and all it's flags (including the description for the flags) - but it doesn't help you in understanding when to use which subcommand.

**ArgumentParser version:** 1.2.2
**Swift version:** 5.7.2

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
`swift package plugin generate-manual`

### Expected behavior
Example output for a check sub-command:

```
.It Em check
Parses a ledger and prints any errors it finds
.Bl -tag -width 6n
.It Ar file
The file to parse.
.It Fl q , -quiet
Don't print errors, only indicate via exit code.
```

### Actual behavior
Example output for a check sub-command:

```
.It Em check
.Bl -tag -width 6n
.It Ar file
The file to parse.
.It Fl q , -quiet
Don't print errors, only indicate via exit code.


Issue 550 - Author: natecook1000
Arguments declared with the `.allUnrecognized` parsing strategy currently capture built-in flags, which isn't intended. This fixes that issue by looking for built-in flags in the captured portion of the input before decoding.

Fixes rdar://104990388

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 549 - Author: natecook1000
None

Issue 548 - Author: natecook1000
When a property wrapper is applied to a property, the property's storage is given a name with a prefixed underscore. That is, for a property named `x`, the actual storage is named `_x`.

That prefixed storage is what is visible through reflection, so when building an `ArgumentSet` from a command type's mirror, we need to remove the leading underscore. This is done when creating an `InputKey` for each property.

However, `InputKeys` are also created from `CodingKeys` during decoding of a command. These `CodingKeys` _do not_ have the leading underscore that is added by the property wrapper, so any underscores that appear are actually from the declaration of the property with an underscored name. Removing leading underscores from `CodingKey` names results in a mismatch when trying to find the decoded value. For example, for a simple command declared like this:

```
@main
struct Repro: ParsableCommand {
    @Option(name: .customLong("arg"))
    var _arg: String?

    func run() throws {
        print(self._arg ?? "nil")
    }
}
```

Running: `repro --arg foo` fails to parse with the error:
```
Error: Unknown option '--arg'. Did you mean '--arg'?
Usage: repro [--arg <arg>]
  See 'repro --help' for more information.
```

This change simplifies the `InputKey` type to use an array path instead of an indirect enum and removes the leading underscore dropping when creating an `InputKey` from a `CodingKey`.

rdar://104928743

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 547 - Author: natecook1000
When an executable with asynchronous commands is backdeployed, the compiler chooses the synchronous `main()` unless a minimum availability target is provided for the root command type. This changes the error message provided when the incorrect `main()` function is called to direct the tool's author to a correct solution.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 546 - Author: mackoj
I don't feel like it's my place to do this but I really want to see this move forward.

This a pr for #449 since everything seems to work. **I didn't do the work @KeithBird did**. I just open this PR in order to see this feature move forward.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 545 - Author: davidnorris78
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace each paragraph
    below with the relevant details for your bug, and complete
    the steps in the checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Replace this paragraph with a short description of the incorrect incorrect behavior. If this is a regression, please note the last version that the behavior was correct in addition to your current version.

**ArgumentParser version:** `0.1.0` or the `main` branch, for example.
**Swift version:** Paste the output of `swift --version` here.

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
I'm building a commandline tool that runs as root and I'm simply attempting to get the '--help' to present when there are no arguments passed into the command line.

I'm running Macbook Pro M1, Xcode Version 14.2 (14C18) as sudo.

Here is my logic in main.swift
```
let passedArgs = Array(CommandLine.arguments.dropFirst())
if passedArgs.count == 0 {
    do {
        try _ = argParser.parse(["--help"])
        exit(1)
    } catch {
        print(error)
        print(error.localizedDescription)
        exit(1)
    }
}
```

### Expected behavior
Expecting it to print out the Help/Usage summary of each of the commands.

### Actual behavior
Console in Xcode just returns:

```
helpRequested(visibility: ArgumentParser.ArgumentVisibility(base: ArgumentParser.ArgumentVisibility.Representation.default))
The operation couldn’t be completed. (ArgumentParser.ParserError error 0.)
```


Issue 544 - Author: natecook1000
`CountLines`'s concurrency use requires availability annotations — this should fix those build errors.

Issue 543 - Author: natecook1000
This provide type annotation for a multi-line closure, which can only have an inferred return type in Swift 5.7.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 542 - Author: TiagoMaiaL
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

The purpose of this PR is to fix issue https://github.com/apple/swift-argument-parser/issues/541. It fixes the `USAGE` text when generated with arguments using the `.postTerminator` parsing strategy.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 541 - Author: natecook1000
An `@Argument` property declared with the `.postTerminator` parsing strategy should appear after the terminator (`--`) in the Usage string, but right now is treated just like other arguments.

**ArgumentParser version:** `main` branch
**Swift version:** Paste the output of `swift --version` here.

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
Declare a command with this definition:

```swift
@main
struct Example: ParsableCommand {
  @Argument
  var requiredArgument: String
  
  @Argument(parsing: .postTerminator)
  var otherArgs: [String] = []
}
```

### Expected behavior
The usage string should place `other-args` after the terminator:
```
USAGE: example <required-argument> -- [<other-args> ...]
```

### Actual behavior
There's no terminator visible in the usage string:
```
USAGE: example <required-argument> [<other-args> ...]
```

Issue 540 - Author: natecook1000
None

Issue 539 - Author: natecook1000
The `CountLines` executable is failing to build on non-macOS platforms, [as seen here](https://swiftpackageindex.com/apple/swift-argument-parser/builds), due to missing availability annotations before using `FileHandle.AsyncBytes.lines`. This change adds the missing availability to match.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 538 - Author: julianiaccopucci
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace each paragraph
    below with the relevant details for your bug, and complete
    the steps in the checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

When using an AsyncParsableCommand with @main, the command-line-tool exits without running the `run() async` function and prints the help log.
Note: `run()` without `async` runs the function.

**ArgumentParser version:** `1.2.0`
**Swift version:** swift-driver version: 1.45.2 Apple Swift version 5.6 (swiftlang-5.6.0.323.62 clang-1316.0.20.8)
**MacOS** 12.6
### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
Option A: Reproduce by running the [Example in this repository](https://github.com/apple/swift-argument-parser/blob/main/Examples/count-lines/CountLines.swift)

Option B:
![Screenshot 2023-01-06 at 10 36 30](https://user-images.githubusercontent.com/5910320/210991006-7ad472d9-112b-4a8b-9397-f14ca1010ac1.png)

### Expected behavior
The `run() async` function should run

### Actual behavior
The `run() async` function isn't run and the program exits with the help log.


Issue 537 - Author: sailinz
I import the ArgumentParser package to use it with influxdb-client-swift package https://github.com/influxdata/influxdb-client-swift. This is for a companion watchOS app. The iOS itself works well, as in the I can request data successfully from influxdb with these two packages. However, when I copy the same code to the Watch App swift code and build project, the build Failed because of the "Cannot find 'Process' in scope" error from  Process+SimpleAPI.swift. 

**ArgumentParser version:** `1.2.0` 
**Swift version:** swift-driver version: 1.62.15 Apple Swift version 5.7.1 (swiftlang-5.7.1.135.3 clang-1400.0.29.51)
Target: x86_64-apple-macosx13.0

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
I'm querying data in a very similar way to the "QueryCpuData" example on https://github.com/influxdata/influxdb-client-swift

### Expected behavior
Both iOS and watchOS apps should be able to build. 

### Actual behavior
When there's no watchOS code with these two packages, the iOS app builds and runs well. I copy-paste the same swift code from the iOS app to the watchOS app, the error occurs during the build process. 


Issue 536 - Author: fboundp
When attempting to create an application with a AsyncParsableCommand root and AsyncParsableCommand subcommands, a fatal error is thrown at runtime “Asynchronous subcommand of a synchronous root.”

**ArgumentParser version:** `1.2.0`
**Swift version:** `swift-driver version: 1.62.8 Apple Swift version 5.7 (swiftlang-5.7.0.127.4 clang-1400.0.29.50)
Target: arm64-apple-macosx13.0`


### Checklist
- [ ] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce

source:

```
import protocol ArgumentParser.AsyncParsableCommand
import struct ArgumentParser.CommandConfiguration

@main
struct asyncissue: AsyncParsableCommand {
  static var configuration = CommandConfiguration(subcommands: [Cmd1.self])

  struct Cmd1: AsyncParsableCommand {
    mutating func run() async throws {
      print("Hello")
    }
  }
}
```

### Expected behavior

When resulting command is run, help with a subcommand would be displayed.

### Actual behavior

```
ArgumentParser/ParsableCommand.swift:184: Fatal error: 
--------------------------------------------------------------------
Asynchronous subcommand of a synchronous root.

The asynchronous command `Cmd1` is declared as a subcommand of the
synchronous root command `asyncissue`.

With this configuration, your asynchronous `run()` method will not be
called. To fix this issue, change `asyncissue`'s `ParsableCommand`
conformance to `AsyncParsableCommand`.
--------------------------------------------------------------------

zsh: trace trap  swift run
```


Issue 535 - Author: mtj0928
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->
A generated fish script didn't complete an option after an argument.

The cause is the generated fish script doesn't accept an input text which already has arguments. 
For example, when the input is `repeat -`, the script can complete `--count`, but when the text is `repeat foo -`, the script cannot complete `repeat foo --count`, because the input text already has the argument "foo".

To fix the issue, I implemented the following steps.
1. Preprocess for the subcommand.
To support options of the root command like `math --version add`, `--version` is removed by `_swift_{command name}_preprocessor`.

2. Decide a command.
In a case when a command has some subcommands like `math stats average 1 10 100 --kind mean`, we need to decide the target command.  (In the example  case, the target command is `average`.)
To decide it, the newly generated script receives `expected command` and `subcommands`.
(e,g,)
    1. A case checking whether the target command is `stats` or not.
        - `expected command` = `math stats`
        - `subcommands` = `average stdev quantiles help`
    2. A case checking whether the target command is `average` or not.
        - `expected command` = `math stats average`
        - `subcommands` is empty (`average` doesn't have any subcommands.)`

    When the input has the expected command, and a text after the expected command is not the subcommand, the newly generated script decide the command is a target command, and suggest options for the target command.

### Related issues
- #376
- #534

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 534 - Author: mtj0928
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace each paragraph
    below with the relevant details for your bug, and complete
    the steps in the checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

A fish script that is generated by `--generate-completion-script` doesn't complete an option after an argument.
For example, `repeat` command which is contained in the repository as an example can run the following command.
```shell
$ repeat foo --count 10 
```
However, `--count` is not completed even though `$ repeat foo --c` is input and a tab key is pressed.

**ArgumentParser version:** `main`
**Swift version:**  
```
swift-driver version: 1.62.15 Apple Swift version 5.7.1 (swiftlang-5.7.1.135.3 clang-1400.0.29.51)
Target: arm64-apple-macosx13.0
```

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
1. Build this repository
```shell 
$ swift build -c release
```
2. Add the release directory into your $PATH.
```shell
$ set -x PATH (string join "" (pwd) "/.build/release/") $PATH  
```

3. Generate a fish completion script.
```
$ repeat --generate-completion-script fish >> ~/.config/fish/completions/repeat.fish
```

4. Type `repeat foo --` and press a tab key to try to complete options.

### Expected behavior
Options that `repeat` supports are shown.

### Actual behavior
Nothing is shown.

Issue 533 - Author: natecook1000
Reverts apple/swift-argument-parser#531 — I mis-read which branch this was landing on. We need to wait until there's a release version of the docs hosted at SPI.

Issue 532 - Author: yim-lee
Together with https://github.com/apple/swift-argument-parser/pull/531, updating GitHub pages references to those hosted by Swift Package Index.


Issue 531 - Author: yim-lee
This is part of the concerted effort to move to Swift Package Index hosted docs.

Issue 530 - Author: Chamepp
Improved project status structure grammatically.

### Checklist
- [x] Improved project status section in readme


Issue 529 - Author: rauhul
- Renames AssertEqualStringsIgnoringTrailingWhitespace to AssertEqualStrings and updates the implementation to require matching trailing whitespace.
- Updates AssertEqualStrings to include much easier to read diff output when CollectionDifference is available. This should add developers when tests fail by providing more clear errors.


Issue 528 - Author: rauhul
- Changes uses of import Foundation in ArgumentParser to only expose the symbols needed to avoid growing unintentional dependencies.
- Replaces direct usage of EXIT_FAILURE in MessageInfo with ExitCode, exposed as a result of the above change.

Issue 527 - Author: rauhul
- The name of "GenerateManualPlugin" was changed to "Generate Manual" to improve the plugin's display name in Xcode. This however results in the `.pluginWorkDirectory` provided by SPM to include a space (' ') in the path. The space in the output path by itself is not a deal breaker, but unfortunately `man` (at least on macOS) does not properly handle path arguments with spaces. Example:

  ```shell
  ➜  swift package generate-manual
  ...
  Generating manual for roll...
  Generated manual in '.build/plugins/Generate Manual/outputs/roll'
  ...
  ➜  man '.build/plugins/Generate Manual/outputs/roll/roll.1'
  /usr/bin/man: line 413: cd: .build/plugins/Generate: No such file or \
    directory
  ```

  IMO, easily previewing the generating manual takes precedence over the UI in Xcode; as a result, this commit partially reverts the plugin's name to "GenerateManual" to hopefully provide a good middle ground of an output path without a space and a display name in Xcode that is a little easier on the eyes than "GenerateManualPlugin" was.

Issue 526 - Author: rauhul
- Fixes deprecation warnings in unit tests by marking tests which cover deprecated functionality as @available(*, deprecated) themselves.

Issue 525 - Author: rauhul
Fixes #524 

- Updates README.md and GettingStarted.md to reference swift-argument-parser from: 1.2.0. Additionally, adds a minimum supported swift version table to README.md to guide users on older toolchains.

Issue 524 - Author: iainhouston
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace each paragraph
    below with the relevant details for your bug, and complete
    the steps in the checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

As described in the Getting Started (count.swift) example, `Package.swift` contains

    targets: [
        .target(
            name: "count",
            dependencies: [.product(name: "ArgumentParser", package: "swift-argument-parser")]),
    ]

but `swift.run` emitted:  

     error: no executable product available

until I changed `.target` to `.executableTarget`

**ArgumentParser version:** main branch `1.2.0` 
**Swift version:**   

     swift-driver version: 1.62.15 Apple Swift version 5.7.1 (swiftlang-5.7.1.135.3 clang-1400.0.29.51)
     Target: x86_64-apple-macosx13.0

### Checklist
- [tick ] If possible, I've reproduced the issue using the `main` branch of this package
- [tick ] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)


Issue 523 - Author: doozMen
I have a simple command, see below, that runs a custom build command. I have to do some initial setup that can only happen once. I noticed init gets called many times when I use @main. 

```swift
import ArgumentParser

@main
struct Build: AsyncParsableCommand {
 
  static var configuration: CommandConfiguration = .init(
    subcommands: [BuildSwift.self, Clean.self])
  
  init() { print("Init called")}
}

```

**ArgumentParser version:** `1.2.0`
**Swift version:** 
swift-driver version: 1.62.15 Apple Swift version 5.7.1 (swiftlang-5.7.1.135.3 clang-1400.0.29.51)
Target: arm64-apple-macosx13.0
Darwin MacBook-Pro.lan 22.1.0 Darwin Kernel Version 22.1.0: Sun Oct  9 20:15:09 PDT 2022; root:xnu-8792.41.9~2/RELEASE_ARM64_T6000 arm64

### Checklist
- [ ] If possible, I've reproduced the issue using the `main` branch of this package
- [ ] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
1. swift package init --type executable
2. depend on swift-argument-parser
3. add build command like above 
4. run the app

### Expected behavior

Init should only be called once

### Actual behavior

multiple calls to init

### Workaround

I overwrite the static main and copy paste the default implementation of AsyncParsableCommand. This one is only called once. But not ideal


Issue 522 - Author: natecook1000
This change is to make sure that the non-optional generic parameter type is chosen for `@Argument` and `@Option` properties that provide a default value. Previously, an optional type might be chosen depending on how the `help` parameter was spelled, due to strange overload resolution. In particular, using the `.init` caused selection of the deprecated optional overload:

```swift
// Unexpected:
// Infers `Value` as `Optional<AbsolutePath>`
@Argument(help: .init("The path"))
var path = AbsolutePath("/")

// Expected:
// Infers `Value` as `AbsolutePath`
@Argument(help: "The path")
var path = AbsolutePath("/")
```

This addresses the issue by marking the deprecated overloads as disfavored. rdar://102383455

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 521 - Author: rickrizzo
Remove the word "master" from the project. An inclusive language filter was flagging this. As this word is only used in a test I opted to remove it completely to avoid this issue for myself and others.

Master is now "graduate" and doctor is now "doctorate" to be consistent.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 520 - Author: kkk669
This issue was introduced by #504.

When the target platform is WASI, `Platform.exit` causes infinite recursion because it calls itself.

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 519 - Author: natecook1000
This adds the `.spi.yml` file that SPI uses to know how to generate documentation, as described here: https://blog.swiftpackageindex.com/posts/auto-generating-auto-hosting-and-auto-updating-docc-documentation/


Issue 518 - Author: natecook1000
None

Issue 517 - Author: sonic555gr
I have argument parser as a dependancy on a Library. 
After updating to xcode 14.1 
`swift build` fails 

version 1.1.4 
swift version 5.7

### Checklist
- [ ] If possible, I've reproduced the issue using the `main` branch of this package
- [X] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
using 
``` swift
.package(url: "https://github.com/apple/swift-argument-parser", from: "1.0.0")
```
tries to install version 1.1.4 
fails with error.

```
error: Couldn’t check out revision ‘9f39744e025c7d377987f30b03770805dcb0bcd1’:
    fatal: reference is not a tree: 9f39744e025c7d377987f30b03770805dcb0bcd1

```

problem doesn't occur if I set the version 
``` swift 
.package(url: "https://github.com/apple/swift-argument-parser", .exact("1.1.3"))
```

### Expected behavior
Library should build successfully without errors

### Actual behavior
```
error: Couldn’t check out revision ‘9f39744e025c7d377987f30b03770805dcb0bcd1’:
    fatal: reference is not a tree: 9f39744e025c7d377987f30b03770805dcb0bcd1

```

Issue 516 - Author: natecook1000
We've had some regressions under Swift 5.6 in the latest changes, particularly around using implicitly opened existentials, which is a 5.7 feature. I've tested these changes using Swift 5.6 on Linux and macOS 12.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 515 - Author: Zollerboy1
If I haven't overlooked something, it's currently not possible to define options in the style of make/gcc/clang definitions.

In theory it should be possible to define it like this:

```swift
@main
struct Foo: ParsableCommand {
    @Option(name: .customShort("D", allowingJoined: true), parsing: .singleValue)
    var defines: [String] = []

    public func run() throws {
        print(defines)
    }
}
```

This works fine for calling the executable e.g. like so:

```
$ foo -Dbar -Dbaz
["bar", "baz"]
```

However, when the value of the option contains an =, this doesn't work anymore:

```
$ foo -Dbar=baz
Error: Unknown option '-Dbar'
```

I'd guess that after seeing an equals sign the single "D" isn't considered anymore. It would be great, if that behaviour could be changed.

Of course, it would be possible to go an extra step and fully parse such key-value pairs into a dictionary. I could imagine a syntax like this:

```swift
@main
struct Foo: ParsableCommand {
    @Option(name: [.customShort("D", allowingJoined: true), .customLong("define")])
    var defines: [String: String] = [:]

    public func run() throws {
        print(defines)
    }
}
```

Where `Option` gets a new specialized init for `Value == [String: Element]` that then would work like that:

```
$ foo -Dbar=1 -D baz=2 --define qux=3
["bar": 1, "baz": 2, "qux": 3]
``` 

Issue 514 - Author: natecook1000
This will hopefully provide better for guidance around a common issue for ArgumentParser adopters. Also fixes #508.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 513 - Author: chrisyarbrough
Argument parser is generating the warning "Conversion to Swift 5 is available" in Xcode 14.0.1 (14A400). 

**ArgumentParser version:**
1.1.4

**Swift version:**
swift-driver version: 1.62.8 Apple Swift version 5.7 (swiftlang-5.7.0.127.4 clang-1400.0.29.50)
Target: arm64-apple-macosx12.0

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
- Create a Swift Command Line Application in Xcode
- Import ArgumentParser with any sample code and build
- Observe Xcode warnings in the Navigator

### Expected behavior
No warnings should be shown.

### Actual behavior
The Xcode navigator shows this warning: warning project: Conversion to Swift 5 is available

Clicking the warning normally allows auto-upgrading the code to a newer version. In this case, however, auto-upgrade will not work. It will display the message "No source changes necessary". Presumably, it's not possible to auto-upgrade the code because package dependencies are readonly and should not be modified. To remove the warning, the source code of the ArgumentParser package will need to conform to Swift 5.

<img width="1083" alt="image" src="https://user-images.githubusercontent.com/17833862/198854559-e282b189-5495-4d63-9da6-cee336fadb14.png">



Issue 512 - Author: natecook1000
Fixes #509.

Issue 511 - Author: d-ronnqvist
This fixes 6 unresolved symbol links in ArgumentParser documentation and removes the `@Comment` directives that used to describe these unresolved links. These unresolved links were brought up in https://github.com/apple/swift-docc/issues/407.

<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

This is a documentation-only change.

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [ ] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 510 - Author: natecook1000
Some tests fail on Windows due to the unimplemented `Bundle.init(for:)`.


Issue 509 - Author: bjo0
Suggested change:
```diff
-  /// An array of all possible strings to that can convert to value of this
-  /// type.
+  /// An array of all possible strings that can convert to value of this type.
```

Issue 508 - Author: rauhul
We should add a code example to the AsyncParsableCommand for swift >5.5:

https://github.com/apple/swift-argument-parser/blob/76259ebe8c477ecc4e938d0831aea4c25f9ee3ee/Sources/ArgumentParser/Documentation.docc/Extensions/AsyncParsableCommand.md?plain=1#L3-L7

The prose wrt to needing the root to be an AsyncParsableCommand if any of the children are async is very useful but a simple code example is a bit easier to get started with.

Issue 507 - Author: natecook1000
Some of the symbol identifiers changed since the last release, and `OptionGroup` and `ArgumentArrayParsingStrategy` both received new API.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 506 - Author: compnerd
There are references to functions from the Windows SDK rather than the C library for the console handling.  Explicitly import the necessary types and functions from the WinSDK module so that Windows can build once more with the changes to sequester the platform specific code.

Issue 505 - Author: clayellis
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

This PR updates the name of the "Generate Manual" plugin so that it appears in a more readable "command" form in the context menu in Xcode.

Before:
![image](https://user-images.githubusercontent.com/10712068/194952348-b2ee8325-0b21-4f62-a970-4d1bdc75338b.png)

After:
![image](https://user-images.githubusercontent.com/10712068/194952287-f4ab7c44-a51c-47b6-9524-e642fd0992cb.png)

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 504 - Author: natecook1000
None

Issue 503 - Author: compnerd
The new source file was added to the tree but not the build.  Due to the snapshots using a tagged version, this escaped testing.

Issue 502 - Author: pauluk20
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:kş.l    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Replace this paragraph with a description of your changes and rationale. Provide links to an existing issue or external references/discussions, if appropriate.

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [ ] I've followed the code style of the rest of the project
- [ ] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 501 - Author: QuaqSim
### Description
This adds the `shouldUseExecutableName` property to `CommandConfiguration`, allowing the command name to be derived from the executable's file name.

The property defaults to false, both because subcommands using it is probably undesirable and to preserve existing behaviour after updating the package.

This also adds `/DerivedData` to the git ignore list.

### Detailed Design
```swift
/// A Boolean value indicating whether to use the executable's file name for the command name.
public var shouldUseExecutableName: Bool
```

The `CommandConfiguration` initialisers use a default value of false, serving to allow existing code to compile and to avoid an unexpected change in behaviour. When the value is true, if both `commandName` and `_superCommandName` are nil, the command name will be derived from the first command line argument, i.e. the path to the running executable.

Change to associated code paths is minimal, specifically `ParsableCommand._commandName` has been expanded in a way that preserves the original outcome when the new property is false.

The thinking behind ignoring this value when either `commandName` or `_superCommandName` have been set is that if the command name has been explicitly set, this should be used. If the super command name has been set, this implies a relationship with another command where a dynamic command name may lead to inconsistent help texts.

Two new internal symbols - see diff for full API documentation.
```swift
/// Will generate a tool name from the name of the executed file if possible.
static var executableName: String {}

/// Returns a new single-quoted string if this string contains any characters
/// from the specified character set. Any existing occurrences of the `'`
/// character will be escaped.
func quotedIfContains(_ chars: CharacterSet) -> String {}
```

### Documentation Plan
Includes API documentation for the new symbols and minorly updates docs to expose the new property.

### Test Plan
Includes unit tests for the string quoting. I'm unaware of a guaranteed executable name when running tests and therefore this does not include tests for the command name generation.

### Source Impact
Existing users should not be impacted by this change.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 500 - Author: natecook1000
Once 1.2.0 is released, the code sample change in #498 should be reverted.

Issue 499 - Author: natecook1000
As described in #489, a command that declares an optional `@Argument` before a non-optional `@Argument` won't ever allow a single-argument call. It would be nice if ArgumentParser provided a validation warning / error so that authors could move to a different design.

Issue 498 - Author: natecook1000
Fixes #497.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 497 - Author: heckj
The example in the README and `main` branch of the project doesn't match the code that's currently released, resulting in a rather confusing compilation error.

**ArgumentParser version:** `1.1.4`
**Swift version:**:
```
swift-driver version: 1.62.14 Apple Swift version 5.7.1 (swiftlang-5.7.1.131.4 clang-1400.0.29.51)
Target: arm64-apple-macosx12.0
```

### Checklist
- [X] If possible, I've reproduced the issue using the `main` branch of this package
- [X] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)


The example in the README for Repeat explicitly uses the the new functionality for providing optional values, that was merged with https://github.com/apple/swift-argument-parser/pull/480. I grabbed the sample directly to stub in code into my repo, and got a sequence of confusing messages from Xcode about it not working, until I finally tracked down the details to the optional being a newer feature than the 1.1.4 release provided. 

I wasn't sure how long until this project was thinking about releasing the next update, so I wanted to open this bug.

The error messages when you explicitly set @Optional to nil are:

`Type '...yourAppName...' does not conform to protocol 'Decodable'`
and 
`Referencing initializer 'init(wrappedValue:name:parsing:help:completion:)' on 'Option' requires that 'Int?' conform to 'ExpressibleByArgument'`

This would be pretty quickly resolved by putting out a point release that includes that lovely optional setup that was merged after the last release, which I'd like to suggest. In the meantime, newcomers (and clueless folks like me) might take the README as reflection the currently released code and be very confused.

Issue 496 - Author: natecook1000
### Description
This adds two new parsing options for argument arrays, and renames `.unconditionalRemaining` to `.captureForPassthrough`:

- `unconditionalRemaining` has been an attractive nuisance. It looks like it means "everything leftover", but it actually has a specific and slightly strange set of behaviors to support SwiftPM capturing inputs to pass on to a sub-client, as in `swift run MyExecutableTarget`. The new name better matches this intended usage.
- `allUnrecognized` collects all the inputs that weren't used during parsing, which is a more generally useful behavior. This essentially suppresses all "unrecognized flag/option" and "unexpected argument" errors, and makes those extra inputs available to the client.
- `postTerminator` collects all inputs that follow the `--` terminator, before trying to parse any other positional arguments. This is a non-standard, but sometimes useful parsing strategy.

### Detailed Design
Two new symbols and one renaming — see the diff for full API documentation.

```swift
/// After parsing, capture all unrecognized inputs in this argument array.
public static var allUnrecognized: ArgumentArrayParsingStrategy {
  self.init(base: .allUnrecognized)
}

/// Before parsing, capture all inputs that follow the `--` terminator in this
/// argument array.
public static var postTerminator: ArgumentArrayParsingStrategy {
  self.init(base: .postTerminator)
}

/// Parse all remaining inputs after parsing any known options or flags,
/// including dash-prefixed inputs and the `--` terminator.
public static var captureForPassthrough: ArgumentArrayParsingStrategy {
  self.init(base: .allRemainingInput)
}

@available(*, deprecated, renamed: "captureForPassthrough")
public static var unconditionalRemaining: ArgumentArrayParsingStrategy {
  .captureForPassthrough
}
```

### Documentation Plan
Includes API documentation for the new symbols and significantly expanded docs for the existing members.

### Test Plan
Includes unit tests for the new cases.

### Source Impact
This deprecates the `unconditionalRemaining` strategy, which was confusingly named. The new name is `captureForPassthrough`, which is more explicit about its intent.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 495 - Author: randomeizer
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your request, please replace each paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

### Description
This fix addresses the core issue described in #322.

As noted in the issue, if you have a `ParsedCommand`/`AsyncParsedCommand` which contains a `ParsedArguments` implementation, and the `ParsedCommand` and `ParsedArguments` both have a field which has the same name and type, they will both update each other, even if one has a unique `.customLong(...)` name.

For example, a simple case which will break:

```swift
struct MyOptions: ParsedArguments {
  @Flag(name: .customLong("my-custom-flag"))
  var myFlag: Bool = false
}

struct MyCommand: ParsedCommand {
  @Flag()
  var myFlag: Bool = false

  @OptionGroup var options: MyOptions

  mutating func run() throws {
    print("My Flag: \(myFlag)")
    print("My Custom Flag: \(options.myFlag)")
  }
}
```

This is then output with flags set:

```sh
> swift run MyCommand
My Flag: false
My Custom Flag: false
> swift run MyCommand --my-flag
My Flag: true
My Custom Flag: true
> swift run MyCommand --my-custom-flag
My Flag: true
My Custom Flag: true
> swift run MyCommand --my-flag --my-custom-flag
My Flag: true
My Custom Flag: true
```

The first and last combination are correct, the two in the middle are incorrect - only one or the other should be `true` in those cases.

### Detailed Design

It turns out that the core issue is in `ArgumentDecoder`, with some assistance from `InputKey`. The root `ArgumentDecoder` is handed the flat list of `ParsedValues`, which contains a reference to the `key` as an `InputKey`. That `InputKey` just has the field name, with no link to any `.customLong` values. That same list of `ParsedValues` is handed to any sub-decoders for `@OptionGroup`-annotated `ParsedArguments` implementations. When the sub-decoder looks for its named field, its `InputKey` matches the parent struct's field, and they both end up sharing the same value.

For example, if I have an instance of `MyCommand` called `cmd`, the two fields have this `InputKey`:

- `cmd.myFlag`: `InputKey(rawValue: "myFlag")`
- `cmd.options.myFlag`: `InputKey(rawValue: "myFlag")`

The fix I've implemented is to augment `InputKey` to record any "parent" key relevant to the field during the parsing phase. For example, our `MyCommand` instance will now have the following:

- `cmd.myFlag`: `InputKey(name: "myFlag", parent: .root)`
- `cmd.options.myFlag`: `InputKey(name: "myFlag", parent: .key(InputKey(name: "options", parent: .root)))`

Interestingly, the fix did not require any changes to `ArgumentDecoder`, but it did require changes to anything that created an `InputKey`, along with passing in a `parent` `InputKey` where relevant, mostly when dealing with `ParsedArguments`.

### Documentation Plan
I have added source-level documentation to the `InputKey` in particular, along with a couple of other locations for clarity. All the changes were to internal code, so no public API/documentation changes seem to be necessary. Happy to update them if I missed something though.

### Test Plan
I've added four new tests cases into `OptionGroupEndToEndTests`, for lack of a better place to put it. I'm happy to move them elsewhere if there is a more appropriate location. Specifically, they are:

- `testUniqueNamesForDuplicatedFlag_NoFlags`
- `testUniqueNamesForDuplicatedFlag_RootOnly`
- `testUniqueNamesForDuplicatedFlag_OptionOnly`
- `testUniqueNamesForDuplicatedFlag_RootAndOption`

They cover the four example combinations from above. I'm currently not testing other types (`@Option`/`@Argument`), can add those also if desired. Again, let me know where is best to put them.

All existing tests are currently passing.

### Source Impact
The key change was with `InputKey`, as described above, and the related requirements of passing around the parent `InputKey` at various points, particularly in `validate` methods. It doesn't change any public APIs.

I also too the opportunity to move copy-pasted code that was dropping the leading "_" for `@propertyWrapper` fields into `InputKey` to keep everything tidy.

`InputKey` ended up being larger than the `ParsedValues` code, so I moved the whole struct into its own file: `InputKey.swift` in the same folder.

As noted above, it does not change the public API, so I don't believe any updates to the public API documentation are required.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 494 - Author: natecook1000
RawRepresentable types that have a non-String raw value are having values displayed in the help screen by converting the RawRep value into a string. However, these values are by default parsed by their raw value, so we should use that for display instead.

This is accomplished by adding a defaultValueDescription implementation for all ExpressibleByArgument-conforming RawValue types, and then basing the allValues implementation on that. This generalizes the existing overloads for String-based RawRep types, while also allowing users who customize their ExpressibleByArgument implementation to provide the correct help value for clients.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 493 - Author: danpalmer
I've had a look for this in the docs and code and not found anything. If this is already support, apologies, let me know what I should be searching for. I'm happy to contribute more docs for it to make it less likely that others come asking in the future.

I'd like to be able to ignore unknown arguments. For example, given the following definition, I'd like to be able to run `cmd --bar` and have it work, ignoring the `--bar`.

```swift
struct Example: ParsableCommand {
    @Option var foo: Bool
}
```

### Design options

How is this behaviour enabled? I strongly feel it shouldn't be the default as it's somewhat dangerous and minimises the benefits of `swift-argument-parser`.

#### `CommandConfiguration`

The simplest option feels like a boolean property on `CommandConfiguration`, likely passed to the constructor, with a name like `ignoreUnknownArguments` or `ignoreUndefinedArguments` (is "unknown" or "undefined" the better terminology to use for this feature?).

#### `@UnknownArguments`

Another option, perhaps more flexible, is to define a new decorator that can be applied like this:

```swift
@UnknownArguments var unknown: [String]
```

The behaviour of this would be to collect anything that `swift-argument-parser` would otherwise consider unknown, nullifying the validation that there are no known arguments, but _also_ giving the developer the chance to act on them with their own logic.

A further version of this would be `@UnknownArguments(requireAllow: true)` (with some better naming). The behaviour of this would be to allow unknown arguments, but only if acknowledged and allowed by another argument, for example...

```
cmd --foo --allow-unknown=--foo
```

In the above case, if `--foo` parses successfully, everything works as normal. However if it doesn't it's added to the list of unknown arguments and no validation error is raised. Any arguments that are unknown but _not_ given with `--allow-unknown` would cause validation errors as normal.

I expect that the `--allow-unknown` argument would itself be validated as normal, as if it had been manually created by the developer, i.e. if there is no `@UnknownArguments` it would raise a validation error.

### Why?

There are 2 primary use-cases for this that I can see:

1. Writing binaries for environments not under your control. Perhaps the binary is going to be run with options/arguments that you are not in control of, but you don't care about what they are. Using `swift-argument-parser` is still useful, but writing effectively a schema for things you don't care about that will be validated makes the code more brittle.
2. Progressive rollouts of arguments. It's common in server environments to use arguments to control the behaviour of a server. Being able to add the supporting code and the arguments separately from each other makes deployments more flexible.

---

Again, apologies if this is available, I haven't been able to find it. I expect that one _could_ implement all of this on top of `swift-argument-parser`'s infrastructure, but it would likely be more manual, less elegant, and may sacrifice more validation to work fully.

I'm happy to provide more detail on the above ideas for implementation, or on the use-cases. My preferred option would be the second one as I think it's more flexible, and I've got experience using systems with the `--allow-unknown` sort of flag and the ergonomics are nice to have.

Issue 492 - Author: natecook1000
This change lets you provide a title for option groups, which is used when generating the help screen. Titled option groups, when they exist, are placed between the ARGUMENTS and OPTIONS section of the help. Multiple option groups with the same title are coalesced into a single group.

For example, this command declaration:

```swift
struct Extras: ParsableArguments {
    @Flag(help: "Print extra output while processing.")
    var verbose: Bool = false

    @Flag(help: "Include details no one asked for.")
    var oversharing: Bool = false
}

@main
struct Example: ParsableCommand {
    @OptionGroup(title: "Extras")
    var extras: Extras

    @Argument var name: String?
    @Option var title: String?
}
```

yields this help screen:

    USAGE: example [--verbose] [--oversharing] [<name>] [--title <title>]

    ARGUMENTS:
      <name>

    EXTRAS:
      --verbose               Print extra output while processing.
      --oversharing           Include details no one asked for.

    OPTIONS:
      --title <title>
      -h, --help              Show help information.

Resolves #267.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary
    - [x] API documentation
    - [x] Articles


Issue 491 - Author: MartinP7r
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace the paragraph
    below with information about your proposed feature.
-->

Sorry if this is a very naive question or what I'm trying to do is already possible with the current package setup.  

I find the `ArgumentParserTestHelpers` target very helpful and it would be great to be able to add it as a dependency for the client's `testTarget`.

As a test, I tried to simply add a [product target for it in a fork](https://github.com/MartinP7r/swift-argument-parser/blob/5936daea708194917d65020187febe402e40c954/Package.swift#L21-L23). 

---

> **Note**
> below error was solved by @KS1019's [suggestion](https://github.com/apple/swift-argument-parser/issues/491#issuecomment-1257397121)

However, I keep getting the following error:  

```console
product 'ArgumentParserTestHelpers' required by package 'MyApp' target 'MayAppTests' not found in package 'swift-argument-parser'.
```
([Here](https://github.com/MartinP7r/sap-test) is a sample reproducing this error)

---

Best regards,  
Martin


Issue 490 - Author: allevato
This restores the ability to build with versions of Swift prior to 5.7.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 489 - Author: RISCfuture
I have a `ParsableCommand` instance with two positional arguments, one of which is required. Despite passing a value for the required argument, it still claims that argument is not being specified.

**ArgumentParser version:** `main`
**Swift version:** 5.7.0.127.4

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce

``` swift
import Foundation
import ArgumentParser

@main
struct ExampleCommand: ParsableCommand {
    @Argument(help: "arg1",
              completion: .file(extensions: ["sql"]),
              transform: URL.init(fileURLWithPath:))
    var firstArg = URL(fileURLWithPath: "default/value.sql")
    
    @Argument(help: "arg2",
              completion: .file(extensions: ["csv"]),
              transform: URL.init(fileURLWithPath:))
    var secondArg
    
    @Flag(help: "Include extra information in the output.")
    var verbose = false
    
    mutating func run() throws {
      print(firstArg, secondArg)
    }
}
```

Run `example-command some/file.csv`

### Expected behavior

Prints the two arguments.

### Actual behavior

```
Error: Missing expected argument '<second-arg>'
Help:  <second-arg>  arg2
Usage: example-command [<first-arg>] <second-arg> [--verbose]
  See 'example-command --help' for more information.
Program ended with exit code: 64
```


Issue 488 - Author: Samasaur1
As it currently stands, although a command can designate its default subcommand and argument parsing works correctly, there is no completion for arguments, options, or flags of the subcommand unless the subcommand name is specified — which eliminates much of the convenience of having a default subcommand. I'd like it if the completion for the default subcommand was added to the list of all subcommands as the completion for the super command.

Here's an example[^1]:
```swift
@main
struct Greeter: ParsableCommand {
    static let configuration = CommandConfiguration(subcommands: [Informal.self, Formal.self], defaultSubcommand: Informal.self)

    struct Informal: ParsableCommand {
        @Option var firstName: String

        func run() throws {
            print("Hi, \(firstName)")
        }
    }

    struct Formal: ParsableCommand {
        @Option var fullName: String

        func run() throws {
            print("Good day, \(fullName)")
        }
    }
}
```
Here's what happens if you run it:
```
$ greeter informal --f<Tab> # successfully completes to the below line
$ greeter informal --firstName

$ greeter formal --f<Tab> # successfully completes to the below line
$ greeter formal --fullName

# here's the problem
$ greeter <Tab> # lists the following completions
--help    -h        formal    help      informal
$ greeter --f<Tab> # no completions
```
Instead, I would like `greeter <Tab>` to list all subcommands (as it currently does) _and_ all the completions for its default command, so:
```
$ greeter <Tab>
--first-name  --help        -h            formal        help          informal
```

For backwards compatibility and user configurability, it might make sense to make this an optional parameter to the `@Argument`/`@Option`/`@Flag` initializer (or perhaps `CompletionKind`?)

[^1]: I made up this code sample because the project I was working on when I found this error is more complex, but this should get the point across

Issue 487 - Author: natecook1000
If a ParsableArguments type doesn't implement init(from:) correctly, it isn't decodable by the parser. This improves the validation failure message for such types.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 486 - Author: natecook1000
When an `EnumerableFlag` flag has a default value, the default is printed incorrectly as the instance value in the help, instead of as the flag that a user would need to type. The same issue is present for Boolean flags with both an inversion and a default.

```swift
struct Example: ParsableCommand {
   @Flag(inversion: .prefixedNo)
   var frobulate: Bool = true
}
```

Old help output:

```
USAGE: example [--frobulate] [--no-frobulate]

OPTIONS:
  --frobulate/--no-frobulate
                          Whether to frobulate. (default: true)
  -h, --help              Show help information.
```

Corrected help output:

```
USAGE: example [--frobulate] [--no-frobulate]

OPTIONS:
  --frobulate/--no-frobulate
                          Whether to frobulate. (default: --frobulate)
  -h, --help              Show help information.
```

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 485 - Author: KeithBird
Solution to the issue #461.

This PR is used to track progress and view differences to make discussions easier.

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary

Issue 484 - Author: KeithBird
Solution to the issue #448.

This PR is used to track progress and view differences to make discussions easier.

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary

Issue 483 - Author: ian-twilightcoder
I have a command line tool that invokes another tool, and I'd like to allow the user to pass arguments for the underlying tool. In other words:

```
my-tool my-argument --my-flag -- --argument-for-underlying-tool
```

That would look like this in code.

```
@Argument
var myArgument: String?

@Flag
var myFlag = false

@Argument
var passThroughArguments: [String] = []
```

The problem is that I need `my-tool -- --argument-for-underlying-tool` to assign "--argument-for-underlying-tool" to `passThroughArguments`, but it assigns it to `myArgument` instead. I don't see any existing argument parsing strategies that can achieve this behavior.

Issue 482 - Author: ian-twilightcoder
Flags can be mutually exclusive, but there isn't a way to do that for options. e.g. you can't have `[--arch <arch> | --target <target>]` Ideally these could be nested like `[[--one <one> --two <two>] | [--combo <combo>]]`

Issue 481 - Author: natecook1000
In addition to being useful, this allows us to drop the `@testable` annotation for the ArgumentParser import in ArgumentParserTestHelpers, which resolves #463.

### Checklist
- [X] I've added at least one test that validates that my change is working, if appropriate
- [X] I've followed the code style of the rest of the project
- [X] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [X] I've updated the documentation if necessary


Issue 480 - Author: natecook1000
This adds underscored initializers that let library users add `= nil` to declarations of optional `@Option` and `@Argument` properties. Previously, default values have been available for properties of non-optional types only.

These new initializers use `_OptionalNilComparisonType` as the wrapped value parameter, so only a `nil` literal is acceptable in the default value position. This avoids the problem of declaring an optional property with a non-`nil` default, which ends up negating the purpose of an optional.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 479 - Author: rauhul
- Idea: additional discussion for commands and arguments which is
  exported to dump-help and can be consumed by supplemental content
  generators to contains much more detailed information than you may want
  to include in a help screen.
  Maybe a better idea would be to have --help-detailed flag that would
  include this information in the help output. Suggestions are welcome.


Issue 478 - Author: rauhul
None

Issue 477 - Author: rauhul
- Fixes #466.
- Adds initializers to ArgumentDefinition generic over a Container type.
  The Container type must conform to a new internal protocol
  ArgumentDefinitionContainer which describes functionality like default
  set of help options for the argument defined by the property wrapper,
  etc.
- Adds overloads for Optional @Arguments and @Options with default
  values which emit deprecation warning to guide users towards using the
  non-Optional versions.

Issue 476 - Author: ian-twilightcoder
defaultValueDescription is always the enum case name, but that's not a valid argument when the enum value differs from the case name. Extend ExpressibleByArgument to use rawValue for defaultValueDescription for string enums.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 475 - Author: rauhul
- Removes the experimental prefix from the generate-manual plugin. The
  manual generation still is not mature, but we would like to avoid
  breaking adopters scripts by delaying changing the plugin's name in
  the future.


Issue 474 - Author: rauhul
- Fixes a bug where built-in flags such as --help and --version were not
  properly marked with isOptional which resulted in them appearing in
  generated content (such as completion scripts and manuals) as required
  arguments.

Issue 473 - Author: rauhul
- Fixes a manual generation bug where options in the synopsis were not
  given an option value name and flags were.


Issue 472 - Author: rauhul
- Changes the generate-manual --single-page argument to --multi-page, so
  generate-manual will create a single manual page with all subcommand
  information by default instead of many distinct files.

Issue 471 - Author: rauhul
- Fixes an issue where the --author option without its value  was passed
  by the generate-manual plugin to the generate-manual tool resulting in
  plugin invocation failures or incorrect author information.

Issue 470 - Author: KeithBird
Solution to the issue #469.

This PR is used to track progress and view differences to make discussions easier.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary

Issue 469 - Author: KeithBird
### Ask for required `@Flag: EnumerableFlag`

Design and implement interactive mode for `@Flag` who conforms to `EnumerableFlag`.

When parameters similar to the following are not initialized:

```swift
enum ColorFlag: EnumerableFlag {
    case pink, purple, silver
}

@Flag var color: ColorFlag
```

The following dialog will be generated automatically:

```
1. --pink
2. --purple
3. --silver
? Please select 'color': --silver
Error: '--silver' is not a serial number.

? Please select 'color': 4
Error: '4' is not in the range 1 - 3.

? Please select 'color': 3
You select '--silver'.
```

---

**This issue is posted here as a subtask of the [GSoC project](https://github.com/apple/swift-argument-parser/issues/449) for discussion and suggestions.**

Issue 468 - Author: KeithBird
Solution to the issue #467.

This PR is used to track progress and view differences to make discussions easier.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary

Issue 467 - Author: KeithBird
### Ask for required `@Option`

Design and implement interactive mode for `@Option`.

`@Option`'s interactive mode is similar to `@Argument`'s. Both of them will takes the parameter name as a prompt instead of asking the user to type it.

When parameters similar to the following are not initialized:

```swift
@Option var userName: String
```

The following dialog will be generated automatically:

```
? Please enter 'userName': keith
```

### Ask for required `@OptionGroup`

Design and implement interactive mode for `@GlobalOptions`.

When parameters similar to the following are not initialized:

```swift
struct GlobalOptions: ParsableArguments {
    @Argument var values: [Int]
    @Flag var verbose: Bool = false
}

struct Options: ParsableArguments {
    @OptionGroup var globals: GlobalOptions
}
```

The following dialog will be generated automatically:

```
? Please enter 'values': 1 2 3
```

---

**This issue is posted here as a subtask of the [GSoC project](https://github.com/apple/swift-argument-parser/issues/449) for discussion and suggestions.**

Issue 466 - Author: YourMJK
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace each paragraph
    below with the relevant details for your bug, and complete
    the steps in the checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Declaring an argument with `@Argument(..., transform:)` makes it non-optional in the "USAGE" and doesn't include it's default value in the argument's abstract in the "ARGUMENTS" section, ***even* if the value has a default value and/or is of an optional type.**  
(The actual parsing of the optional arguments seems to be correct)

**ArgumentParser version:** `1.1.3`
**Swift version:** `swift-driver version: 1.26.9 Apple Swift version 5.5.1 (swiftlang-1300.0.31.4 clang-1300.0.29.6)`

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
Declare arguments like this in a `ParsableCommand` struct:
```
struct Cmd1: ParsableCommand {
  @Argument(help: "Test argument 1", transform: { Int($0)! })
  var test1: Int = 0
  
  @Argument(help: "Test argument 2", transform: URL.init(fileURLWithPath:))
  var test2: URL?
}
```
and print the help message through `Cmd.parseOrExit([])` or `print(Cmd.helpMessage())`

### Expected behavior
The printed help string (namely USAGE and ARGUMENTS) should be the same as if the arguments were declared like this (without the `transform:` parameter):
```
struct Cmd2: ParsableCommand {
  @Argument(help: "Test argument 1")
  var test1: Int = 0
  
  @Argument(help: "Test argument 2")
  var test2: String?
}
```

### Actual behavior
Help message for arguments with `transform:` parameter looks like this:
```
USAGE: cmd1 <test1> <test2>

ARGUMENTS:
  <test1>                 Test argument 1
  <test2>                 Test argument 2
```
While help message *without* `transform:` is correctly generated:
```
USAGE: cmd2 [<test1>] [<test2>]

ARGUMENTS:
  <test1>                 Test argument 1 (default: 0)
  <test2>                 Test argument 2
```


Issue 465 - Author: YourMJK
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace each paragraph
    below with the relevant details for your bug, and complete
    the steps in the checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Xcode 13.1 on macOS 11.6.7 throws the compiler error "Concurrency is only available in macOS 12.0.0 or newer" since `AsyncParsableCommand` and `AsyncMainProtocol` are only marked with `@available(macOS 10.15)`.  
This should be changed to `@available(macOS 12.0)`.

**ArgumentParser version:** `1.1.3`
**Swift version:** `swift-driver version: 1.26.9 Apple Swift version 5.5.1 (swiftlang-1300.0.31.4 clang-1300.0.29.6)`

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
Include latest version of ArgumentParser as dependency in command line project and build with Xcode 13.1 on macOS 11.6.7.

### Expected behavior
ArgumentParser should build without errors on macOS 11.6.7.

### Actual behavior
ArgumentParser can't be built on macOS 11.6.7.


Issue 464 - Author: KeithBird
Solution to the issue #462.

This PR is used to track progress and view differences to make discussions easier.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary

Issue 463 - Author: buttaface
Building in release mode produces this since #410 was merged:
```
> ./swift-5.6.2-RELEASE-ubuntu20.04/usr/bin/swift build -c release
/home/butta/swift-argument-parser/Sources/ArgumentParserTestHelpers/TestHelpers.swift:12:18: error: module 'ArgumentParser' was not compiled for testing
@testable import ArgumentParser
```
That means the last working version was 1.0.3. A workaround is to add `-Xswiftc -enable-testing`.

**ArgumentParser version:** latest commit df9ee66 from the  `main` branch
**Swift version:** 5.5 and later, probably earlier versions too

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

Issue 462 - Author: natecook1000
There should be API added to the `CommandConfiguration` type so that command authors can disable interactive mode. We'll need to choose a good name — something like `promptForMissingRequiredValues: Bool = true` is accurate but obviously too long.

Issue 461 - Author: natecook1000
Tests are currently blocked on the `feature/interactive` branch because the interactive mode is always on. It should only run when the command is executed in an interactive shell.

Issue 460 - Author: KeithBird
Solution to the issue #459.

This PR is used to track progress and view differences to make discussions easier.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary

Issue 459 - Author: KeithBird
### Asking to retype an invalid value

When parameters similar to the following are not initialized:

```swift
@Argument var integer: Int
```

The following dialog will be generated automatically:

```
? Please enter 'integer': a
Error: The value 'a' is invalid for '<integer>'.

? Please replace 'a': 0.1
Error: The value '0.1' is invalid for '<integer>'.

? Please replace '0.1': 1
```

### Asking to retype invalid values in array

When parameters similar to the following are not initialized:

```swift
@Argument var values: [Int]
```

The following dialog will be generated automatically:

```
Please enter 'values': a 0.1
Error: The value 'a' is invalid for '<values>'.

? Please replace 'a': 1
Error: The value '0.1' is invalid for '<values>'.

? Please replace '0.1': 2
```

---

**This issue is posted here as a subtask of the [GSoC project](https://github.com/apple/swift-argument-parser/issues/449) for discussion and suggestions.**

Issue 458 - Author: KeithBird
This PR is used to track progress and view differences to make discussions easier.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 457 - Author: KeithBird
Solution to the issue #453.

This PR is used to track progress and view differences to make discussions easier.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 456 - Author: MarcoEidinger
✅ Closes: #455

`ArgumentParser` 1.1.3 includes a SwiftPM plugin for generating man pages. However, this plugin is not visible to packages that declare `ArgumentParser` as a package dependency.

Defining a product of type `plugin` in the package manifest will solve that. Running `swift package plugin --list` for a package, that declares `ArgumentParser` as a package dependency, will then list the `GenerateManualPlugin`

```
‘experimental-generate-manual’ (plugin ‘GenerateManualPlugin’ in package ‘swift-argument-parser’)
```

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [X] I've followed the code style of the rest of the project
- [X] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [X] I've updated the documentation if necessary


Issue 455 - Author: MarcoEidinger
**ArgumentParser version:** `1.1.3`
**Swift version:** 5.6

### Checklist
- [X] If possible, I've reproduced the issue using the `main` branch of this package
- [X] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

## Relates to

ArgumentParser includes a SwiftPM plugin for generating man pages. Explore the functionality and configuration by running `swift package plugin experimental-generate-manual --help` from your package root. (https://github.com/apple/swift-argument-parser/pull/332)

### Steps to Reproduce
Add `ArgumentParser` as a package dependency to an existing package

```Swift
    dependencies: [
        // other dependencies
        .package(url: "https://github.com/apple/swift-argument-parser", from: "1.1.3"),
    ],
```

Run command to list available plugins

```
swift package plugin --list
```

### Expected behavior

Expected that `GenerateManualPlugin` is shown as available plugin

```
‘experimental-generate-manual’ (plugin ‘GenerateManualPlugin’ in package ‘swift-argument-parser’)
```

### Actual behavior

No plugin(s) are listed


Issue 454 - Author: KeithBird
Solution to the issue #453.

This PR is used to track progress and view differences to make discussions easier.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 453 - Author: KeithBird
### Ask for required `@Argument: Value`

Design and implement interactive mode for `@Argument` whose type is normal value.

When parameters similar to the following are not initialized:

```swift
@Argument var phrase: String
```

The following dialog will be generated automatically:

```
? Please enter 'phrase': hello
```

### Ask for required `@Argument: Array<Element>`

Design and implement interactive mode for `@Argument` whose type is `Array`.

When parameters similar to the following are not initialized:

```swift
@Argument var values: [Int]
```

The following dialog will be generated automatically:

```
? Please enter 'values': 1 2 3
```

### Ask for required `@Argument: ExpressibleByArgument`

Design and implement interactive mode for `@Argument` who conforms to `ExpressibleByArgument`.

When parameters similar to the following are not initialized:

```swift
enum ReleaseMode: String, CaseIterable, ExpressibleByArgument {
    case debug, release
}

@Argument var mode: ReleaseMode
```

The following dialog will be generated automatically:

```
1. debug
2. release
? Please select 'mode': debug
Error: 'debug' is not a serial number.

? Please select 'mode': 0
Error: '0' is not in the range 1 - 2.

? Please select 'mode': 1
You select 'debug'.
```

### Ask for required `@Argument` has `transform`

Design and implement interactive mode for `@Argument` who has `transform` function.

When parameters similar to the following are not initialized:

```swift
enum Format {
    case text
    case other(String)

    init(_ string: String) throws {
        if string == "text" {
            self = .text
        } else {
            self = .other(string)
        }
    }
}

@Argument(transform: Format.init) var format: Format
```

The following dialog will be generated automatically:

```
? Please enter 'format': text
```

---

**This issue is posted here as a subtask of the [GSoC project](https://github.com/apple/swift-argument-parser/issues/449) for discussion and suggestions.**

Issue 452 - Author: natecook1000
None

Issue 451 - Author: KeithBird
Solution to the issue #450.

This PR is used to track progress and view differences to make discussions easier.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 450 - Author: KeithBird
Before this project we need to initialize the entire `ParsableCommand` by parsing a single line of command, otherwise we will require the user to re-enter the whole command. In interactive mode, we can initialize step by step in each conversation by prompting the user.

---

**This issue is posted here as a subtask of the [GSoC project](https://github.com/apple/swift-argument-parser/issues/449) for discussion and suggestions.**

Issue 449 - Author: KeithBird
# Introduction

ArgumentParser provides a straightforward way to declare command-line interfaces in Swift, with the dual goals of making it (1) fast and easy to create (2) high-quality, user-friendly CLI tools.

In order to further achieve these two goals, for this project, we designed and implemented an interactive mode for tools built using ArgumentParser. This mode can prompt for required arguments not given in the initial command, suggest possible corrections when user input is invalid, help users learn to use unfamiliar command line tools by trial and error.

This project was also done as a GSoC (Google Summer of Code) project for which you can find [here](https://summerofcode.withgoogle.com/programs/2022/projects/ynUKk8wd).

# Motivation

With server side swift gaining more and more traction, command line apps built with ArgumentParser can be very useful for automating common tasks to boost developer productivity. But there are still many developers don’t want to bother with the command line, because the help text came in the form of thick manuals and error messages were opaque.

For example, in the past, users would get lengthy error messages when required arguments are not initialized:

```
$ repeat

Error: Missing expected argument '<phrase>'

USAGE: repeat [--count <count>] [--include-counter] <phrase>

ARGUMENTS:
  <phrase>                The phrase to repeat.

OPTIONS:
  --count <count>         The number of times to repeat 'phrase'.
  --include-counter       Include a counter with each repetition.
  -h, --help              Show help information.

$ repeat hello world
hello world
hello world
```

Introducing the conversational nature of interactive mode will be very helpful, it can reduce duplication and provide a conversational CLI which is both easier to write and easier to read:

```
$ repeat

? Please enter 'phrase': hello world
hello world
hello world
```

# Achievements

## `Ask` prompt the user for input

```swift
let age = ask("? Please enter your age: ", type: Int.self)
```

The above code will generate the following dialog:

```
? Please enter your age: keith
Error: The type of 'keith' is not Int.

? Please enter your age: 18
```

## `Check` verifies key directives

```swift
guard
  check("Are you sure you want to delete all?")
else { return }
print("---DELETE---")
```

The above code will generate the following dialog:

```
Are you sure you want to delete all?
? Please enter [y]es or [n]o: y
---DELETE---
```

## `Choose` provides possible input for the user to choose from

```swift
let selected = choose("Please pick your favorite colors: ",
                      from: ["pink", "purple", "silver"])
```

The above code will generate the following dialog:

```
1. pink
2. purple
3. silver
Please pick your favorite colors: pink
Error: 'pink' is not a serial number.

Please pick your favorite colors: 0 1
Error: '0' is not in the range 1 - 3.

Please pick your favorite colors: 1 2
```

## Ask for required `@Argument`

When parameters similar to the following are not initialized:

```swift
@Argument var values: [Int]
```

The following dialog will be generated automatically:

```
? Please enter 'values': 1 2 3
```

## Ask for required `@Option`

When parameters similar to the following are not initialized:

```swift
@Option var userName: String
```

The following dialog will be generated automatically:

```
? Please enter 'userName': keith
```

## Ask for required `@Flag: EnumerableFlag`

When parameters similar to the following are not initialized:

```swift
enum ColorFlag: EnumerableFlag {
    case pink, purple, silver
}

@Flag var color: ColorFlag
```

The following dialog will be generated automatically:

```
1. --pink
2. --purple
3. --silver
? Please select 'color': --silver
Error: '--silver' is not a serial number.

? Please select 'color': 4
Error: '4' is not in the range 1 - 3.

? Please select 'color': 3
You select '--silver'.
```

## Asking to retype an invalid value

When parameters similar to the following are not initialized:

```swift
@Argument var values: [Int]
```

The following dialog will be generated automatically:

```
Please enter 'values': a 0.1
Error: The value 'a' is invalid for '<values>'.

? Please replace 'a': 1
Error: The value '0.1' is invalid for '<values>'.

? Please replace '0.1': 2
```

---

**The above is just a partial display of the interfaces. For more details, please click the links in the implementation section.**

# Implementation

This project is implemented by the following subtasks, you can click to see more detailed API design:

* **#448**

* **#450**

* **#453**

* **#467**

* **#469**

* **#459**

* **#462**

# Future Work

## Fixing misspelled arguments

If a user mistypes an option, flag, or command, the interactive mode should suggest possible correction:

```
% example --indx 5
Error: Unexpected argument '--indx', did you mean '--index'?

? Please enter [y]es or [n]o: y
```

## Merge two `canInteract()` functions

Since the two `canInteract()` one modifies the `SplitArguments` and the other modifies the `ParsedValues`, it's not a good idea to merge them for now. But it could make more sense if there's only one path for interactively collecting additional input. So we need find a way to handle `.missingValueForOption` error without modifying the the original input, which is surely going to be more error prone than operating on the more structured parsed value data.

The discussion under the #451 provides more details.

# Related Links

* [GSoC accepted proposal](https://keithbird.notion.site/Interactive-mode-for-swift-CLI-tool-ArgumentParser-a3ffeaf0256e4ca0b0ce9de5d52a092d)

* [GSoC official project showcase page](https://summerofcode.withgoogle.com/programs/2022/projects/ynUKk8wd)

* [Swift forum posts related to this project](https://forums.swift.org/t/swift-argumentparser-interactive-mode/55884)

* [Other GSoC projects organizing in swift](https://forums.swift.org/tag/gsoc-2022)

Issue 448 - Author: KeithBird
The following internal functions will serve as the basis for the interactive mode:

### `Ask` prompt the user for input:

```swift
let operand = ask("? Please enter operand: ", type: Int.self)
```

```
? Please enter operand: 1.2
Error: The type of '1.2' is not Int.

? Please enter operand: 1
```

### `Choose` provides possible input for the user to choose from:

```swift
let choice = choose("? Please select an operator: ", from: ["+", "-", "*", "/"])
```

```
1. +
2. -
3. *
4. /
? Please select an operator: +
Error: '+' is not a serial number.

? Please select an operator: 0
Error: '0' is not in the range 1 - 4.

? Please select an operator: 1
You select '+'.
```

### `Check` verifies key directives

```swift
guard check("Are you sure you want to delete all?") else { return } 
```

```
Are you sure you want to delete all? 
? Please enter [y]es or [n]o: y
```

---

**This issue is posted here as a subtask of the [GSoC project](https://github.com/apple/swift-argument-parser/issues/449) for discussion and suggestions.**

Issue 447 - Author: wendyliga


**ArgumentParser version:** `1.1.2`.
**Swift version:** 
```
swift-driver version: 1.45.2 Apple Swift version 5.6.1 (swiftlang-5.6.0.323.66 clang-1316.0.20.12)
Target: arm64-apple-macosx12.0
```

### Checklist
- [ ] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
a simple argument parser that could take an array of input

```
@main
struct Main: ParsableCommand {
    @Argument
    var path: [String]

    func run() throws {}
}
```

compile this and run it with pipeline `echo **/*.jpg | .build/arm64-apple-macosx/debug/main`
it seems that the stdout is not pass as stdin 

### Expected behavior
the stdout from lhs is passed to rhs

### Actual behavior
Describe or copy/paste the behavior you observe.


Issue 446 - Author: LucianoPAlmeida
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Improving implementation of edit distance string extension by:
* Using only two arrays `n + 1` instead of an `m x n` matrix.
* Trimming common prefix and suffix as an optimization for reducing size/complexity 
* Tests for those cases were added.

Been playing around with ways to improve it more in https://github.com/LucianoPAlmeida/strings

**Benchmarks**
**Code:**
```swift
var benchmark = Benchmark(title: "Edit distance")
let inputGeneratorCommon: (Int) -> (String, String) = { size in
    let common = String(repeating: "a", count: size / 4)
    let s1 = String(repeating: "foo", count: (size / 2) / 3)
    let s2 = String(repeating: "bar", count: (size / 2) / 3)
    return (common + s1 + common, common + s2 + common)
}

let inputGeneratorDifferent: (Int) -> (String, String) = { size in
  let s1 = String(repeating: "foo", count: size)
  let s2 = String(repeating: "bar", count: size)
  return (s1, s2)
}

benchmark.registerInputGenerator(inputGeneratorCommon)
benchmark.add(
  title: "Opt editDistance common prefix/suffix",
  input: (String, String).self,
  maxSize: 1000
) { input in
  return { timer in
    let d = input.0.editDistance(to: input.1)
    blackHole(d)
  }
}

benchmark.add(
  title: "editDistance common prefix/suffix",
  input: (String, String).self,
  maxSize: 1000
) { input in
  return { timer in
    let d = input.0.editDistanceOld(to: input.1)
    blackHole(d)
  }
}

benchmark.registerInputGenerator(inputGeneratorDifferent)
benchmark.add(
  title: "Opt editDistance",
  input: (String, String).self,
  maxSize: 1000
) { input in
  return { timer in
    let d = input.0.editDistance(to: input.1)
    blackHole(d)
  }
}

benchmark.add(
  title: "editDistance",
  input: (String, String).self,
  maxSize: 1000
) { input in
  return { timer in
    let d = input.0.editDistanceOld(to: input.1)
    blackHole(d)
  }
}
```
<img width="1280" alt="chart" src="https://user-images.githubusercontent.com/8292651/168441236-d409b152-90d4-4268-8efd-2b3378fc3b38.png">


### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [ ] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 445 - Author: konomae
When an array of argument values fails to parse, no custom error message is
provided, and a list of valid candidate values is available, include the
list as part of the error message.

Addresses #401.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 444 - Author: davidnorris78
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace each paragraph
    below with the relevant details for your bug, and complete
    the steps in the checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Replace this paragraph with a short description of the incorrect incorrect behavior. If this is a regression, please note the last version that the behavior was correct in addition to your current version.

**ArgumentParser version:** `0.1.0` or the `main` branch, for example.
**Swift version:** Paste the output of `swift --version` here.

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce

Using `main` branch v1.1.2.  Here is how I'm implementing the code:-

```
import SwiftUI
import UserNotifications
import ArgumentParser

@main
struct NotificationAppApp: App {
    @NSApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
    @StateObject var model: ContentViewModel = {
      let model = ContentViewModel()
      do {
          let parsedResult = try Notifier.parse()
          parsedResult.update(model)
      }
      catch {
        print("Error: Could not parse arguments")
        print(CommandLine.arguments.dropFirst().joined(separator: " "))
        print(Notifier.helpMessage())
        print(error)
      }
      return model
    }()
    
    var body: some Scene {
        WindowGroup {
            ContentView(model: model)
        }
    }
}

struct Notifier: ParsableCommand {

    static let configuration = CommandConfiguration(
        abstract: "A Swift command-line tool to manage notificiations")

    @Option(name: .shortAndLong, help: "The Message")
    var message: String?

}

extension Notifier {
  func update(_ viewModel: ContentViewModel) {
    if let message = message {
      viewModel.message = message
    }
  }
}
```


### Expected behavior
I'd expect it to parse the commandline arguments.

### Actual behavior
This is the error I'm getting:

```
CommandError(commandStack: [NotificationApp.Notifier], parserError: ArgumentParser.ParserError.unknownOption(ArgumentParser.InputOrigin.Element.argumentIndex(2.0), ArgumentParser.Name.short("N", allowingJoined: false)))
```


Issue 443 - Author: rauhul
- Adds a filter to prevent hidden subcommands from appearing in shell
  completion scripts.

Fixes #442, rdar://92182881


Issue 442 - Author: bjo0
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace each paragraph
    below with the relevant details for your bug, and complete
    the steps in the checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Completion scripts for zsh (`--generate-completion-script`) include completion for hidden subcommands, making them not very hidden.

I don't think this is a regression. In my testing, hidden arguments were correctly hidden in completion.

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
- create a command with subcommands
- make one of the subcommands be hidden
- generate and load completion for the command in your shell of choice (I used zsh)
- navigate through the completion options for the base command

### Expected behavior
Hidden subcommands should not be displayed.

### Actual behavior
Hidden subcommands get displayed.


Issue 441 - Author: natecook1000
None

Issue 440 - Author: KeithBird
### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary

Issue 439 - Author: ahmdyasser
I've replaced the double newline "\n\n" with only one newline "\n".
The CLI apps like the Terminal app are most of the time opened in a small window and do not take the full size of the screen, so each line is important to be inside the window frame and it's a better UX to view it without scrolling down. Removing these two new lines gives you extra two lines to view more information without scrolling.
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Replace this paragraph with a description of your changes and rationale. Provide links to an existing issue or external references/discussions, if appropriate.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 438 - Author: KeithBird
Make all article links more accessible

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 437 - Author: KeithBird
To prevent newbies from being scared off by endless printing in the terminal, I changed the default value of `Repeat.count` from `.max` to `2`.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 436 - Author: KeithBird
The feature will be invalid when override `main()` in `ParseableCommand`. I did some testing but didn't commit because our unit tests caught errors with `parse()` as the entry, skipping `main()`.

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 435 - Author: KeithBird
Here's my solution to issue #434. I've written some unit tests and passed all tests, but I still don't know if there are any omissions or is there a way to be more performant. Every thoughts are welcomed.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 434 - Author: natecook1000
The error message when giving an option label, but no values, is incorrect for `@Option` array properties. For example, with this command:

```swift
@main
struct Example: ParsableCommand {
  @Option(parsing: .upToNextOption)
  var test: [String] = []

  mutating func run() throws {
    print(test)
  }
}
```

### Expected behavior

```
$ example --test
Error: Missing value for '--test <test>'
```

### Actual behavior

```
$ example --test
Error: Unknown option '--test'. Did you mean '--test'?
```

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

**ArgumentParser version:** `main`
**Swift version:** swift-driver version: 1.45.2 Apple Swift version 5.6 (swiftlang-5.6.0.323.62 clang-1316.0.20.8)


Issue 433 - Author: rauhul
It would be nice to add a code path in debug mode that asserts if a user has accidentally included an AsyncParseableCommand nested under a Sync one, as the async run entry point will not be called in this case.

Issue 432 - Author: KeithBird
To prevent newbies from being scared off by endless printing in the terminal, I changed the default value of `Repeat.count` from `.max` to `2`.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 431 - Author: Jomy10
Changed `1.0.0` to `1.1.1` in the "Adding `ArgumentParser` as a Dependency" section or the README


### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate // Not relevant
- [x] I've followed the code style of the rest of the project // Not relevant
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 430 - Author: christopherweems
Building an executable project using `AsyncParsableCommand` with the Swift development branch toolchain broke some time after the 02-25-22a snapshot. No compile-time errors show, but an executable built with the 03-13-22 or 03-22-22 trunk toolchain ignores any provided arguments, prints the list of argument subcommands, and exits.

This seems to be a bug in the compiler, which now prefers the `ParsableCommand.main()` type method to the `AsyncParsableCommand.main()` override.

I've found replacing `AsyncParsableCommand.main()` with one defined on `ParsableCommand` with an `AsyncParsableCommand` self-requirement restores the original behavior without breaking source-compatibility for Swift 5.6 (and presumably earlier versions as well). I am unsure of any ABI implications arising from this change.

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 429 - Author: KS1019
testCountLines fails when running tests on my environment. It seems like arguments are not properly recognized and the default run() method is executed instead of run() in CountLines.
 
**ArgumentParser version:**  main (1.1.1)
**Swift version:** 
```
Swift version: Apple Swift version 5.6 (swiftlang-5.6.0.323.62 clang-1316.0.20.8)
Target: x86_64-apple-macosx12.0
Unix version: Darwin Kotaro-no-MacBook-Pro.local 21.3.0 Darwin Kernel Version 21.3.0: Wed Jan  5 21:37:58 PST 2022
 root:xnu-8019.80.24~20/RELEASE_X86_64 x86_64

macOS version: 12.2.1
Xcode-select path: '/Applications/Xcode-13.3.0.app/Contents/Developer
Xcode: Xcode 13.3 (Build version 13E113)

```

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
Run `swift test`

### Expected behavior
Tests run successfully

### Actual behavior

```shell
Test Suite 'CountLinesExampleTests' started at 2022-03-20 00:44:05.359
Test Case '-[ArgumentParserExampleTests.CountLinesExampleTests testCountLines]' started.
/Users/kotarosuto/Documents/oss/swift-argument-parser/Tests/ArgumentParserExampleTests/CountLinesExampleTests.swift:21: error: -[ArgumentParserExampleTests.CountLinesExampleTests testCountLines] : XCTAssertEqual failed: ("1") is not equal to ("10") - Strings have different numbers of lines.
/Users/kotarosuto/Documents/oss/swift-argument-parser/Tests/ArgumentParserExampleTests/CountLinesExampleTests.swift:21: error: -[ArgumentParserExampleTests.CountLinesExampleTests testCountLines] : XCTAssertEqual failed: ("20") is not equal to ("USAGE: count-lines <input-file> [--prefix <prefix>] [--verbose]")
/Users/kotarosuto/Documents/oss/swift-argument-parser/Tests/ArgumentParserExampleTests/CountLinesExampleTests.swift:22: error: -[ArgumentParserExampleTests.CountLinesExampleTests testCountLines] : XCTAssertEqual failed: ("1") is not equal to ("10") - Strings have different numbers of lines.
/Users/kotarosuto/Documents/oss/swift-argument-parser/Tests/ArgumentParserExampleTests/CountLinesExampleTests.swift:22: error: -[ArgumentParserExampleTests.CountLinesExampleTests testCountLines] : XCTAssertEqual failed: ("4") is not equal to ("USAGE: count-lines <input-file> [--prefix <prefix>] [--verbose]")
Test Case '-[ArgumentParserExampleTests.CountLinesExampleTests testCountLines]' failed (0.730 seconds).
Test Case '-[ArgumentParserExampleTests.CountLinesExampleTests testCountLinesHelp]' started.
Test Case '-[ArgumentParserExampleTests.CountLinesExampleTests testCountLinesHelp]' passed (0.070 seconds).
Test Suite 'CountLinesExampleTests' failed at 2022-03-20 00:44:06.159.
	 Executed 2 tests, with 4 failures (0 unexpected) in 0.800 (0.800) seconds
```

Issue 428 - Author: natecook1000
None

Issue 427 - Author: natecook1000
Adding the platform requirement is a source breaking change; this moves the requirement down to the `async` symbols instead.

Fixes #426.

Issue 426 - Author: glbrntt
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace each paragraph
    below with the relevant details for your bug, and complete
    the steps in the checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Packages depending on swift-argument-parser which support older platforms are no longer able to compile.

This is a regression introduced in 1.1.0 where supported platforms were added to the package manifest. This raised the supported platforms from the defaults. This is a breaking change as packages depending on swift-argument-parser which support platforms older than those supported by this package are no longer able to compile (SPM will not resolve to a version of the package where appropriate platforms are supported).

Packages depending on swift-argument-parser must either raise their own supported platforms, require the version of swift-argument-parser to be less than 1.1.0, or remove their requirement on swift-argument-parser. 

**ArgumentParser version:** `1.1.0`

### Checklist

- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

Issue 425 - Author: compnerd
This adds `-parse-as-library` to the example targets which use `@main`
resulting in a compile failure as `@main` is not processed unless the
target is marked as library.

<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Replace this paragraph with a description of your changes and rationale. Provide links to an existing issue or external references/discussions, if appropriate.

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [ ] I've followed the code style of the rest of the project
- [ ] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 424 - Author: compnerd
Now that windows supports static linking as well (to a certain degree),
alter the build of swift-argument-parser in CMake to use static linking
for ArgumentParserToolInfo always irrespective of whether ArgumentParser
is being built as a static library or a dynamic library.  On Windows, in
release mode, this saves ~32KiB.  Additionally, because no tool directly
links against this library, no binaries are further expanded by static
linking, and we have one less file to distribute.

<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Replace this paragraph with a description of your changes and rationale. Provide links to an existing issue or external references/discussions, if appropriate.

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [ ] I've followed the code style of the rest of the project
- [ ] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 423 - Author: compnerd
This fixes the build with CMake after #404.

<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Replace this paragraph with a description of your changes and rationale. Provide links to an existing issue or external references/discussions, if appropriate.

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [ ] I've followed the code style of the rest of the project
- [ ] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 422 - Author: natecook1000
None

Issue 421 - Author: natecook1000
None

Issue 420 - Author: natecook1000
Updated documentation for the 1.1 release.

Issue 419 - Author: natecook1000
### Description
This removes the underscore from the parameter in `@OptionGroup(visibility:)`, making it a fully public API. This allows users to set the visibility for an entire option group at once.

### Detailed Design
This adds a single initializer to the `OptionGroup` type.

```swift
extension OptionGroup {
    init(visibility: ArgumentVisibility)
}
```

### Documentation Plan
Symbol documentation included.

### Test Plan
Updated tests for generating help.

### Source Impact
This deprecates, but doesn't remove, the no argument `OptionGroup` initializer.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](https://github.com/apple/swift-argument-parser/blob/main/CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 418 - Author: MartinP7r
I found a typo and realized some links were not working in the PR template.

No real code was harmed during the production of this PR. 😅 

### Checklist
- ~~I've added at least one test that validates that my change is working, if appropriate~~
- ~~I've followed the code style of the rest of the project~~
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md) 👈
- [x] I've updated the documentation if necessary


Issue 417 - Author: natecook1000
Previously, a `--help` flag could trigger the help screen when it should have been part of the parsed input for a command with an `.unconditionalRemaining` array parsing strategy.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary

Issue 416 - Author: natecook1000
The usage string feature that only shows positional args and required options/flags was incorrectly allowing through flags with type `Bool?`. For example, `--enable-foo` was incorrectly visible in the usage string for this type:

```swift
struct Example: ParsableCommand {
    // so many options
    // too many options

    @Flag(inversion: .prefixedEnableDisable)
    var foo: Bool?
}
```

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 415 - Author: zkiraly
The third code snippet in `ManualParsing.md` is this:

```swift
guard let options.elements.count >= options.count else {
    let error = ValidationError("Please specify a 'count' less than the number of elements.")
    SelectOptions.exit(withError: error)
}
```

However, this does not build, because `guard` is testing for inequality, not for unwrapping an optional. Removing `let` will make the code snippet correct, and it will build if inserted into an appropriate project.

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 414 - Author: buttaface
as there is no `XCTExpectFailure` in the OSS XCTest, which all these non-Darwin platforms rely on. #405 just [broke my daily Android CI](https://github.com/buttaface/swift-android-sdk/runs/5197310606?check_suite_focus=true#step:9:71) because these other platforms weren't excluded alongside linux, showing this error:
```
Tests/ArgumentParserUnitTests/HelpGenerationTests.swift:76:5: error: cannot find 'XCTExpectFailure' in scope
```
Tried it locally on my Android phone and this addition gets it building again.

@compnerd, I figured this breaks on Windows too, so went ahead and added it also.

Issue 413 - Author: rauhul
- Changes ArgumentVisibility from an enum to a struct. This will allow
  ArgumentParser to add cases in the future without breaking clients
  that could have been exhaustively switching across all cases. It also
  allows us to implement protocol on the internal type that and not
  expose their conformance on the public type.


Issue 412 - Author: natecook1000
This includes arguments, options, and flags that have `.hidden` visibility when a user requests the extended version of help with `--help-hidden`. Previously, only hidden option groups were included.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 411 - Author: rauhul
None

Issue 410 - Author: rauhul
- Updates helpMessage(columns:) and helpMessage(for:columns:) with an
  includeHidden argument defaulted to false to allow for clients to
  programmatically generate hidden help.

Issue 409 - Author: rauhul
- Adds help-hidden flags generated based on each ParsableCommand's help
  names. The help-hidden flag is only generated if the help names
  contain at least one .long name.

Issue 408 - Author: rauhul
None

Issue 407 - Author: rauhul
- Deprecates OptionGroup.init(_hiddenFromHelp:) and replaces it with
  OptionGroup.init(_visibility:).
- Updates ArgumentSetProvider to use _visibility.

Issue 406 - Author: rauhul
- Renames ArgumentHelp.Visibility to ArgumentVisibility.
- Replaces ArgumentDefinition.shouldDisplay with a visibility property
  whose value is derived from ArgumentHelp.visibility.

Issue 405 - Author: rauhul
- Replaces `ArgumentSet.init(_:creatingHelp:includeHidden:)` with
  `ArgumentSet.init(_:visibility:)`. `visibility` intentionally does not
  have a default value to ensure that callers only have the correct
  arguments. As part of this change `includeHidden` has been replaced
  throughout the codebase with `visibility`. This change also fixes a
  bug where arguments with hidden `visibility` were being displayed in the
  generated command usage string.

Issue 404 - Author: natecook1000
### Description
Adds an `AsyncParsableCommand` type that sports an `run() async` method, allowing for asynchronous code in a command line tool.

### Detailed Design
This includes the new `AsyncParsableCommand` protocol, which provides a `static func main() async` entry point and can call through to the root command's or a subcommand's asynchronous `run()` method. For this asynchronous execution, the root command must conform to `AsyncParsableCommand`, but its subcommands can be a mix of asynchronous and synchronous commands.

```swift
/// A type that can be executed as part of a nested tree of commands.
public protocol AsyncParsableCommand: ParsableCommand {
  mutating func run() async throws
}

extension AsyncParsableCommand {
  public static func main() async { ... }
}
```

Due to an issue in Swift 5.5, you can only use `@main` on an `AsyncParsableCommand` root command starting in Swift 5.6. This PR also includes a workaround for clients that are using Swift 5.5. Declare a separate type that conforms to `AsyncMainProtocol` and add the `@main` attribute to that type. For example:

```swift
@main enum Main: AsyncMain {
    typealias Command = <#command#>
}
```

`AsyncMainProtocol` is deprecated for Swift 5.6.

### Documentation Plan
There's a new example included (`count-lines`) that uses `AsyncParsableCommand` to read lines asynchronously, demonstrating the feature. A new guide for creating asynchronous commands is still TK.

### Test Plan
As an entry point, this feature is tested by invoking the built executable via a new test in `ArgumentParserExampleTests`.

### Source Impact
This change requires an upgrade in Swift versions to 5.5, but is otherwise source compatible. 

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 403 - Author: weissi
Much like `swift --help-hidden` and `clang --help-hidden`, argument parser should by default have a `--help-hidden` which shows you the usually hidden options.

The reason why some options are usually hidden from `--help` is because the developers want to be helpful to their users and show the recommended options. But many utilities have additional "developer options" which only make sense in very limited circumstances or aren't fully implemented etc. So it'd be bad to always show them but of course we should have a way to list them because having to dig through a binary to find them is tiring.

Please note that no extra information would be revealed, all the information about the available options are already in the binary and they could be extracted in a shell script or so.

Issue 402 - Author: grynspan
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your request, please replace each paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

**⚠️ Not ready for merging yet!**

### Description

This change introduces support for DOS-/Windows-style command line parsing. Historically, DOS and Windows have used a different set of rules for parsing their command-line arguments than POSIX-like or UNIX-like platforms like Linux, BSD, macOS, etc. Wikipedia has a decent write-up [here](https://en.wikipedia.org/wiki/Command-line_interface#Option_conventions_in_DOS,_Windows,_OS/2).

### Detailed Design

There are two commits:
- The first commit refactors snake case/camel case conversions to be more flexible. This is necessary in order to get the correct parsing behaviour using the DOS convention.
- The second commit actually adds the new parsing convention and plumbs it through.

An open problem is that this is a runtime configuration flag, but there's no good way to make it per-command state (e.g. a field on `CommandConfiguration`) without tendrils getting _eeeeeverywhere_. Thoughts/feedback/advice here would be good. For now, you control the parsing convention by setting `ParsingConvention.current = .dos` before calling `Command.main()`.

### Documentation Plan

TODO

### Test Plan

Existing tests continue to pass despite the refactor (a good thing.) I've added new tests confirm the basic assumptions of the code (i.e. that it can handle both conventions.) There's always room for more tests.

### Source Impact

There are a few symbol names including the phrase `withSingleDash` which, because DOS and Windows don't use dashes, is misleading. I've introduced replacement API named `withShortPrefix` instead and deprecated the existing symbols.

Because existing codebases expect POSIX-style parsing, DOS-style parsing is off by default even on Windows.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 401 - Author: dduan
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace each paragraph
    below with the relevant details for your bug, and complete
    the steps in the checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Similar to #344, when a `ExpressibleByArgument & CaseIterable` argument from user has incorrect value, the candidate values are shown in the error message **except** when said value is a member of an array.

**ArgumentParser version:** `1.0.3`.
**Swift version:** `swift-driver version: 1.26.21 Apple Swift version 5.5.2 (swiftlang-1300.0.47.5 clang-1300.0.29.30)`

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
With the following program:

```swift
import ArgumentParser

enum Noodle: String, CaseIterable, ExpressibleByArgument {
    case ramen
    case capellini
    case silkworm
}

@main
struct Dinner: ParsableCommand {
    @Argument
    var noodle: [Noodle]

    mutating func run() throws {
        print("Hmm, yummy \(noodle.first!).")
    }
}
```

Build and run with a wrong value for `noodle`. For a SwiftPM example

```swift
swift run dinner usbcable
```

### Expected behavior

The error message should include candidate values for `noodle` like:

```
Error: The value 'hello' is invalid for '<noodle>'. Please provide one of 'ramen', 'capellini' or 'silkworm'.
Help:  <noodle>
Usage: dinner <noodle>
  See 'dinner --help' for more information.
```

### Actual behavior

The output does not include candidate values for `noodle`

```
Error: The value 'hello' is invalid for '<noodle>'
Help:  <noodle>
Usage: dinner [<noodle> ...]
  See 'dinner --help' for more information.
```


Issue 400 - Author: natecook1000
### Description
This adds a `usage` property to `CommandConfiguration` that lets tool authors customize their command's usage string.

### Detailed Design

The `CommandConfiguration` type now has a `usage` property that defaults to a `nil` string. When non-`nil`, this string is used instead of the auto-generated usage string.

### Documentation Plan

Symbol documentation is included, but the Help article should be updated to show this additional API.

### Test Plan
Unit tests cover the new feature.

### Source Impact
This is an additive change, and requires a new initializer for `CommandConfiguration`. Since the new property has a default value, most existing source should not be affected. Source that references the old initializer (instead of just calling it) will receive a deprecation warning.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 399 - Author: natecook1000
None

Issue 398 - Author: KS1019
As of 9453b72, it seems that the documentation for experimental features was not properly generated, and the link on the first page redirects to "The page you’re looking for can’t be found." page.


Issue 397 - Author: natecook1000
This extends the current behavior of `@Argument` array properties defined with the `.unconditionalRemaining` parsing strategy to work with subcommands, as well. For example, with a command hierarchy like this:

```swift
@main
struct Root: ParsableCommand {
    static var configuration: CommandConfiguration {
        .init(subcommands: [Sub.self])
    }

    @Flag var verbose = false
}

struct Sub: ParsableCommand {
    @Argument(parsing: .unconditionalRemaining)
    var remainder: [String] = []

    @OptionGroup var root: Root

    func run() {
        print("Verbose:", root.verbose)
        print("Remainder:", remainder)
    }
}
```

We want the `Sub` command to capture any arguments after the subcommand name appears in the command-line arguments. This fix enables the following behavior:

```
$ root --verbose sub foo --bar
Verbose: true
Remainder: foo --bar
$ root sub foo --bar --verbose 
Verbose: false
Remainder: foo --bar --verbose
$ root --verbose sub foo --bar --verbose 
Verbose: true
Remainder: foo --bar --verbose
```

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 396 - Author: natecook1000
This includes some revisions to a few articles, and adds links to the documentation to the README.

Issue 395 - Author: McNight
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

This pull request harmonizes `Option` initializers abstracts by providing documentation to `completionKind` arguments.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 394 - Author: KS1019
This issue proposes a new bool parameter `isExperimental` to Flag and Option. 

## How it can be useful
With this parameter, we can possibly
- Automatically add `experimental` prefix
- Automatically remove the experimental Flags/Options from the help
- Automatically mark the experimental Flags/Options as experimental in the dumped JSON by `--experimental-dump-help`
- Only list experimental Flags/Options

With this parameter, users of ArgumentParser can easily mark Flag/Option as experimental and control the exposure of the Flag/Option to users of their tool.

Issue 393 - Author: imWildCat
With the Xcode 13.2.1 toolchain, it seems impossible to compile the example code within a Swift package.

**ArgumentParser version:** `1.0.2`
**Swift version:** 
```
swift-driver version: 1.26.21 Apple Swift version 5.5.2 (swiftlang-1300.0.47.5 clang-1300.0.29.30)
Target: arm64-apple-macosx12.0
```

### Checklist
- [ ] If possible, I've reproduced the issue using the `main` branch of this package
- [ ] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce

Create a swift `executable` package using the example code:

```swift
import ArgumentParser

@main
struct Repeat: ParsableCommand {
    @Flag(help: "Include a counter with each repetition.")
    var includeCounter = false

    @Option(name: .shortAndLong, help: "The number of times to repeat 'phrase'.")
    var count: Int?

    @Argument(help: "The phrase to repeat.")
    var phrase: String

    mutating func run() throws {
        let repeatCount = count ?? .max

        for i in 1...repeatCount {
            if includeCounter {
                print("\(i): \(phrase)")
            } else {
                print(phrase)
            }
        }
    }
}
```

### Expected behavior

This code can compile.

### Actual behavior

```shell
swift run        
/Users/username/Downloads/202201/temp/ProjectName/Sources/ProjectName/main.swift:3:1: error: 'main' attribute cannot be used in a module that contains top-level code
@main
^
/Users/username/Downloads/202201/temp/ProjectName/Sources/ProjectName/main.swift:1:1: note: top-level code defined in this source file
import ArgumentParser
^

error: fatalError
```


Issue 392 - Author: shahmishal
Testing Ubuntu 20.04 (Docker) PR testing

Issue 391 - Author: McNight
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

This PR marks an `Option` initializer as deprecated because it had its last 2 parameters inverted (help should be before completion, following order of all other initializers).
It also adds a new one with parameters in correct order.
It follows recommendations of @natecook1000 in issue https://github.com/apple/swift-argument-parser/issues/381.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 390 - Author: McNight
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

This pull request (as a draft for now) adds a new `ArgumentHelp.Visibility` API with multiple levels allowing to indicate whether help messages should be shown in the extended help display.
It follows suggestions made by @natecook1000 in issue https://github.com/apple/swift-argument-parser/issues/384.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 389 - Author: KS1019
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

I added a link to ExperimentalFeatures.md on ArgumentParser.md so that it is more discoverable by users.

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
N/A
- [ ] I've followed the code style of the rest of the project
N/A
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 388 - Author: mdznr
Corrects a number of typos that I saw throughout comments in the codebase.
| Original | Replacement |
|----|----|
| avaiable | available |
| favour | favor |
| occurence | occurrence |
| Onl | |
| propery | property |
| sinlge | single |
| suggetion | suggestion |
| tranform | transform |

### Checklist
- [N/A] I've added at least one test that validates that my change is working, if appropriate
- [N/A] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [N/A] I've updated the documentation if necessary


Issue 387 - Author: rauhul
- Fixes #375
- Fixes a bug with the experimental dump help generator which would
  occur when a ParsableCommand has non-Argument properties.


Issue 386 - Author: rauhul
- Fixes #369
- Adds an error check for the return value of GetConsoleScreenBufferInfo
  Windows. If GetConsoleScreenBufferInfo a default size of 80 by 25 is
  used.

Issue 385 - Author: rauhul
- Adds check to ensure that `wrapped(to:wrappingIndent:)` doesn't
  attempt to retrieve a negative prefix.
- The Usage struct was composed of an array of strings which always
  contained exact one string at runtime. This struct has been removed
  and replaced with a single usage string.
- Removes HelpGenerator._screenWidthOverride in favor of explicitly
  setting the screen width in generateHelp calls.


Issue 384 - Author: natecook1000
With the addition of a `--help-hidden` flag that displays an extended help screen (as in #366), command-line tool developers may want to specify a level of hidden-ness that isn't visible in that extended display. The `ArgumentHelp` type should be updated to include multiple levels of visibility instead of just using a Boolean value.

#### Existing functionality

```swift
// Hidden flag
@Flag(help: .hidden)
var experimentalExtraSpicy = false

// Hidden flag, but with abstract provided
@Flag(help: ArgumentHelp("Experimental extra sauce setting", shouldDisplay: false))
var experimentalExtraSauce = false
```

#### Proposed

A visibility API:

```swift
enum Visibility {
    /// Show help for this argument whenever appropriate
    case default

    /// Only show help for this argument in the extended help screen
    case hidden

    /// Never show help for this argument
    case private
}
```

...and its use at the declaration site:

```swift
// Hidden flag
@Flag(help: .hidden)
var experimentalExtraSpicy = false

// Hidden flag, but with abstract provided
@Flag(help: ArgumentHelp("Experimental extra sauce setting", visibility: .hidden))
var experimentalExtraSauce = false

// Private flag
@Flag(help: .private)
var deprecatedFlag = false
```


Issue 383 - Author: natecook1000
None

Issue 382 - Author: dduan
When an option value fails to parse, no custom error message is
provided, and a list of valid candidate values is available, include the
list as part of the error message.

Addresses #344.


### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 381 - Author: stevapple
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace each paragraph
    below with the relevant details for your bug, and complete
    the steps in the checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Let's say, it's possible to configure a `String`-typed option:
- with `help` text;
- with `completion`;
- with default value.

In fact, we can do either two of these, but combining three of these will cause compilation failure.

**ArgumentParser version:** `1.0.2`, `main`
**Swift version:** swift-driver version: 1.26.21 Apple Swift version 5.5.2 (swiftlang-1300.0.47.5 clang-1300.0.29.30)

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce

Minimal code to reproduce:

```swift
import ArgumentParser

struct Run: ParsableCommand {
    @Option(help: "", completion: .file())
    var string: String = ""

    func run() {}
}
```

Similar bug with `String?`:

```swift
@Option(completion: .file())
var string: String? = ""
```

### Expected behavior

Compile successfully.

### Actual behavior

```
main.swift:5:26: error: cannot convert value of type 'String' to expected argument type '[String]'
    var string: String = ""
                         ^
main.swift:5:9: error: property type 'String' does not match 'wrappedValue' type 'Array<String>'
    var string: String = ""
        ^~~~~~
main.swift:5:9: note: cannot automatically synthesize 'Decodable' because '<<error type>>' does not conform to 'Decodable'
    var string: String = ""
        ^
main.swift:3:8: error: type 'Run' does not conform to protocol 'Decodable'
struct Run: ParsableCommand {
       ^
Swift.Decodable:2:5: note: protocol requires initializer 'init(from:)' with type 'Decodable'
    init(from decoder: Decoder) throws
    ^
```

### Workaround

For anyone who encountered such error, you can workaround with a non-op `transform`:

```swift
// ✅ It works!
@Option(help: "", completion: .file(), transform: {String($0)})
var string: String = ""
```


Issue 380 - Author: soconnor-florio
I had a "verbose" flag for log output, but it was getting completely ignored and failed silently.

**ArgumentParser version:** `1.0.2`
**Swift version:** 
```
swift-driver version: 1.26.9 Apple Swift version 5.5.1 (swiftlang-1300.0.31.4 clang-1300.0.29.6)
Target: arm64-apple-macosx12.0
```

### Checklist
- [ ] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce

Create your own `ParsableCommand` with a flag such as:
```
struct MyCommand: ParsableCommand {

   // other boilerplate here.

    @Flag(name: .shortAndLong, help: "Whether to enable verbose logging.")
    var verbose = false
    
    mutating func run() throws {
      print("Verbose Logging Enabled: \(self.verbose)") // is ALWAYS false.
    
       // the rest of what you do here.
    }
}
```
If you include this flag in your command line arguments, it is not parsed as expected.

### Expected behavior
The Flag should be set to true when you `swift run MyCommand --verbose`

Stretch goal:  The compiler should fail or complain or warn about your variable name.

### Actual behavior
The argument --verbose is ignored and "fails silently"

### Workaround

make a custom flag name that doesn't begin with "v".  In this case "fatlog" did the trick.

Issue 379 - Author: natecook1000
This updates the README with links to the articles in the documentation archive, for easier discovery.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 378 - Author: leisurehound
its currently possible to add a -v version option to display the version of the application, however it requires any arguments to be set as optional and when -v is not supplied and the argument is also not provided, forces users to roll their own error condition for a missing argument.

Ideally, it would be better if a -v could be inherent like the -h, such that the required argument checking is bypassed and the version is simply reported without error and when the argument is missing and no -v is provided the normal error reporting is displayed.



Issue 377 - Author: floam
This PR has two minor changes for FishCompletionsGenerator.swift.

The first is related to the name of the fish function created that's used to determine whether to show completions or not, depending on the commandline entered thus far. Functions beginning with `__fish` **really** ought only be things internal to fish that are included with the shell. So prefix the function `_swift` instead.

Secondly, `set --local cmd` instead of `set cmd` - this ensures running the function does not accidentally clobber a global or universal variable.

Issue 376 - Author: floam
I was looking over some issues, and for fun cloned https://gitlab.com/frizlab-demo-projects/swift-argument-parser-example-for-pr-320 which was a test case for a problem that affected bash and not zsh for issue #320. Was just interested in verifying it had the correct behavior for fish. This is the first project using argument-parser I've compiled. It seems custom completions are not generated for fish at all. I expect there to be something executing  `---completion …` in the output?

```fish
$ example --generate-completion-script=fish
function __fish_example_using_command
    set cmd (commandline -opc)
    if [ (count $cmd) -eq (count $argv) ]
        for i in (seq (count $argv))
            if [ $cmd[$i] != $argv[$i] ]
                return 1
            end
        end
        return 0
    end
    return 1
end
complete -c example -n '__fish_example_using_command example' -f -r -l option1
```
```zsh
$ example --generate-completion-script=zsh
#compdef example
local context state state_descr line
_example_commandname=$words[1]
typeset -A opt_args

_example() {
    integer ret=1
    local -a args
    args+=(
        '--option1:option1:'
        ':arg:{_custom_completion $_example_commandname ---completion  -- arg $words}'
        '(-h --help)'{-h,--help}'[Print help information.]'
    )
    _arguments -w -s -S $args[@] && ret=0

    return ret
}


_custom_completion() {
    local completions=("${(@f)$($*)}")
    _describe '' completions
}

_example


Issue 375 - Author: KS1019
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace each paragraph
    below with the relevant details for your bug, and complete
    the steps in the checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

When I was using `--experimental-dump-help` with a command that has non-wrapped or default property, it showed the error
```
ArgumentParser/DumpHelpGenerator.swift:153: Fatal error: argument.kind must not be .default
```
caused by https://github.com/apple/swift-argument-parser/blob/e1465042f195f374b94f915ba8ca49de24300a0d/Sources/ArgumentParser/Usage/DumpHelpGenerator.swift#L153


**ArgumentParser version:** main
**Swift version:** swift-driver version: 1.26.9 Apple Swift version 5.5 (swiftlang-1300.0.31.1 clang-1300.0.29.1)
Target: x86_64-apple-macosx11.0

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
It can be reproduced if you add something like
```
var i: Int?
```
in math command from the examples.

### Expected behavior
It should output the JSON without including the default property.

### Actual behavior
It fails with the fatal error shown above.

It seems that this happens because default properties are not properly removed if `argument.help.isComposite` is false. The easy fix is to filter arguments based on their `Kind` and remove default prperties but I am not sure if that is the best way to go.

Issue 373 - Author: natecook1000
None

Issue 372 - Author: jakepetroules
#356 fixed compile failure on iOS, which happens if you are adding CLI support for a Mac Catalyst app.

This patch also fixes the tests compilation.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 371 - Author: philippzagar
The Argument Parser isn't able to parse an `Option` correctly in a very specific parameter setting (see example below). This may even result in wrongly parsed values.

**ArgumentParser version:** `1.0.1`
**Swift version:** `swift-driver version: 1.26.9 Apple Swift version 5.5.1 (swiftlang-1300.0.31.4 clang-1300.0.29.6)
Target: x86_64-apple-macosx12.0`

### Steps to Reproduce
The Argument Parser isn't able to parse an `Option` correctly if it is stated between a "normal" `Argument` and an `Argument` with the `unconditionalRemaining` setting.

Here an example:
```swift
struct ExampleCommand: ParsableCommand {
    @Argument(help: "Works as expected")
    var firstArg: String
    
    @Option(help: "Not recognized argument")
    var secondArg: String
    
    @Argument(parsing: .unconditionalRemaining, help:"Failure causing argument, especially the `unconditionalRemaining` option")
    var thirdArg: [String]
}
```

`swift run ArgumentParserExample --help` prints the following (for all tested swift-argument-parser versions, so v0.4.4 onwards):
```
OVERVIEW: Example Command that showcases bug in the swift-argument-parser

USAGE: example-command <first-arg> --second-arg <second-arg> [<third-arg> ...]

ARGUMENTS:
  <first-arg>             Works as expected 
  <third-arg>             Failure causing argument, especially the `unconditionalRemaining` option 

OPTIONS:
  --second-arg <second-arg>
                          Not recognized argument 
  --version               Show the version.
  -h, --help              Show help information.
```

A related run Command could look like the following: `swift run ArgumentParserExample test1 --second-arg=test2 test3 --test4 -t`

**[Repository](https://github.com/philippzagar/swift-argument-parser-bug-example)** containing example code reproducing the behavior described below. Try the different swift-argument-parser versions in the `Package.swift` file.

### Expected behavior
One would expect that all stated CLI parameters are parsed correctly and that they can be accessed containing the correct values.
Especially, the `secondArg` parameter ( --second-arg <second-arg>) is detected and parsed correctly.
Occurs correctly on v0.4.4 of the swift-argument-parser.

However, the `thirdArg` actually contains the `--second-arg=test2` from the run CMD mentioned above. This shouldn't be the case, as only the `secondArg` should contain the correct value (`test2`), which it also does in this scenario.

### Actual behavior
Starting with the swift-argument-parser v0.5 and up until the current v1.0.1 version, the parsing fails with the error message that the `secondArg` is missing (again, using the run CMD mentioned above):
```
Error: Missing expected argument '--second-arg <second-arg>'
Help:  --second-arg <second-arg>  Not recognized argument
Usage: example-command <first-arg> --second-arg <second-arg> [<third-arg> ...]
  See 'example-command --help' for more information.
```

Setting the name of the `Option` explicitly to `second-arg` (so `--second-arg`) within the initialization of the `Option` property wrapper doesn't change the behavior. 

As soon as the `unconditionalRemaining` option for the last `Argument` is deleted, the parsing is done correctly, under the condition that the passed parameters after the `--second-arg` are not `Option`'s on their own (so no `--test4` or `-t` anymore). Same behavior as soon as the first `Argument` (so `firstArg`) is deleted. 
As described in the example above, the `secondArg` parameter ( --second-arg <second-arg>) isn't being detected correctly.

It seems to me that the `.unconditionalRemaining` option to a certain extent is responsible for this incorrect behavior. However, as mentioned above, if the `firstArg` is deleted, the parsing is done correctly, even with the `.unconditionalRemaining` option (even with correct values of the parsed parameters!).

Issue 370 - Author: floam
Hi there,

I'm one of the core developers of the fish-shell, and I noticed recently that some of the binaries shipping with macOS appear to have some interesting null-terminated strings that look a whole lot like fish functions.

A couple commits enable us to easily query `shortcuts` and `kmutil` for fish completions (autoloaded after the user types the command name), https://github.com/fish-shell/fish-shell/blob/master/share/completions/shortcuts.fish and https://github.com/fish-shell/fish-shell/blob/master/share/completions/kmutil.fish. 

So, this isn't so much feedback about those two pieces of software, but just the mechanism in general this project is responsible for. 

First of all, neato! They work well. I've played around with them, and have a couple observations:

In `shortcuts view <TAB>`, for example, two things stand out: a) after entering subcommands, I am noticing the tab completions offering up useless file completions from my current directory. If there is any kind of mechanism for your generator to know whether or not files are appropriate input here, this is easily remedied, it could output `--no-files` or `--exclusive` right here and not send the user astray.

Secondly, again in e.g. `shortcuts view`, I know there are several acceptable arguments - the shortcut names output by `shortcuts list`. Would it be possible for this generator to know it could output something like `complete … -a '(shortcuts list)' … ` -- this is what I'd do by hand -- to dynamically do exactly that?

It would have to be able to produce those functions ahead of time to be evaluated at autoload time. Or if not that, another option is a way for developers to interrogate the binaries and ask them to complete strings, similar to clang. (which we use):

```fish
$ # their --autocomplete takes current partial command line. e.g.:
$ clang --autocomplete="-f"
-faapcs-bitfield-load	Follows the AAPCS standard that all volatile bit-field write generates at least one load. (ARM only).
-faapcs-bitfield-width	Follow the AAPCS standard requirement stating that volatile bit-field width is dictated by the field container type. (ARM only).
-faccess-control	
-faddrsig	Emit an address-significance table
-faggressive-function-elimination	
-falign-commons	
```

Here's a screen recording of the completions in action on fish if that is helpful to understand (the italicized grey text that appears after my cursor are not completions - those are fish's autosuggestions from my history, playing around with it earlier):

https://user-images.githubusercontent.com/291142/140467402-40033ab5-13e7-407a-adb6-bc1f7a9c7f21.mp4

Thanks!

Aaron Gyes

Issue 369 - Author: MaxDesiatov
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace each paragraph
    below with the relevant details for your bug, and complete
    the steps in the checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

When testing a CLI app  that depends on Swift Argument Parser on GitHub Actions on Windows, it crashes with this stack trace (full CI run logs available [here](https://github.com/MaxDesiatov/Kara/runs/4109994579?check_suite_focus=true), but the link may expire in a few days):

```
Swift/Collection.swift:1308: Fatal error: Can't take a prefix of negative length from a collection
2603
Current stack trace:
2604
0    (null)                             0x00007ff8aa77a550 swift_stdlib_reportFatalErrorInFile + 134
2605
1    (null)                             0x00007ff8aa419d70 _isStdlibInternalChecksEnabled() + 1932
2606
2    (null)                             0x00007ff8aa419d70 _isStdlibInternalChecksEnabled() + 864
2607
3    (null)                             0x00007ff8aa419d70 _isStdlibInternalChecksEnabled() + 179
2608
4    (null)                             0x00007ff8aa419830 _assertionFailure(_:_:file:line:flags:) + 521
2609
5    (null)                             0x00007ff8aa451c20 Collection.prefix(_:) + 1415
2610
6    (null)                             0x00007ff6ac6cab30 String.wrapped(to:wrappingIndent:) + 1070
2611
7    (null)                             0x00007ff6ac6a3180 HelpGenerator.Section.Element.rendered(screenWidth:) + 443
2612
8    (null)                             0x00007ff6ac6a4460 HelpGenerator.Section.rendered(screenWidth:) + 1650
2613
9    (null)                             0x00007ff6ac6b1030 type metadata accessor for HelpGenerator.DiscussionSection + 820
2614
10   (null)                             0x00007ff6ac6a4460 HelpGenerator.Section.rendered(screenWidth:) + 1700
2615
11   (null)                             0x00007ff8aa4058a0 Collection.map<A>(_:) + 597
2616
12   (null)                             0x00007ff6ac6a4460 HelpGenerator.Section.rendered(screenWidth:) + 644
2617
13   (null)                             0x00007ff6ac6abc20 HelpGenerator.rendered(screenWidth:) + 5202
2618
14   (null)                             0x00007ff6ac6b1030 type metadata accessor for HelpGenerator.DiscussionSection + 1615
2617
15   (null)                             0x00007ff6ac6aec20 BidirectionalCollection<>.dumpHelpArgumentDefinition() + 2004
2619
16   (null)                             0x00007ff8aa4058a0 Collection.map<A>(_:) + 597
2620
17   (null)                             0x00007ff6ac6abc20 HelpGenerator.rendered(screenWidth:) + 782
2621
18   (null)                             0x00007ff6ac6b21c0 MessageInfo.init(error:type:) + 10606
2622
19   (null)                             0x00007ff6ac627d70 static ParsableArguments.exit(withError:) + 337
2623
20   (null)                             0x00007ff6ac6394f0 static ParsableCommand.main(_:) + 471
2624
21   (null)                             0x00007ff6ac639720 static ParsableCommand.main() + 72
2625
22   (null)                             0x00007ff6ac8ed060 main + 35
2626
23   (null)                             0x00007ff6ac8ed060 main + 720
2627
24   (null)                             0x00007ff8dc857960 BaseThreadInitThunk + 20
2628
25   (null)                             0x00007ff8df66a2d0 RtlUserThreadStart + 33
```

I'd assume the root cause of this is that screen width is inferred to have some amount of columns less than desired indentation, possibly 0? Thus `HelpGenerator.Section.Element.rendered(screenWidth:)` is called with that invalid screen width passed.

I don't know what the best fix should be. Maybe some default screen width value on Windows for such CI runs? I'm not sure how this is handled on other platforms.

**ArgumentParser version:** `1.0.1` or the `main` branch.
**Swift version:** Reproducible with Swift 5.4 and 5.5

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
Make app depending on Swift Argument Parser print help info on GitHub Actions Windows hosts.

### Expected behavior
The app should print help info successfully.

### Actual behavior
The app crashes with the stacktrace shared above.


Issue 368 - Author: griffin-stewie
Xcode 13.2 Beta is released now. We are getting closer to use Swift Concurrency in the real life. I wish [async branch](https://github.com/apple/swift-argument-parser/tree/async) will be merged.

Thank you.

Issue 367 - Author: keith
Swift 5.5+ Swift Package Manager warns that `--enable-test-discovery` is
enabled by default. I assume for this project that should mean this
isn't needed anymore on `main`.

Issue 366 - Author: keith
Swift Package Manager adopted _hiddenFromHelp, the resulting help is
much more approachable for basic usage, but leaves no way to view
all the advanced options it accepts. This takes from swiftc's + clang's
playbook and adds a hidden `--help-hidden` flag that prints all help,
including those using `_hiddenFromHelp`

Related: https://bugs.swift.org/browse/SR-15224

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 365 - Author: keith
This test covers the cast that an invalid long argument is not mistaken
for any other argument with a similar prefix.

Issue 364 - Author: CraigSiemens
### Related issues and PRs

- #277 
- #284 

### Description
This adds onto the fix from #284 that added support for commands with dashes in the name. 

When getting completions for an argument using `CompletionKind.custom(...)` an error occurs. #284 updated [a variable](https://github.com/apple/swift-argument-parser/pull/284/files#diff-b243e9c8a946a341ab514c2d5ce1b9f27a3bb6cf672b14ab02f0d221a491d645R20) but missed updating where that variable is used to also escape the command name.

This updates the usage of that variable to also escape the command name and updates the tests to check for it.

### Example
If I have a command called `cli-tools` with an argument that has a `CompletionKind.custom(...)`, typing `cli-tools a` then pressing tab will produce the following error.

```
cli-tools a_custom_completion:1: command not found: -tools_commandname
_custom_completion:1: command not found: -tools_commandname
  cli-tools a
```

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary

Issue 363 - Author: yonihemi
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Adds support for building WebAssembly binaries targeting [WASI](https://wasi.dev/) using [SwiftWasm](https://swiftwasm.org/) toolchains.

### Minor variations
- `EX_USAGE` is not exposed by WASI so a generic exit code of 1 is returned for validation failures.
- Terminal size is not supported so a default is returned.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
	- Running compiled SwiftWasm binary requires an external runtime. I've added a sample project with binary and instructions in [another repo](https://github.com/yonihemi/use-argument-parser/).
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary
	- N/A


Issue 362 - Author: atierian
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Fixed various links in documentation articles that were broken by file name changes.
Manually validated change - test checklist item is not applicable. 

### Checklist
- [ ] ~I've added at least one test that validates that my change is working, if appropriate~
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 361 - Author: fractaldragonflies
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace the paragraph
    below with information about your proposed feature.
-->

Xcode made it pretty easy to add argument-parser dependencies, but it took me awhile to figure out that I had to also argument-parser to the 'Link Binary with Libraries' element as well.  Otherwise not of the argument-parser references get resolved and my project has lots of red errors!

BTW, the @main annotation in the readme.md example also errors in Xcode. 
Great work. Thanks.

Issue 360 - Author: KS1019
This PR resolves #358 and adds new documentation for experimental features. 

Currently, there is only one experimental feature so it is quite short since I wanted to keep it simple. I have created a separate file because I believe there could be more experimental features in the future.

If there is other information that could be useful/should be added, please let me know.

Suggestions on wording choices, grammar, or anything are also much appreciated!

### Checklist
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 359 - Author: acoomans
Initializing a `ParsableCommand` with a value does not work, but setting it after initialization does.

**ArgumentParser version:** `0.3.0`
**Swift version:** `swift-driver version: 1.26.9 Apple Swift version 5.5 (swiftlang-1300.0.31.1 clang-1300.0.29.1) Target: x86_64-apple-macosx11.0`

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce

Set up a `ParsableCommand` with 2 independent sub-`ParsableCommand`, and 1 `all` sub-`ParsableCommand` that runs both of the sub-`ParsableCommand`:

```
import Foundation
import ArgumentParser

enum EndpointFlag: String, EnumerableFlag {
    case local
    case staging
    case prod
}

struct SwiftScript: ParsableCommand {

    static var configuration = CommandConfiguration(
            subcommands: [DownloadSchema.self, GenerateCode.self, DownloadSchemaAndGenerateCode.self])

    struct DownloadSchema: ParsableCommand {
        static var configuration = CommandConfiguration(...)

        @Flag(exclusivity: .exclusive, help: "...") var endpointFlags: EndpointFlag = .local
        
        func run() throws {...}
    }
    
    struct GenerateCode: ParsableCommand {
        static var configuration = CommandConfiguration(...)
        
        func run() throws {...}
    }

    struct DownloadSchemaAndGenerateCode: ParsableCommand {
        static var configuration = CommandConfiguration(...)

        @Flag(exclusivity: .exclusive, help: "...") var endpointFlags: EndpointFlag = .local

        func run() throws {
		
			// working code
			var downloadSchema = DownloadSchema()
			downloadSchema.endpointFlags = endpointFlags
			try downloadSchema.run()
			// end working code
		
			// NOT working code
			try DownloadSchema(endpointFlags: endpointFlags).run()		
			// end NOT working code

			try GenerateCode().run()
        }
    }
}

SwiftScript.main()
```

### Expected behavior

When called with `swift run SwiftScript downloadSchemaAndGenerateCode`, it should run both commands successfully, i.e:

1. run `DownloadSchemaAndGenerateCode`, take its `endpointFlags` value, and 
2. pass it down to `DownloadSchema`, which should run with the right `endpointFlags` value, and 
3. finally run `GenerateCode`.


### Actual behavior

`swift run SwiftScript downloadSchemaAndGenerateCode` stops and outputs the following error message:

```
ArgumentParser/Flag.swift:103: Fatal error: 
--------------------------------------------------------------------
Can't read a value from a parsable argument definition.

This error indicates that a property declared with an `@Argument`,
`@Option`, `@Flag`, or `@OptionGroup` property wrapper was neither
initialized to a value nor decoded from command-line arguments.

To get a valid value, either call one of the static parsing methods
(`parse`, `parseAsRoot`, or `main`) or define an initializer that
initializes _every_ property of your parsable type.
--------------------------------------------------------------------

zsh: illegal hardware instruction  swift run SwiftScript all --staging
```



Issue 358 - Author: KS1019
ArguementParser now has a built-in `--experimental-dump-help` flag which is not documented (as far as I know).

I believe we should have a section for listing experimental features like this one and possibly other experimental features coming in the future with some explanation and possibly some use cases too. That will encourage users of the library to _play_ with those features and hopefully, we can get feedback on those features.

Issue 357 - Author: natecook1000
None

Issue 356 - Author: imxieyi
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

This PR fixes compile failure on iOS, which happens if you are adding CLI support for a Mac Catalyst app. Specifically, it fixes:
```
'sortedKeys' is only available in iOS 11.0 or newer
```

### Checklist
- [N/A] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [N/A] I've updated the documentation if necessary


Issue 355 - Author: natecook1000
None

Issue 354 - Author: natecook1000
None

Issue 353 - Author: natecook1000
When capturing the values for an option with a single-dash with the .upToNextOption
parsing strategy, the parser was stopping its search for values when it encountered
the "unpacked" short option candidates. This change removes the single-dash option
before looking for values, which strips those short options (e.g. -h) from
consideration.

This fixes #327.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 352 - Author: rauhul
None

Issue 351 - Author: natecook1000
None

Issue 350 - Author: natecook1000
### Description
This marks the two entry points of the "dump help" feature as experimental.

### Detailed Design
1. The `--dump-help` flag is now `--experimental-dump-flag`
2. The `dumpMessage()` method on `ParsableArguments` has been renamed to `_dumpHelp()`

### Documentation Plan
This feature isn't covered in the documentation yet.

### Test Plan
Updated the test with new names, as above.

### Source Impact
None — this feature hasn't yet shipped in a release.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 349 - Author: compnerd
The changes in #335 introduced a new library but failed to actually
build the library and update the dependency structure.  Update the build
system to build and install the new target.

<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Replace this paragraph with a description of your changes and rationale. Provide links to an existing issue or external references/discussions, if appropriate.

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [ ] I've followed the code style of the rest of the project
- [ ] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 348 - Author: racer1988
We are unable to use SPM, can you support CocoaPods

Issue 347 - Author: natecook1000
This change upgrades the existing documentation to support the articles and symbol documentation ingested by DocC.


Issue 346 - Author: Blackjacx
I'm trying to solve the issue that Xcode cannot determine the correct deployment target for this project. See issue https://github.com/apple/swift-argument-parser/issues/345. I also raised the Swift tools version to 5.5. 

Functionality can be tested by using this version with the project https://github.com/Blackjacx/Assist/tree/async-await on the branch `async-await`.

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 345 - Author: Blackjacx
I just installed Xcode 13 Beta 5 13A5212g and now I get the errors below when building my root package [Assist](https://github.com/Blackjacx/Assist/tree/async-await) from branch `async-await`. In a previous version this worked without problems. I just upgraded macOS to the newest beta and downloaded the latest Xcode. I wonder why you don't specify any platform versions in Package.swift. Since Async await is only working in macOS 12 and argument parser is only for macOS I'd expect something like 

```
platforms: [
    .macOS(.v12)
]
```

The errors I get are the following:

```
~/Library/Developer/Xcode/DerivedData/Assist-bpeugmbecnlglscpsxjqdloqyduu/SourcePackages/checkouts/swift-argument-parser/Sources/ArgumentParser/Parsable Types/ParsableCommand.swift:31:23: error: concurrency is only available in macOS 12.0.0 or newer
  mutating func run() async throws
```

![Screen Shot 2021-08-18 at 15 13 06](https://user-images.githubusercontent.com/794372/129904239-b0af90e5-bdf8-4825-ba96-edee81f77f58.png)

I can build my package on command line via 
`swift build "-Xswiftc" "-target" "-Xswiftc" "x86_64-apple-macosx12.0"`

But not in Xcode :(

Anything I'm missing?

Issue 344 - Author: BadPirate
When using ExpressibleByArgument for an enum @Option, neither help nor error message correctly shows available options.

**ArgumentParser**: main
**Swift version:** Apple Swift version 5.3.1

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
Create an option:

```
    enum Config : String, ExpressibleByArgument, CaseIterable
    {
        case ios, mac, simulator
    }
    
    @Option(help: "Build configuration")
    var config : [Config] = [.ios]
```

See command help screen using -h, or use the config option with an illegal value:

```
cli command --config invalid
```

### Expected behavior
1. Help should show options available
2. Error message should show valid options

### Actual behavior

1. Help Provides no options.
2. Error provides no useful options:
  
  ```
  Error: The value 'invalid' is invalid for '--config <config>'
  Usage: cli command [--config <config> ...] 
    See 'cli command --help' for more information.
  ```  

Issue 343 - Author: Frizlab
Currently the completion script is auto-generated from ArgumentParser and cannot be modified.
In some (rare) projects this auto-generated completion script can be unadapted. We should be able to customize it to our particular needs.

Issue 342 - Author: natecook1000
ArgumentParser version 0.4.3 added an experimental feature for hiding option groups at the command level, which is triggering a runtime crash when commands are compiled in release mode, as described in #338 and rdar://80796582. This includes changes that work around both of those crashes. I'll cherry pick this change over to the current release as 0.4.4 as well.

Issue 341 - Author: rauhul
- Adds an overload of ArgumentDefinition.init with a generic constraint
  on ExpressibleByArgument that propogates the conformance to the
  construction of ArgumentDefinition.Help. This allows the
  allValueStrings of the type conforming to ExpressibleByArgument to
  become the allValues property of the help object.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary

Fixes #340 

Issue 340 - Author: rauhul
`ArgumentDefinition.help.allValues` is empty for a `String, CaseIterable, ExpressibleByArgument` enum.

**ArgumentParser version:**
```
main
```
**Swift version:**
```
Apple Swift version 5.3.1 (swiftlang-1205.0.16.11 clang-1205.0.19.6)
Target: x86_64-apple-darwin20.3.0
```

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
Run the attached sample, observe assertion firing.

### Expected behavior
The contents of `opt.help.allValues` should be the same as `Fruit.allValueStrings`.

### Actual behavior
The contents of `opt.help.allValues` is empty.

### Sample Code
[repro.zip](https://github.com/apple/swift-argument-parser/files/6852622/repro.zip)



Issue 339 - Author: natecook1000


Issue 338 - Author: griffin-stewie
It crashes(SIGABRT) on Release build when I use Transform closure.

I tested several versions bellow. Only v0.4.3 has this issue.

- ✅ 0.3.2
- ✅ 0.4.0
- ✅ 0.4.1
- ✅ 0.4.2
- ‼️ 0.4.3
- ‼️ main branch

**ArgumentParser version:** `0.4.3`
**Swift version:** Apple Swift version 5.4 (swiftlang-1205.0.26.9 clang-1205.0.19.55) Target: x86\_64-apple-darwin20.5.0

### Checklist

- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce

[Here](https://github.com/griffin-stewie/sample_cal) is my sample code to reproduce this issue.

1. Build sample code with Release configuration.
2. Run this `sample_cal description --start-date 2021/07/18_11:22:33 --name aaa`

I suspect that the crash is caused by using `@Option(name: , help: , transform: )`.

One more thing, It prints a blank where `start: Date` should be printed, if I deleted `@Option() var name: String`.

### Expected behavior

No crash, and prints OptionGroup’s description.

### Actual behavior

Crashed.

Xcode shows some logs on console, like bellow:

```
sample\_cal(687,0x10026fe00) malloc: Double free of object 0x105a47cc0
sample\_cal(687,0x10026fe00) malloc: \*\*\* set a breakpoint in malloc\_error\_break to debug
```

Issue 337 - Author: daltonclaybrook
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace the paragraph
    below with information about your proposed feature.
-->

I'd like the ability for an input to be able to work as both a Flag and an Option in my CLI. For example, I would want both of the following examples to be possible:
```bash
$ example --build
# and
$ example --build Foo Bar
```
The first case would parse to `build: []` and the second case to `build: ["Foo", "Bar"]`. I tried making this work in two ways. First I tried making an `@Option` with a type of `[String]? = nil` and using a custom transform closure. My assumption was that passing `--build` without a value would pass an empty string to the transform closure. Instead, the CLI emits the following error when running:
```
Error: Missing value for '--build <build>'
```

The second strategy I tried was creating two separate fields, making one a `@Flag` and one an `@Option`, and giving them the same name. This time, I got an assertion failure:
```
ArgumentParser/ParsableArguments.swift:243: Fatal error: Validation failed for `Example`:
- Multiple (2) `Option` or `Flag` arguments are named "--build".
```

The first strategy—the one that uses only a single `@Option` field—seems the most ergonomic to me. I could also picture using a new initializer parameter to `@Option` e.g. `allowsMissingValue: Bool`, etc. My apologies if this is already possible and I just didn't dig hard enough.

Issue 336 - Author: compnerd
Repair the build after #310 to allow building with CMake which is required for bootstrapping.

<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Replace this paragraph with a description of your changes and rationale. Provide links to an existing issue or external references/discussions, if appropriate.

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [ ] I've followed the code style of the rest of the project
- [ ] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 335 - Author: rauhul
- Removes `HelpInfo` in favor of a recursively defined `CommandInfo`
  which contains more raw metadata about the source command.
  Additionally, introduces a top level `ToolInfo` type with a
  serialization version to aid future tooling.

- Updates tests to match the new serialized format.

- Renames `DumpHelpInfoGenerator` to `DumpHelpGenerator` to align the
  type with the `--dump-help` flag.

Issue 334 - Author: eneko
README file incorrectly referenced 'minor' version when it should be 'patch' version.

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [ ] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 333 - Author: natecook1000
If a command defines an `@Argument` property with the `.unconditionalRemaining` parsing strategy, we need to stop parsing input when we encounter either a positional argument or an unrecognized option/flag label. Note that this is a change in behavior, as seen in the modified test.

Resolves #331.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 332 - Author: rauhul
- Adds a swift package manager command plugin called
  GenerateManualPlugin. The plugin can be invoked from the command line
  using `swift package experimental-generate-manual`. The plugin is
  prefixed for now with "experimental-" to indicate it is not mature and
  may see breaking changes to its CLI and output in the future. The
  plugin can be can be used to generate a manual in MDoc syntax for any
  swift-argument-parser tool that can be executed via
  `tool --experimental-dump-info`.
- The plugin works by converting the `ToolInfoV0` structure from the
  `ArgumentParserToolInfo` library into MDoc AST nodes using a custom
  (SwiftUI-esk) result builder DSL. The MDoc AST is then lowered to a
  string and written to disk.
- The MDoc AST included is not general purpose and doesn't represent the
  true language exactly, so it is private to the underlying
  `generate-manual` tool. In the future it would be interesting to
  finish fleshing out this MDoc library and spin it out, however this is
  not a priority.
- Next steps include:
  - Improving the command line interface for the plugin.
  - Adding support for "extended discussions" to Commands and exposing
    this information in manuals.
  - Further improve the escaping logic to properly escape MDoc macros
    that might happen to appear in user's help strings.
  - Ingesting external content a-la swift-docc so the entire tool
    documentation does not need to be included in the binary itself.
  - Bug fixes and addressing developer/user feedback.

Built with love,
@rauhul

Issue 331 - Author: didix21
After updating from Swift 5.3.1 to 5.4, I'm observing that the behaviour of how swift-argument-parser handle options with the same name from two different commands has changed. For example, If I run the following commands in Swift 5.3.1:

- Swift 5.3.1
```bash
>> swift run --configuration debug shusky install --configuration ownconfig
output: "shusky configuration: ownconfig"
>> swift run shusky install --configuration ownconfig
output: "shusky configuration: ownconfig"
```

the result is `swift run --configuration` gets the value of `debug`, and `shusky install --configuration` gets `ownconfig`, but If I run the same commands in Swift 5.4:

- Swift 5.4
```bash
>> swift run --configuration debug shusky install --configuration ownconfig
output: "error: The value 'ownconfig' is invalid for '--configuration <configuration>'"
>> swift run shusky install --configuration ownconfig
output: "error: The value 'ownconfig' is invalid for '--configuration <configuration>'"
```

as we can see, `swift run --configuration` gets the value of `ownconfig` for this reason is telling us ownconfig is invalid.

**ArgumentParser version:** `0.3.2`
**Swift version:** Apple Swift version 5.4 (swiftlang-1205.0.26.9 clang-1205.0.19.55)
Target: arm64-apple-darwin20.5.0.

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
You need a command line tool which contains options with similar names from swift run options, and then run:
`swift run --configuration release <cli-tool> --configuration anyconf`.

### Expected behavior
Swift 5.4 must have the same behaviour as Swift 5.3.1. 

### Actual behavior

- Swift 5.4
```bash
>> swift run --configuration debug shusky install --configuration ownconfig
output: "error: The value 'ownconfig' is invalid for '--configuration <configuration>'"
>> swift run shusky install --configuration ownconfig
output: "error: The value 'ownconfig' is invalid for '--configuration <configuration>'"
```


Issue 330 - Author: ileitch
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace the paragraph
    below with information about your proposed feature.
-->

I'm working on an app that supports persisting configuration to a YAML file. When the app boots, configuration is read from the YAML, followed by arguments from the command line. I only want to apply the command line value if it was explicitly provided, otherwise the value from the YAML is used. Currently I've implemented this as follows:

```swift
@Flag(help: "Some flag.")
var someFlag: Bool = false

func run() throws {
    let config = Configuration()
    config.loadFromYAML()

    if CommandLine.arguments.contains({ $0.hasSuffix("some-flag") }) {
        config.someFlag = someFlag
    }
}
```

This works, but the need to duplicate the argument name isn't great. I'd like for SAP to handle this ability, or at least expose the flag name somehow. I'm thinking a `projectedValue` from the property wrapper might be a nice solution, e.g:

```swift
if $someFlag.isExplicit {
    config.someFlag = someFlag
}
```

Thoughts?



Issue 329 - Author: atierian
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Fixed minor syntax error in Documentation/06 Manual Parsing and Testing.md

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 328 - Author: varungandhi-apple
The [Python library Gooey](https://github.com/chriskiehl/Gooey) automagically converts commandline applications using argparse to GUI applications using wxPython.

> At run-time, it parses your Python script for all references to ArgumentParser. (The older optparse is currently not supported.) These references are then extracted, assigned a component type based on the 'action' they provide, and finally used to assemble the GUI.

It has a bunch of ways of customizing the GUI output as well.

Would it be possible to make something similar that sits on top of ArgumentParser to autosynthesize a GUI, say using SwiftUI?

Found via [HackerNews](https://news.ycombinator.com/item?id=27490291).

Issue 327 - Author: SquircleCode-M
For this code
````
@Option(name: [.customLong("arrayArgumentWhatever", withSingleDash: true)],
            parsing: .upToNextOption,
            help: """
            Lorem IPSUM LOREM IMPSUM
            """)
    var arrayArgumentWhatever: [String]
````
When pass this:

`./Example --whatever value --whatever2 value --whatever3 value --whatever4 value --whatever5 value -arrayArgumentWhatever 03ade86c0 8f2058e3ade86c84ec5b`


The argument  in function `func checkForBuiltInFlags(_ split: SplitArguments)` contains an h, so cli displays help

```
64 : -h
      ▿ value : Value
        ▿ option : -h
          ▿ name : Name
            ▿ short : 2 elements
              - .0 : "h"
              - allowingJoined : false
```

**ArgumentParser version:** `0.4.3`
**Swift version:** swift-driver version: 1.26 Apple Swift version 5.5 (swiftlang-1300.0.19.104 clang-1300.0.18.4)
Target: x86_64-apple-macosx11.0

### Checklist
- [X] If possible, I've reproduced the issue using the `main` branch of this package
- [X] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)



Issue 326 - Author: sergiocampama
async/await is useful for writing clean and concise code for building small CLI tools, especially ones that interact with the network or the file system.

Since `@main` now supports an async variant, I was able to add such support to a prototype with the following code:

```
// entry.swift

@available(macOS 12.0, *)
protocol AsyncParsableCommand: ParsableCommand {
    mutating func runAsync() async throws
}

extension ParsableCommand {
    static func main(_ arguments: [String]? = nil) async {
        do {
            var command = try parseAsRoot(arguments)
            if #available(macOS 12.0, *), var asyncCommand = command as? AsyncParsableCommand {
                try await asyncCommand.runAsync()
            } else {
                try command.run()
            }
        } catch {
            exit(withError: error)
        }
    }
}

struct MainCommand: AsyncParsableCommand {
    @Option()
    var name: String = "Anon"

    func runAsync() async throws {
        print("Hello, \(name)")
        // await something...
    }
}

@main
struct MainApp {
    static func main() async {
        await MainCommand.main()
    }
}
```

Having this be officially supported by swift-argument-parser would be ideal.

Issue 325 - Author: griffin-stewie
It prints a help message when I pass a dash symbol even quoted.

**ArgumentParser version:** `0.4.3`
**Swift version:** Apple Swift version 5.4 (swiftlang-1205.0.26.9 clang-1205.0.19.55) Target: x86_64-apple-darwin20.5.0

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce

[Here](https://github.com/griffin-stewie/my_echo) is my sample project to test.

Pass double-quoted string as an argument.

### Expected behavior

`my_echo "- [Apple](https://apple.com)"` → `- [Apple](https://apple.com)`

### Actual behavior

It prints the help message of this command.


Issue 324 - Author: dirtyhabits97
Hi, these changes should fix #314.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 323 - Author: Frizlab
In Bash, when calling completion for an executable written with full path (e.g. `/opt/brew/bin/example`), the completion script might call another executable if another executable with the same name happens to be first in the PATH. (This is particularly annoying when debugging completion in a project!) This PR fixes that.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 322 - Author: rauhul
Swift argument parser doesn't handle properties with the same name under different option groups gracefully.

The following snippet throws an error when run with no arguments, but I would expect no required arguments:
```swift
import ArgumentParser

struct Foo: ParsableCommand {
    @Option(name: .long)
    var `bar`: String = ""

    @OptionGroup
    var group: Group
    
    func run() throws { }
}

struct Group: ParsableArguments {
    @Option(name: .customLong("baz"))
    var `bar`: String?
}

Foo.main()
``` 

**Output:**

```bash
Error: Missing one of: '--bar <bar>', '--baz <baz>'

USAGE: foo [--bar <bar>] [--baz <baz>]

OPTIONS:
  --bar <bar>
  --baz <baz>
  -h, --help              Show help information.
```

**ArgumentParser version:** `0.4.3`
**Swift version:**
```
swift-driver version: 1.20.1 Apple Swift version 5.5 (swiftlang-1300.0.13.7 clang-1300.0.15.1)
Target: arm64-apple-macosx11.0
```

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

Issue 321 - Author: Frizlab
At first I noticed a crash when running the tests of this project. It was due to weird chars in my CWD.
This lead me to discover a bug where the default value description of a URL checks for the `absoluteString` value of itself instead of the path + whether it is a file URL!

Note: I did not add a test specifically, I don’t really know how this would be tested. Maybe create a folder with a weird name and check everything is good? Also a test with an https URL as default w/ a path being the same as current CWD?
Tell me, I’ll do them if needed.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 320 - Author: Frizlab
I’ve noticed when using a custom completion in bash, the custom completion handler does not receive all the arguments as would be expected. This PR fixes that.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 319 - Author: Azoy
This is an initial draft of subcommand auto discovery using reflection to find a list of protocol conformances to `ParsableCommand` and looking for nested types who conform to said protocol.

I haven't added any new tests, but I've changed some of the existing tests which essentially tests this functionality. There are still tests who have subcommands who aren't nested, thus they still use the subcommand array in `CommandConfiguration` which allows us to test that user defined subcommands also still work. If specific tests are needed, I'll be happy to add them! This is marked WIP because there are still some more documentation needed to fully explain this feature.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 318 - Author: compnerd
apple/swift-argument-parser#315 added a new file but failed to update
the CMakeLists.txt, resulting in the inability to bootstrap the
toolchain.

<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Replace this paragraph with a description of your changes and rationale. Provide links to an existing issue or external references/discussions, if appropriate.

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [ ] I've followed the code style of the rest of the project
- [ ] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 317 - Author: swiftyfinch
It's the solution for issue #307
The author closed the issue, but I still need this one.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary

Didn't find any documentation about using arrays in Option properties.

Issue 316 - Author: rauhul
- Removes unused codepaths.
- Simplifies synopsis string codepaths by removing optionality. This
  complexity is moved to the caller who is now responsible for filtering
  out hidden arguments and options. This change is desirable as it
  allows the caller to determine if the argument should be hidden. For
  example, while it makes sense to hide arguments in help text, it may
  not make sense to hide them when dumping the arguments for another
  tool to consume.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 315 - Author: rauhul
- Removes one layer of help properties by directly including the members
  of ArgumentHelp in ArgumentDefinition.Help. This also results in the
  discussion field which previously existed in both structures, now
  having a single source of truth. Adds helper method for setting each
  of these members using an instance of ArgumentHelp and additionally
  annotates each of the String? members with a new `@NonEmpty` property
  wrapper that ensures the wrapped string is either nil or nonempty so
  clients no do not need to check for the empty string case.

Replace this paragraph with a description of your changes and rationale. Provide links to an existing issue or external references/discussions, if appropriate.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 314 - Author: natecook1000
As with #282, the error output when a user doesn't provide a required value should include the help text for that argument or option.

```swift
struct Example: ParsableCommand {
    @Argument(help: "The number of items")
    var count: Int

    @Option(help: "The verbosity level")
    var verbosity: Int
}
```

**Existing:**

```
$ example --verbosity
Error: Missing value for '--verbosity <verbosity>'
Usage: example <count> --verbosity <verbosity>
  See 'example --help' for more information.
$ example --verbosity 3
Error: Missing expected argument '<count>'
Usage: example <count> --verbosity <verbosity>
  See 'example --help' for more information.
```

**Improved:**

```
$ example --verbosity
Error: Missing value for '--verbosity <verbosity>'
Help:  --verbosity <verbosity>  The verbosity level 
Usage: example <count> --verbosity <verbosity>
  See 'example --help' for more information.
$ example --verbosity 3
Error: Missing expected argument '<count>'
Help:  <count>  The number of items 
Usage: example <count> --verbosity <verbosity>
  See 'example --help' for more information.
```

Note that the existing behavior of printing the full help along with an error message should be maintained if the user provides _no_ arguments at all:

```
$ example
Error: Missing expected argument '<count>'

USAGE: example <count> --verbosity <verbosity>

ARGUMENTS:
  <count>                 The number of items

OPTIONS:
  --verbosity <verbosity> The verbosity level
  -h, --help              Show help information.
```

Issue 313 - Author: erica
I'm leaving this here because it may or may not be worth looking into. When using Swift Package Manager,  `swift package init --help` has the entry " --type <type>           (default: library)" corresponding to

@Option(name: .customLong("type"), help: "Package type: empty | library | executable | system-module | manifest")

Why doesn't it show the full help message?

Issue 312 - Author: natecook1000
It appears this issue was fixed some time in the past; closes #278.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 311 - Author: natecook1000
This change adds a `--repo` option to the `changelog-authors` tool that lets it work with other repositories. (I've been using it to help with Swift Algorithms changelog entries.

### Checklist
- [ ] ~I've added at least one test that validates that my change is working, if appropriate~
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 310 - Author: KS1019
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

This PR resolves #164 and adds a new built-in flag `--dump-help` to dump all the help information in JSON format. This feature can be useful when parsing help information and generating documentation for a command. I will add documentation if necessary. In that case, I would appreciate it if anyone could direct me to the right place to add the documentation.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 309 - Author: natecook1000
This resolves #259 — a bit more involved than I expected, as `HelpCommand` uses a custom decoder.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 308 - Author: natecook1000
This uses the customized help flags when generating completion scripts and includes the `--version` flag when appropriate. (Fish completions didn't include the help flags at all, which is now fixed as well.)

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 307 - Author: msalmonse
I wanted to add a `—draft` option to my command but I wanted to be able to optionally specify the draft text i.e. `—draft` or `—draft Entwurf`. Unfortunately I couldn't think of a way to handle it.

I think that there is a case for having optional arrays although I think there that specifying a minimum and maximum number of elements would be better.

I don't think that there is a good way of handling this with standard types so maybe a custom type should be a requirement, one that could take an optional value as an argument.

Issue 306 - Author: Runrioter
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Change help subcommand position

See `swift package` help detail

```
➜ swift package
OVERVIEW: Perform operations on Swift packages

SEE ALSO: swift build, swift run, swift test

USAGE: swift package <options> <subcommand>

OPTIONS:
  -Xcc <Xcc>              Pass flag through to all C compiler invocations
  ……

SUBCOMMANDS:
  clean                   Delete build artifacts
  ……

  See 'swift help package <subcommand>' for detailed help.
```
`See 'swift help package <subcommand>' for detailed help.` should be `See 'swift package help <subcommand>' for detailed help.`


### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 305 - Author: natecook1000


Issue 304 - Author: natecook1000
This fixes a bug where an `@Option` array defined with the `.upToNextOption` parsing strategy would only capture the last "group" of elements. e.g. in:

    example --test one two --test three four

the `--test` property would only have the value `["three", "four"]`.

Fixes rdar://73908471

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 303 - Author: miggs597
It would be nice to have access to ArgumentParserTestHelpers, this would allow SwiftPM to use `AssertHelp` to prevent regression.
### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 302 - Author: natecook1000


Issue 301 - Author: miggs597
Second PR that is needed to fix --help for SwiftPM

Related PRs:

[SwiftPM](https://github.com/apple/swift-package-manager/pull/3407)
[ArgumentParser](https://github.com/apple/swift-argument-parser/pull/300)


### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 300 - Author: miggs597
Currently when asking for help with a subcommand we will receive help for it, and all supercommands that precede it. I propose the ability to only print help for the subcommand. The best example of this is in SwiftPM.

Current Behavior:

```
$ swift package init --help
OVERVIEW: Initialize a new package

USAGE: swift package init <options>

OPTIONS:
  -Xcc <Xcc>              Pass flag through to all C compiler invocations 
  -Xswiftc <Xswiftc>      Pass flag through to all Swift compiler invocations 
  -Xlinker <Xlinker>      Pass flag through to all linker invocations 
  -Xcxx <Xcxx>            Pass flag through to all C++ compiler invocations 
  -c, --configuration <configuration>
                          Build with configuration (default: debug)
  --build-path <build-path>
                          Specify build/cache directory 
  --cache-path <cache-path>
                          Specify the shared cache directory 
  --enable-repository-cache/--disable-repository-cache
                          Use a shared cache when fetching repositories (default: true)
  -C, --chdir <chdir>
  --package-path <package-path>
                          Change working directory before any other operation 
  --multiroot-data-file <multiroot-data-file>
  --enable-prefetching/--disable-prefetching
                          (default: true)
  -v, --verbose           Increase verbosity of informational output 
  --disable-sandbox       Disable using the sandbox when executing subprocesses 
  --manifest-cache <manifest-cache>
                          Caching mode of Package.swift manifests (shared: shared cache, local: package's build directory, none:
                          disabled (default: shared)
  --destination <destination>
  --triple <triple>
  --sdk <sdk>
  --toolchain <toolchain>
  --static-swift-stdlib/--no-static-swift-stdlib
                          Link Swift stdlib statically (default: false)
  --skip-update           Skip updating dependencies from their remote during a resolution 
  --sanitize <sanitize>   Turn on runtime checks for erroneous behavior, possible values: address, thread, undefined, scudo 
  --enable-code-coverage/--disable-code-coverage
                          Enable code coverage (default: false)
  --force-resolved-versions, --disable-automatic-resolution
                          Disable automatic resolution if Package.resolved file is out-of-date 
  --enable-index-store/--disable-index-store
                          Enable or disable  indexing-while-building feature 
  --enable-parseable-module-interfaces
  --trace-resolver
  -j, --jobs <jobs>       The number of jobs to spawn in parallel during the build process 
  --enable-build-manifest-caching/--disable-build-manifest-caching
                          (default: true)
  --emit-swift-module-separately
  --use-integrated-swift-driver
  --experimental-explicit-module-build
  --print-manifest-job-graph
                          Write the command graph for the build manifest as a graphviz file 
  --build-system <build-system>
                          (default: native)
  --netrc
  --netrc-optional
  --netrc-file <netrc-file>
  --type <type>           (default: library)
  --name <name>           Provide custom package name 
  --version               Show the version.
  -help, -h, --help       Show help information.
```

Proposed Behavior
```
swift package init --help
OVERVIEW: Initialize a new package

USAGE: swift package init [--type <type>] [--name <name>]

OPTIONS:
  --type <type>           Package type: empty | library | executable | system-module | manifest (default: library)
  --name <name>           Provide custom package name 
  --version               Show the version.
  -help, -h, --help       Show help information.
```

These changes are fully backwards compatible, with no changes needed to existing sources that depend on `ArgumentParser`.

To access this new feature a user would just need to add `includeSuperCommandInHelp = false` to their struct that conforms to `ParsableCommand`

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 299 - Author: natecook1000
Using structs for these public types (instead of enums) will let us add members in the future without breaking source compatibility. This is a source-breaking change, but not alarmingly so — these enum cases are typically used as static members, and that usage is maintained. Only switch exhaustivity is altered here.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary

Issue 298 - Author: natecook1000


Issue 297 - Author: msalmonse
When I read "Manual Parsing and Testing" I got the impression that `parseAsRoot` would only ever return one of the Math subcommands but I discovered that that wasn't the case when I tried using it. When I went looking to find out why `-h` stopped working for me I found that a `HelpCommand` was returned by `parseAsRoot`. It worked in your example as you execute the `run` method of the `command` in the default case of the switch.

I believe that a short note to that effect would help others.

Also, in the example variance is calculated as the sum of the squared errors when it is actually the mean.

Issue 296 - Author: eaigner
Just including the argument parser raises my CLI tool binary size from 250KB to about 3MB

This seems a _bit_ excessive.

**ArgumentParser version:** `main`
**Swift version:** Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28) Target: arm64-apple-darwin20.3.0


Issue 295 - Author: eaigner
The default `USAGE` output derives the usage command name from the `ParsableCommand` type name. Now this might be correct or not. The "correct" way would be to always use the last path component of `argv[0]`, as it would also show the correct string in case the build product name is different from the class name or the user renames the tool.

While there is `_commandName` I can use to override this, it is marked as for internal use only.

Issue 294 - Author: rauhul
### Problem

Manually wrapped help text in code is wrapped weirdly in the generated help output.

### Cause

Currently ParsableCommand help text is wrapped per line based on the width of the terminal. This requires users to make each paragraph its own line in code, which likely results in extremely long lines. (violating some code basis' line length limit)

### Solution

It would be better to be able to use a multiline string literal for the help text and have argument parser reflow the text similar to markdown. Newlines in the help should be replaced with " " unless there are 2 sequential newlines which would be replaced with a single newline character. (The same behavior should also apply to the help text for individual arguments.)

### Example

#### Command
```swift
import ArgumentParser
struct Example: ParsableCommand {
    static let configuration = CommandConfiguration(
        discussion: """
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc sit amet mattis
eros, sit amet imperdiet odio. Nulla interdum dui in erat volutpat, vitae congue
ante sodales. In at iaculis metus. Fusce fermentum elit sodales odio elementum
interdum. Nam vitae porttitor tellus. Duis quis sapien risus. Curabitur viverra
justo eget fermentum accumsan.
"""
    )
}
Example.main()
```

#### Current Output

```shell
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc sit amet mattis
eros, sit amet imperdiet odio. Nulla interdum dui in erat volutpat, vitae
congue
ante sodales. In at iaculis metus. Fusce fermentum elit sodales odio elementum
interdum. Nam vitae porttitor tellus. Duis quis sapien risus. Curabitur viverra
justo eget fermentum accumsan.
```

#### Desired Output

```shell
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc sit amet mattis
eros, sit amet imperdiet odio. Nulla interdum dui in erat volutpat, vitae
congue ante sodales. In at iaculis metus. Fusce fermentum elit sodales odio
elementum interdum. Nam vitae porttitor tellus. Duis quis sapien risus.
Curabitur viverra justo eget fermentum accumsan.
```

Issue 293 - Author: msalmonse
Negative numbers are parsed as options and not values.

**ArgumentParser version:** 0.4.1
**Swift version:** Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28) Target: arm64-apple-darwin20.3.0

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
 One of my arguments is:
```
@Option(name: .long, parsing: .upToNextOption,
    help: "Generate a random SVG with: #plots [max value [min value]]")
 var random: [Int] = []
```

The idea is to use it as `—random 5 1000 -100` but the -100 is interpreted as an option and not a value.
This is similar to issue #31 but the workaround doesn't work.

### Expected behavior
I expect arguments to be parsed as part of random until a valid option is encountered.

### Actual behavior
```
Error: Unknown option '-100'. Did you mean '--bg'?
Usage: options [<options>] [<csv-name>] [<json-name>]
  See 'options --help' for more information.
```

Issue 292 - Author: kylemacomber
This is kind of cool, but it prevents editing the markdown from Xcode (but not any other text editor).

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [ ] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 291 - Author: 3405691582
On this platform, the TIOCGWINSZ ioctl identifier is a complex macro.
Since we don't have a C bridging header obviously available to get the
flattened value, supply is the flattened value obtained elsewhere. This
is of course brittle but this is the simplest way around this for now.

Additionally, ensure we support the platform architecture name, where
the x86_64 architecture is called amd64 instead.

### Checklist
- [X] I've added at least one test that validates that my change is working, if appropriate
  - not trivially testable
- [X] I've followed the code style of the rest of the project
- [X] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [X] I've updated the documentation if necessary
  - not covered

Issue 290 - Author: werm098
Fixes “Internal error. Invalid state while parsing command-line arguments.” that is encountered when an unparsed value is optional.

Root causes:
- `ParsedArgumentsContainer.decodeNil` returns false for optional values because it only does a `!contains(key)` check. This should instead return nil if the value of the element is nil.
- The decoder did not know about unparsed input origins that and would result in unexpected behavior when decoding nil default values.
- The `value` of `Mirror.Child` is defined as `Any` but this is confusing because the value could be `Optional<Any>` which is not equal to `nil` even when the `Optional` case is `.none`.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 289 - Author: werm098
Fixes an issue where the inversion of a flag would not be hidden when the `ArgumentHelp.shouldDisplay` value is `false`.

Added a unit test to check for this behavior.

Example:
```
@Flag(inversion: .prefixedNo, help: .hidden)
var prompt: Bool = true
```
Would produce the following in the help text:
```
OPTIONS:
  --no-prompt
```
But the desired outcome is that there is no listing for this flag in the help text.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 288 - Author: Mark-McCracken
Resolves #259 

Literally ignores any --help flag, if the first argument is help.

I did spend a while digging into the behaviour using the debugger, but this code is fairly complex, and adding an edge case at this low level would make it harder to understand I think. This ultimately is a little hacky, but I think better than making that low level complexity more complex.

FYI, it was happening somewhere in this function: https://github.com/apple/swift-argument-parser/blob/831ed5e860a70e745bc1337830af4786b2576881/Sources/ArgumentParser/Parsing/CommandParser.swift#L155
If you add a breakpoint on the next line, run the program, continue program execution 2 times, then the `firstUnused` property jumps from 1 to 3, skipping the unused commands, causing our bug.

### Checklist
- [X] I've added at least one test that validates that my change is working, if appropriate
- [questionable X] I've followed the code style of the rest of the project
- [X] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [not necessary] I've updated the documentation if necessary


Issue 287 - Author: natecook1000


Issue 286 - Author: natecook1000
We're newly able to decode actual optional types due to allowing unparsed variable properties. "Normal" optional values are still wrapped in non-optional property wrappers, so `ArgumentDecoder` didn't need to handle optional values until now. Fixes #285.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 285 - Author: Wevah
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace each paragraph
    below with the relevant details for your bug, and complete
    the steps in the checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Upon updating ArgumentParser to 0.4.0 (from 0.3.2), my project fails with the error "Error: No value set for non-argument var InputKey(rawValue: "products"). Replace with a static variable, or let constant."

`products` is a codable key on the `Config` struct; verified by changing the name. Removing the loading of that key also causes it to report the same error but with the next key down.

I'm using a custom struct called Config, and ArgumentParser seems to be trying to validate that object even though it doesn't conform to any of the ArgumentParser protocols, only `Decodable` (it loads a configuration from JSON in `run()`).

Seems to be caused the changes e99a8ef488533e3b331535902843230d2566d4ed.

Is there a way revert to the old behavior making it `static`?

**ArgumentParser version:** 0.4.0
**Swift version:** Apple Swift version 5.3.2

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
Build the project in question with ArgumentParser 0.4.0.

### Expected behavior
Behavior should be the same as older versions.

### Actual behavior
The above error is reported.


Issue 284 - Author: adellibovi
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Hi, this PR fixes #277

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 283 - Author: adellibovi
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Hi, this PR fixes #282 😃 

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 282 - Author: natecook1000
When an invalid value is given for an option or argument, it would be nice if the error text could include any help string for that input.

```swift
struct Example: ParsableCommand {
    @Argument(help: "The number of items")
    var count: Int

    @Option(help: "The verbosity level")
    var verbosity: Int
}
```

**Existing:**

```
$ example aaa
Error: The value 'aaa' is invalid for '<count>'
Usage: example <count> --verbosity <verbosity>
  See 'example --help' for more information.
$ example 3 --verbosity aaa
Error: The value 'aaa' is invalid for '--verbosity <verbosity>'
Usage: example <count> --verbosity <verbosity>
  See 'example --help' for more information.
```

**Improved:**

```
$ example aaa
Error: The value 'aaa' is invalid for '<count>'
Help:  <count>  The number of items 
Usage: example <count> --verbosity <verbosity>
  See 'example --help' for more information.
$ example 3 --verbosity aaa
Error: The value 'aaa' is invalid for '--verbosity <verbosity>'
Help:  --verbosity <verbosity>  The verbosity level 
Usage: example <count> --verbosity <verbosity>
  See 'example --help' for more information.
```

Issue 281 - Author: natecook1000


Issue 280 - Author: CodaFi


Issue 279 - Author: natecook1000
ArgumentParser projects built using Swift PM or Xcode can now use the `@main` attribute to designate the root command instead of calling `Example.main()`. We should document that usage as the correct default approach.

Issue 278 - Author: fappelman
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace each paragraph
    below with the relevant details for your bug, and complete
    the steps in the checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Under some conditions the Usage line in the generated help is incorrect.

**ArgumentParser version:** `0.3.2` 
**Swift version:** Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28)
Target: x86_64-apple-darwin20.3.0

### Checklist
- [ ] If possible, I've reproduced the issue using the `main` branch of this package
- [X] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
There is a subtle bug in the `OptionGroup` help generation.

Given the following application:

```swift
struct ParserBug: ParsableCommand {
    static let configuration: CommandConfiguration = CommandConfiguration(
        commandName: "parserBug",
        subcommands: [Sub.self])

    func run() throws {
    }
}
```
which references a sub command named `Sub`:

```swift
extension ParserBug {
    struct Sub: ParsableCommand {
        @OptionGroup() var commonOptions: CommonOptions

        @Argument(help: "Mandatory argument") var argument: String
    }
}
```
which references a common option group `CommonOptions`:

```swift
extension ParserBug {
    struct CommonOptions: ParsableCommand {
        @Flag(help: "example flag") var example: Bool = false
    }
}
```
If I now run this application with the `parserBug sub -h` command, I get the following output:

```log
USAGE: parserBug sub [--example] <argument>

ARGUMENTS:
  <argument>              Mandatory argument 

OPTIONS:
  --example               example flag 
  -h, --help              Show help information.
```
and this output is completely as expected. I am now making one minor change in `Sub`:

```swift
extension ParserBug {
    struct Sub: ParsableCommand {
        @OptionGroup() var commonOptions: CommonOptions

        @Argument(help: "Mandatory argument")
        var argument: String? // <== Is now optional
    }
}
```
If I now run the help again the `USAGE` line is wrong:

```log
USAGE: parserBug common-options sub [--example] [<argument>]

ARGUMENTS:
  <argument>              Mandatory argument 

OPTIONS:
  --example               example flag 
  -h, --help              Show help information.
```
The word `common-options` should not be in the USAGE line.

I have used version `0.3.2`.
### Expected behavior
Usage without the word 'common-options'

### Actual behavior
Usage with the word 'common-options'


Issue 277 - Author: natecook1000
Dashes aren't valid variable identifier characters for Zsh (~and maybe Bash~ just Zsh). When building a completion script for a command that includes one or more dashes in the command name, the completion script prints errors instead of providing completions.

**ArgumentParser version:** `main` branch
**Swift version:** Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28)

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
Create a CLI tool with a dash in the command name, then generate and install a Zsh completion script for the command.

Command:
```swift
struct ExampleCommand: ParsableCommand {
  @Option var name: String
  @Flag var verbose = false
}
```

Script:
```
#compdef example-command
local context state state_descr line
_example-command_commandname=$words[1]
typeset -A opt_args

_example-command() {
    integer ret=1
    local -a args
    args+=(
        '--name:name:'
        '--verbose'
        '(-h --help)'{-h,--help}'[Print help information.]'
    )
    _arguments -w -s -S $args[@] && ret=0

    return ret
}


_custom_completion() {
    local completions=("${(@f)$($*)}")
    _describe '' completions
}

_example-command
```

### Expected behavior
Typing `example-command` and then `TAB` should offer completions.

### Actual behavior
The shell prints `_example-command:3: command not found: _example-command_commandname=example-command`.


Issue 276 - Author: natecook1000
The error code in CustomNSError is actually _not_ appropriate to use as the command's exit code, as described in #269.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 275 - Author: lorentey
ArgumentParser is configured not to emit detailed synopsis when it would contain more than a dozen entries. This makes sense; however, eliding all information makes the synopsis rather useless.

While commands may have dozens of options, in most cases, only a few of them are required — so we can keep the synopsis short but still useful by only displaying the required parts.

### Checklist
- [X] I've added at least one test that validates that my change is working, if appropriate
- [X] I've followed the code style of the rest of the project
- [X] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [X] I've updated the documentation if necessary


Issue 274 - Author: DagAgren
Currently, it seems that at ParsableArgumentsValidation.swift:140, there is a `throw ValidationResult.success` that triggers on the regular happy path. This makes it very annoying to debug your code if you use a Swift error breakpoint in Xcode, as it will trigger several times before getting to the actual code that needs debugging.

I think most Swift code generally avoids throwing for program flow, and it would be nice if this code could also be changed to avoid that, to make debugging easier.

Issue 273 - Author: natecook1000


Issue 272 - Author: schlagelk
Ensures the `NSError` case is handled in `MessageInfo` and attempts to resolve #270 

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 271 - Author: natecook1000
Resolves #264.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 270 - Author: lorentey
NSError instances thrown from Objective-C aren't handled nicely by `MessageInfo`.

Because protocol conformances don't apply over bridging, `let e as CustomNSError` in an exception handler does not match NSError instances, even if the NSError happens to be bridgeable to `CocoaError` (or another domain-specific error type) that does conform to CustomNSError.

Note: In Foundation as of 2020, `NSError` and `CFError` conform to none of `CustomNSError`, `LocalizedError`, or any other error protocol other than `Error` itself. To handle NSError instances, `MessageInfo.init` needs to explicitly add a `case let e as NSError` clause.

**ArgumentParser version:** `0.3.2`
**Swift version:** 5.4

### Checklist
- [X] If possible, I've reproduced the issue using the `main` branch of this package
- [X] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce

```swift
import Foundation
import ArgumentParser

struct Command: ParsableCommand {
  func run() throws {
    let url = URL(fileURLWithPath: "/This file does not exist")
    try print(NSData(contentsOf: url, options: .mappedIfSafe))
  }
}

Command.main()
```

### Expected behavior

```
$ swift run test
Error: The file “This file does not exist” couldn’t be opened because there is no such file.
```

### Actual behavior

```
$ swift run test 
Error: Error Domain=NSCocoaErrorDomain Code=260 "The file “This file does not exist” couldn’t be opened \
because there is no such file." UserInfo={NSFilePath=/This file does not exist, \
NSUnderlyingError=0x7fd669706a40 {Error Domain=NSPOSIXErrorDomain Code=2 "No such file or directory"}}
```


Issue 269 - Author: lorentey
This package uses the `errorCode` property of `CustomNSError` errors as the process exit status. 

```swift
      // MessageInfo.swift:109
      case let error as CustomNSError:
         self = .other(message: error.localizedDescription, exitCode: Int32(error.errorCode))
```

The purpose of `errorCode` is merely to differentiate error cases within the same error domain; it is not appropriate to use it as an exit status. The process exit status has a limited range (either 8 or 32 bits depending on the syscall used to retrieve it); additional bits get silently truncated. As a result, when the classic `wait`/`waitpid` syscalls are used, `ArgumentParser` processes may appear to exit with a zero status (EXIT_SUCCESS) even if they failed.

Additionally, an `errorCode` that doesn't fit in an `Int32` leads to a fatal runtime error.

The broken behavior was introduced in #244. One easy way to fix this is to revert that change.

One way to correctly implement #230 is to define a custom mix-in error protocol with an explicit property for exit codes that is kept distinct from `errorCode`.

**ArgumentParser version:** `0.3.2`
**Swift version:** Latest stable

### Checklist
- [X] If possible, I've reproduced the issue using the `main` branch of this package
- [X] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce

```swift
import Foundation
import ArgumentParser

enum MyError: Int, CustomNSError {
  case foo = 256
  case bar = 10_000_000_000

  static var errorDomain: String { "MyError" }
  var errorCode: Int { self.rawValue }
  var errorUserInfo: [String : Any] { [:] }
}

struct Command: ParsableCommand {
  @Flag
  var trap: Bool = false

  func run() throws {
    throw trap ? MyError.bar : MyError.foo
  }
}

Command.main()
```

### Expected behavior

I expect `ArgumentParser.main` to exit normally with a non-zero status whenever `run` throws an error it doesn't otherwise handle.

On the bash/fish/zsh prompt, I expect to see:

```
$ swift run test
$ echo $?
1   # Or some other non-zero value

$ swift run test --trap
$ echo $?
1   # Or some other non-zero value
```

### Actual behavior

Depending on the `errorCode` value, the subprocess appears to exit with a zero status, or exits with a signal instead.

With the bash/zsh installations on default macOS, and fish installed from homebrew, I get:

```
$ swift run test
$ echo $?
0
$ swift run test --trap
Swift/Integers.swift:3550: Fatal error: Not enough bits to represent the passed value
Illegal instruction: 4
```

Exiting with (what appears to be) a zero exit code when the process did not succeed is a very serious problem.

Shells (and other processes) that use the newer `waitid` syscall can get access to the full 32 bits of the exit code, so they'd report a nonzero code here. However, all shells I tried so far are still using the older `wait`/`waitpid` syscalls; we ought to be very conservative about what values we pass to `exit`.


Issue 268 - Author: natecook1000
This captures the default value for non-parsable properties when building the ArgumentSet, which in turn get set as initial
values before decoding. Resolves #265.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 267 - Author: natecook1000
Option groups are currently just splatted into the rest of the declared arguments for a command. This is sometimes fine, but often it would be nice if option groups were separated and labeled, which would (a) help readability in complex commands and (b) help users understand which options carry over across multiple subcommands.

For example, for declarations like this:

```swift
struct Options: ParsableArguments {
    @Flag(help: "Display extra information while processing.")
    var verbose = false

    @Option(help: "The number of extra lines to show.")
    var extraLines = 0
}

struct Example: ParsableCommand {
    @OptionGroup(title: "Shared Options")
    var group: Options

    @Flag(help: "Parse as a binary file.")
    var parseAsBinary = false

    @Argument(help: "The input file.")
    var inputFile: String?
}
```

The help screen could look something like:

```

% example --help
USAGE: example [--verbose] [--extra-lines <extra-lines>] [--parse-as-binary] <input-file>

ARGUMENTS:
  <input-file>            The input file.

OPTIONS:
  --parse-as-binary       Parse as a binary file.

SHARED OPTIONS:
  --verbose               Display extra information while processing.
  --extra-lines <extra-lines>
                          The number of extra lines to show. (default: 0)

  -h, --help              Show help information.
```

Issue 266 - Author: varungandhi-apple
If you have a command with a subcommand, and the subcommand is invoked, the parent command's flags aren't parsed. Arguably, this is not the right behavior. Instead, first the parent should be allowed to parse its flags, then the subcommand should be run.

**ArgumentParser version:** `main`.
**Swift version:** 5.3.1.

### Checklist
- [X] If possible, I've reproduced the issue using the `main` branch of this package
- [X] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
```
import ArgumentParser

var GLOBAL_CHANGED_DIR: String? = nil

struct Outer: ParsableCommand {
  @Option(name: .customShort("C"))
  var changeDir: String?
  static var configuration = CommandConfiguration(
    abstract: "Test", subcommands: [Inner.self])
  func run() {
    GLOBAL_CHANGED_DIR = changeDir
    print("outer")
  }
}

struct Inner: ParsableCommand {
  func run() { print("inner") }
}

Outer.main()
```

### Expected behavior
Prints both "outer" and "inner"

### Actual behavior
Prints "inner"

### Why this should work

This is a very common pattern for command-line tools such as `ninja`, `cmake` and `git`, where some options are common between all sub-commands. (Note that I am using a global in the example here to work around Issue https://github.com/apple/swift-argument-parser/issues/254.)

The alternative of using `@OptionGroup` as advocated in the documentation duplicates the flags across multiple sub-commands, which may be undesirable as it hides the commonality between subcommands.

Although I do find the current default to be a bit strange, I'm open to the additional functionality being available through a different API, and not through `run` (to avoid breaking existing clients, or for some other reason).

Issue 265 - Author: varungandhi-apple
I see a runtime crash when I have a `var` stored property on a type conforming to `ParsableCommand` despite it having a default value.

**ArgumentParser version:** `0.3.0` and `main`
**Swift version:** 5.3.1

### Checklist
- [X] If possible, I've reproduced the issue using the `main` branch of this package
- [X] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce

Put this in `main.swift` and call `xcrun swift run`.

```
import ArgumentParser
struct Test: ParsableCommand {
  @Option
  var boop: String = "boop"
  var blep: String = "blep"
  mutating func run() {
    self.blep += self.boop
    print(self.blep)
  }
}
Test.main()
```

### Expected behavior

There shouldn't be a crash, since the `var` has a default value.

### Actual behavior

```
Error: No value set for non-argument var InputKey(rawValue: "blep"). Replace with a static variable, or let constant.
```

Issue 264 - Author: fappelman
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace each paragraph
    below with the relevant details for your bug, and complete
    the steps in the checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

I have an application with the following definition:

```swift
import ArgumentParser
import Foundation

struct ArgumentParserBug: ParsableCommand {
    @Flag(name: .shortAndLong, help: .hidden) var verbose: Bool = false

    func run() throws {
        if verbose {
            print("Hello, world from argumentParserBug!")
        }
    }
}

ArgumentParserBug.main()
```

It has an hidden option named verbose.

When I run `application --help` I do not see this option as expected:

```bash
$ ./.macos/debug/argumentParserBug --help
USAGE: argument-parser-bug

OPTIONS:
  -h, --help              Show help information.
```
When I generate the completion file for this command it however does expose the verbose flag:

```bash
$ ./.macos/debug/argumentParserBug --generate-completion-script bash
#!/bin/bash

_argument-parser-bug() {
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    COMPREPLY=()
    opts="--verbose -v -h --help"
    if [[ $COMP_CWORD == "1" ]]; then
        COMPREPLY=( $(compgen -W "$opts" -- "$cur") )
        return
    fi
    COMPREPLY=( $(compgen -W "$opts" -- "$cur") )
}
```

**ArgumentParser version:** `0.3.2` or the `main` branch, for example.
**Swift version:** Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28)
Target: x86_64-apple-darwin20.3.0

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
The full application is provided.

### Expected behavior
I would expect that the `verbose` option is not exposed by bash completion scripts.

### Actual behavior
The hidden `verbose` option is exposed by the bash completion scripts.


Issue 263 - Author: natecook1000
Error messages include a message that shows how to display the help screen, but the message didn't use the custom help flag names for a command if they had been specified.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 262 - Author: natecook1000
These were deprecated in version 0.2.0. Time to go!

Issue 261 - Author: natecook1000


Issue 260 - Author: tfonfara
`--help` flag of a subcommand or also `help <subcommand>` does also print options from the main command

**ArgumentParser version:** `main`
**Swift version:** 5.3.2

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
1. Checkout main branch
2. Add any `@Option` or `@Flag` to the `Math` struct
3. Build the project with `swift build`
4. Run `math add --help`

Sample:
```
struct Math: ParsableCommand {

    static var configuration = CommandConfiguration(
        ...
    )

    @Option(help: "Test option.")
    var test: String?

}
```

### Expected behavior
Help of the subcommand only should be printed, options of the main command should not be printed

Sample:
```
OVERVIEW: Print the sum of the values.

USAGE: math add [--hex-output] [<values> ...]

ARGUMENTS:
  <values>                A group of integers to operate on. 

OPTIONS:
  -x, --hex-output        Use hexadecimal notation for the result. 
  --version               Show the version.
  -h, --help              Show help information.

```

### Actual behavior
- Overview, usage, arguments of the subcommand are being printed ✅
- Options of the subcommand are being printed ✅ 
- Options of the main command are being printed ❌

Sample:
```
OVERVIEW: Print the sum of the values.

USAGE: math add [--hex-output] [<values> ...]

ARGUMENTS:
  <values>                A group of integers to operate on. 

OPTIONS:
  --test <test>           Test option. 
  -x, --hex-output        Use hexadecimal notation for the result. 
  --version               Show the version.
  -h, --help              Show help information.
```

Issue 259 - Author: natecook1000
As [noted here](https://github.com/realm/SwiftLint/issues/1088#issuecomment-745738042), adding the `--help` flag subverts the user's intent if they're trying to get help about a subcommand.

**ArgumentParser version:** `main` branch
**Swift version:** any

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
1. Build the project with `swift build`
2. Call the `math` command both the `help` subcommand and a `--help` flag, e.g. `.build/debug/math help stats --help`

### Expected behavior
It should print the help text for the `stats` subcommand.

### Actual behavior
It prints the help text for the top-level `math` command.


Issue 258 - Author: jpsim
I believe this is generally useful information to have, if it's been specified.

This was requested by a SwiftLint user who's been generous enough to try out a version of the tool that's integrated this library: https://github.com/realm/SwiftLint/issues/1088#issuecomment-745738042

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary

Issue 257 - Author: MaxDesiatov
This matches the behavior of [a similar `elseif` branch in the Swift toolchain itself](https://github.com/apple/swift/blob/b80e4bf8f866be26a4108bd92f97b2a182662642/CMakeLists.txt#L594).

<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 256 - Author: drewmccormack
Relates to issue https://forums.swift.org/t/how-to-exclude-members-from-parsing/34325/9

The existing message was completely unhelpful, and even erroneous in the sense that the issue is not related to an argument at all, but to a non-argument. The new message is a stop-gap until the actual problem causing the error is resolved, but it at least gives the user actionable information and makes it clear where the issue lies.

<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Replace this paragraph with a description of your changes and rationale. Provide links to an existing issue or external references/discussions, if appropriate.

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 255 - Author: glessard
When writing a cli, the interface might be interesting enough to warrant tests of the parsing. In order to do that I had previously copied the test helpers from the argument parser project into mine. However recently I came back to such a project and saw my tests fail. After a too-long investigation it turned out that the particular function I copied had diverged from the source; copying the updated version fixed my tests.
If I had been able to import ArgumentParserTestHelpers from the start, I would not have had that problem.
Obviously not all of the current content of the target is desirable as public api, but the various functions that start with “Assert” are all obviously useful to users of the package for their own tests.

Issue 254 - Author: beefon
I'd like to add some context into every command. Ideally, initialize it with objects.

Currently [`ParsableArguments`](https://github.com/apple/swift-argument-parser/blob/main/Sources/ArgumentParser/Parsable%20Types/ParsableArguments.swift#L30) requires `init()`. SAP uses it to instantiate commands once input has been parsed.

Is there a way to inject e.g. DI into parsed command? I can always create a singleton and then get it from command instance, but I'd love to `init(with di: MyDI)` instead. Also, I can parse `: ParsableArguments`, but I'd love to keep command tree feature available, and that works only with `ParsableCommand` and configurations as far as I can tell.

Issue 253 - Author: damuellen
Replacement for: https://github.com/apple/swift-argument-parser/pull/250

Issue 252 - Author: CypherPoet
# Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 251 - Author: Zoha131
Modifying help flag names now works for subcommand. If not specified `helpNames` is inherited from parent. This PR is compatible with the current system.

Fix #215

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 250 - Author: damuellen
getenv generates a warning on windows.

Issue 249 - Author: compnerd
The Windows environment calls the library `CRT`.  This also enables the
removal of the `visualc` module from the Swift SDK overlay.

<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Replace this paragraph with a description of your changes and rationale. Provide links to an existing issue or external references/discussions, if appropriate.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 248 - Author: mlaster
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace the paragraph
    below with information about your proposed feature.
-->

Since ArgumentParser is case-sensitive, it would be nice to allow commands to have alias names.  For example, if I have a subcommand named "fetchResults", if the user types "fetchresults", I would like either of these arguments to run my subcommand.

This would also be useful to have both a verbose subcommand name and a short form like "fr"

Issue 247 - Author: bitigchi
### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 246 - Author: johannes-codes
It's not from the get-go clear for beginners that Foundation has to be imported as well. Otherwise, you would end up with a bunch of compilation errors.

### Checklist
- [-] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 245 - Author: mmng-a
### Description
Some major commands, like swift and cargo, have a feature which calls `swift-sub` when entering `swift sub`. This PR adds support to this.

### Detailed Design
This PR doesn't add new APIs. 
A simple case is here (main is built with swift-argument-parser):

```
$ ls
main main-sub
$ ./main
main is called
$ ./main-sub
sub is called
$ ./main sub
sub is called
```

If `main` needs arguments, custom subcommands behave like swift-argument-parser's subcommand. I'm questioning this behavior, but I've decided to adapt it to the current behavior. 

```
$ ls
main main-custom
$ ./main -h
USAGE: main <text> <subcommand>

ARGUMENTS:
  <text>

OPTIONS:
  -h, --help              Show help information.

SUBCOMMANDS:
  sub

  See 'main help <subcommand>' for detailed help.
$
$ ./main sub
main command is called; text: sub
$ ./main file sub
sub command is called
$ ./main sub file 
Error: Unexpected argument 'file'
Usage: main <text> <subcommand>
  See 'main --help' for more information.
$
$ ./main-custom
custom command is called
$ ./main custom
main command is called; text: custom
$ ./main file custom
custom command is called
$ ./main custom file
Error: Unexpected argument 'file'
Usage: main <text> <subcommand>
  See 'main --help' for more information.
```

### Documentation Plan
I don't know whether I should add documentation or not.

### Test Plan
`swift test` tests in `/private/temp` so I have no idea to test this feature. 

### Source Impact
Nothing

### Alternative Design
- Add a flag to `CommandConfiguration` whether allows sub command provided by users.

### Note
`execv` is always failed when I execute text executable file. It is no problem with a binary file.

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 244 - Author: SergeyPetrachkov
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Introduce support for CustomNSError protocol conformers. Previously executable targets would exit with code 1, but it seems like a good idea to exit with a code provided by the user's custom error type.

I've added a sample executable target, and a few tests to cover things up.

This PR references https://github.com/apple/swift-argument-parser/issues/243 and https://github.com/apple/swift-argument-parser/issues/230

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary(no need i guess)


Issue 243 - Author: natecook1000
If you throw an error type that conforms to `CustomNSError` from the `run` method or a validation closure, the exit code of the program should be the one given by the custom error type's `errorCode` property.

**ArgumentParser version:** `main` branch
**Swift version:** Apple Swift version 5.3

### Checklist
- [x] If possible, I've reproduced the issue using the `main` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
Build and run this command, then use `echo $?` (or `echo $status` in fish) to inspect the exit code:

```swift
import ArgumentParser
import Foundation

enum CustomError: CustomNSError {
  case error
  
  var errorCode: Int {
    switch self {
    case .error: return 7
    }
  }
}

struct Example: ParsableCommand {
  func run() throws {
    throw CustomError.error
  }
}

Example.main()
```

### Expected behavior
The exit code should be 7.

### Actual behavior
It's actually 1, aka `EXIT_FAILURE`.


Issue 242 - Author: natecook1000


Issue 241 - Author: matthewseaman
I'd like to be able to get an array of `String` arguments from an already-initialized `ParsableArguments` type. This is useful for Driver applications that need to create some `ParsableArguments` type, then get the raw string arguments to pass into a child `Process`, which might not even be the same tool and/or cannot be run directly.

```swift
struct MyInvocation: Decodable, ParsableArguments {
    @Flag var myOption = false
}

var invocation = MyInvocation.parse([])
invocation.myOption = true

runChildProcess("myOtherTool \(invocation.rawArguments.joined(separator: " "))")
```

Issue 240 - Author: natecook1000
### Description
This supports joined arguments, like '-Ddebug' or '-v4'. Joined arguments need to be explicitly declared as `.customShort("D", allowingJoined: true)`.

### Detailed Design
You can now specify a Boolean `allowingJoined` value when declaring a custom short name specification, like this:

```swift
@main
struct Example: ParsableCommand {
    @Option(name: .customShort("D", allowingJoined: true))
    var debugValue: String

    func run() {
        print(debugValue)
    }
}
```

Existing calls still work as expected:

```
$ example -D debug
debug
$ example -D=debug
debug
```

And now you can use joined syntax:

```
$ example -Ddebug
debug
```

### Documentation Plan
Expanded the documentation for `.customShort(_:allowingJoined:)` on both `NameSpecification` and `NameSpecification.Element`.

### Test Plan
Unit tests covering the breadth of usage.

### Source Impact
This is an additive change only, users must opt into the new functionality.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 239 - Author: elliottwilliams
Since #104, mutations made to a command struct by its `validate()` function are lost when using `parseAsRoot(_:)`. This is because validations are run on a mutable copy of the parsed command, and that copy is never stored.

My teammates and I use `validate()` as a place to enforce invariants. For example:

```swift
struct Foo: ParsableCommand {
    @Flag()
    var verbose = false

    @Flag()
    var dryRun = false

    mutating func validate() {
        if dryRun {
            verbose = true    // --dry-run implies --verbose
        }
    }

    func run() {
        if verbose { ... }
    }
}
```

While this isn't _technically_ a validation step, it's been useful to separate post-processing of the arguments like this from the business logic of `run()`.

I couldn't find anything indicating that #104 intended to change this behavior, so I'm assuming it was a regression. Here's a fix!

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 238 - Author: gmittert
- TestHelpers has a implicit dependency on Foundation through
  ArgumentParser, so it needs to link against Foundation
- The find package calls should be REQUIRED and CONFIG so they can take
  advantage of CMake configs

### Checklist

- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 237 - Author: natecook1000


Issue 236 - Author: natecook1000


Issue 235 - Author: natecook1000
This removes the nesting inside the ArgumentSet data structure, which had semantic meaning in an earlier version. This flattening, plus a switch to using dictionary lookup instead of linear scanning, provides another performance boost.


Issue 234 - Author: natecook1000
This converts some operations to constant time when parsing individual elements, leading to big performance improvements with larger argument lists.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 233 - Author: natecook1000


Issue 232 - Author: natecook1000
Fixes #231. Note that this changes the error text slightly, to include the single/double-dash prefix.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 231 - Author: natecook1000
Options with the same name, but different number of dashes, are currently prohibited by the name validator. 

**ArgumentParser version:** `0.3.0`
**Swift version:** Swift version 5.3 (swiftlang-1200.0.28.1 clang-1200.0.30.1)

### Checklist
- [x] If possible, I've reproduced the issue using the `master` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
For example, changing the `Repeat` example's `count` property to this:

```swift
    @Option(name: [.long, .customLong("count", withSingleDash: true)],
            help: "The number of times to repeat 'phrase'.")
    var count: Int?
```

results in:

```
Fatal error: Validation failed for `Repeat`:

- Multiple (2) `Option` or `Flag` arguments are named "count".
```

### Expected behavior
Either `-count` or `--count` should work for that option.

### Actual behavior
The error shown above.


Issue 230 - Author: finestructure
I have a custom error type that I'm throwing from my command:

```
enum Error: LocalizedError {
  case foo
  ...

  var localizedDescription: String {
    switch self {
      case .foo: return "foo error"
      ...
    }
  }
}
```

These all surface with code 1 in the shell. I'd like at least some of them to report specific codes so I can more easily respond to them.

I've seen there's `ExitCode` which I could throw instead but then I don't have a single `Error` tracking all error states anymore and I'd need to make the error printing local to the throwing location because ExitCode does not do any error logging:

```
print("error bar")
throw ExitCode(2)
```

Currently I can just throw and tweak all the error messages in my `Error`'s `localizedDescription`.

I tried making my `Error` adopt `RawRepresentable` in the hopes it might pick up the raw values from there but it didn't.

Is there another way to attach specific codes to custom error types? Would it be possible to pick up error codes from `RawRepresentable` or some other error code protocol?

Issue 229 - Author: natecook1000


Issue 228 - Author: natecook1000


Issue 227 - Author: daltonclaybrook
ArgumentParser offers a few conveniences for printing to standard error, but as far as I can tell, all these mechanisms halt program execution (such as throwing or calling `Self.exit(withError:)`). It would be nice to be able to print to standard error without halting execution. It looks like ArgumentParser contains a `StandardError` type, but this type is internal. I suggest either making this type (and associated variable) public, or exposing a convenience function on `ParsableCommand` to print to standard error.

Issue 226 - Author: dduan
Add fish completion script generation.

The math example app generates the following fish script (`swift run math --generate-completion-script fish`).

```
function __fish_math_using_command
    set cmd (commandline -opc)
    if [ (count $cmd) -eq (count $argv) ]
        for i in (seq (count $argv))
            if [ $cmd[$i] != $argv[$i] ]
                return 1
            end
        end
        return 0
    end
    return 1
end
complete -c math -n '__fish_math_using_command math' -f -a 'add' -d 'Print the sum of the values.'
complete -c math -n '__fish_math_using_command math' -f -a 'multiply' -d 'Print the product of the values.'
complete -c math -n '__fish_math_using_command math' -f -a 'stats' -d 'Calculate descriptive statistics.'
complete -c math -n '__fish_math_using_command math' -f -a 'help' -d 'Show subcommand help information.'
complete -c math -n '__fish_math_using_command math add' -f -l hex-output -d 'Use hexadecimal notation for the result.'
complete -c math -n '__fish_math_using_command math add' -f -l hex-output -s x -d 'Use hexadecimal notation for the result.'
complete -c math -n '__fish_math_using_command math multiply' -f -l hex-output -d 'Use hexadecimal notation for the result.'
complete -c math -n '__fish_math_using_command math multiply' -f -l hex-output -s x -d 'Use hexadecimal notation for the result.'
complete -c math -n '__fish_math_using_command math stats' -f -a 'average' -d 'Print the average of the values.'
complete -c math -n '__fish_math_using_command math stats' -f -a 'stdev' -d 'Print the standard deviation of the values.'
complete -c math -n '__fish_math_using_command math stats' -f -a 'quantiles' -d 'Print the quantiles of the values (TBD).'
complete -c math -n '__fish_math_using_command math stats' -f -a 'help' -d 'Show subcommand help information.'
complete -c math -n '__fish_math_using_command math stats average' -f -r -l kind -d 'The kind of average to provide.'
complete -c math -n '__fish_math_using_command math stats average --kind' -f -k -a 'mean median mode'
complete -c math -n '__fish_math_using_command math stats quantiles' -f -l test-success-exit-code
complete -c math -n '__fish_math_using_command math stats quantiles' -f -l test-failure-exit-code
complete -c math -n '__fish_math_using_command math stats quantiles' -f -l test-validation-exit-code
complete -c math -n '__fish_math_using_command math stats quantiles' -f -r -l test-custom-exit-code
complete -c math -n '__fish_math_using_command math stats quantiles' -f -r -l file
complete -c math -n '__fish_math_using_command math stats quantiles --file' -f -a '(__fish_complete_path *.{txt,md})'
complete -c math -n '__fish_math_using_command math stats quantiles' -f -r -l directory
complete -c math -n '__fish_math_using_command math stats quantiles --directory' -f -a '(__fish_complete_directories)'
complete -c math -n '__fish_math_using_command math stats quantiles' -f -r -l shell
complete -c math -n '__fish_math_using_command math stats quantiles --shell' -f -a '(head -100 /usr/share/dict/words | tail -50)'
complete -c math -n '__fish_math_using_command math stats quantiles' -f -r -l custom
complete -c math -n '__fish_math_using_command math stats quantiles --custom' -f -a '(command math ---completion stats quantiles -- --custom (commandline -opc)[1..-1])'
```
![demo](https://user-images.githubusercontent.com/75067/89943907-d537ae80-dbd3-11ea-91a1-825bf38af651.gif)

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 225 - Author: thomasvl
Fix minor typo in the CHANGELOG

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 224 - Author: natecook1000


Issue 223 - Author: natecook1000
This supports SwiftPM, which uses "error:" instead of "Error:" to make its error messages match the compiler.


Issue 222 - Author: Wevah
- Escape appropriate chars in subcommand abstracts as well.

Fixes #218 and fixes #221.

Note: This changes `zshEscapingSingleQuotes()` to use `replacingOccurrencesOf()` instead of `split()`/`join()`. Let me know if that should be reverted.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 221 - Author: Wevah
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace each paragraph
    below with the relevant details for your bug, and complete
    the steps in the checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

If a subcommand's abstract contains a single quote, it isn't escaped, leading to a syntax error on attempted completion.

**ArgumentParser version:** `master`
**Swift version:** 5.3

### Checklist
- [x] If possible, I've reproduced the issue using the `master` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce

Example:

```swift
struct SetComment: ParsableCommand {
    static let configuration = CommandConfiguration(abstract: "Set image files' Finder comments to their textual content.")

    // ...
}
```

Then

```zsh
textfinder --generate-completion-script zsh > ~/.zcomplete/_textfinder
```

(`~/.zcomplete` being in my fpath)

### Expected behavior
Completion works as expected.

### Actual behavior
`_textfinder:91: unmatched '`

Issue 220 - Author: vlm
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace each paragraph
    below with the relevant details for your bug, and complete
    the steps in the checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->


The argument parser doesn't allow interpolated string to be used as help arguments in Swift-5.2.4.

**ArgumentParser version:** `0.2.0`, `0.2.1`.
**Swift version:** Apple Swift version 5.2.4 (swiftlang-1103.0.32.9 clang-1103.0.32.53)

### Steps to Reproduce

Create the following option in any parser:

```
    @Option(help: "foo \(1)")
    var foo: Int = 1
```

### Expected behavior

The code compiles.

### Actual behavior


```swift
<unknown>:0: error: cannot assign to immutable expression of type '(String) -> ()'
/Path/to/Source.swift:15:56: error: cannot assign to immutable expression of type '(Int) -> ()'
```


Issue 219 - Author: stuartcarnie
This PR includes some improvements to the zsh completion script generator:

* `shellCommand` stores output in a local array that is passed to `_describe` to handle spaces and other punctuation in the shell command output

* elide the help abstract if it is empty, as it confuses the zsh completion system

* set the `_<commandName>_commandname` to `$words[1]`, which is the full name of the command used to invoke the completion. This ensures invocations like `./build/debug/math ...` as passed on to the `_custom_completion` command.

The existing tests have been updated.

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 218 - Author: miguelangel-dev
Declaring an `ArgumentParser` with the `help` containing one of these characters: `[` or `]`, it will conflict with the generated completion zsh-script.

example:
```swift
@Option(help: "This help contains invalid characters like [ or ]")
private var example: String
```

generate-completion-script:
```
    ...

    args+=(
        '--example[This help contains invalid characters like [ or ]]:example:'
        '(-h --help)'{-h,--help}'[Print help information.]'
    )

    ...
```

**ArgumentParser version:** `0.2.1`, `master`
**Swift version:** `5.3`
**Shell** oh-my-zsh / zsh

### Checklist
- [x] If possible, I've reproduced the issue using the `master` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Expected behavior
`--generate-completion-script zsh` command should alert about the invalid characters found in the `ArgumentParser:help`, and stop the process of generation script (failing).

### Actual behavior
It success the generation of the completion-script, but when you use the shell-completion, `zsh` throws some exceptions.

```
_arguments:comparguments:325: invalid option definition: --example[This help contains invalid characters like [ or ]]:example:
```

Issue 217 - Author: miguelangel-dev
Users do not familiarize with the shell-completions scripts in Zsh could be frustrated following [this guide](https://github.com/apple/swift-argument-parser/blob/280700d361c1b3af6e2345f5e24f67fa9450bec6/Documentation/07%20Completion%20Scripts.md#installing-zsh-completions). `oh-my-zsh` uses a specific filename format `_example` - I think it is useful to add this information to documentation together with an example.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary

Issue 216 - Author: interstateone
This changes the existing string substitution expression that's used to take the results of a custom completion callback and turn it into an array of strings so that each string is not split on whitespace it might contain.

I will not pretend to fully understand why this new "expand string into array" expression works when the other didn't, but it does. The new expression is based on this SO answer: https://unix.stackexchange.com/a/29748. I know just enough shell stuff to be dangerous, so it's very likely there's a better way than what I've found, and I'd be happy to get some feedback on this!

The motivation for this change was for the install command of [xcodes](https://github.com/RobotsAndPencils/xcodes) (PR with swift-argument-parser support [here](https://github.com/RobotsAndPencils/xcodes/pull/94)) to support Xcode version completion strings with multiple words, like "12.0 Beta". The previous version of this expression would split this string into two, so that "12.0" and "Beta" were independent options in the ZSH completion UI, which didn't make sense for this use case.

For example, if `xcodes ---completion install -- version` printed:

```
11.6
12.0 Beta
12.0 Beta 2
12.0 Beta 3
```

the previous implementation would result in ZSH's completion UI looking like this (braces to indicate terminal highlighting):

```
$ xcodes install <tab>
[11.6]
12.0
2
3
Beta
```

and this new implementation will result in ZSH's completion UI looking like this:

```
$ xcodes install <tab>
[11.6]
12.0 Beta
12.0 Beta 2
12.0 Beta 3
```

Similar results can be seen in the example math executable, if you add a multi-word string to the result of the customArg argument.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 215 - Author: paulofaria
[modifying-the-help-flag-names](https://github.com/apple/swift-argument-parser/blob/master/Documentation/04%20Customizing%20Help.md#modifying-the-help-flag-names) does not work for subcommands. 

Possibly related to #36.

### Checklist
- [x] If possible, I've reproduced the issue using the `master` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce

```swift
struct FeatherFeed : ParsableCommand {
    static var configuration = CommandConfiguration(
        abstract: "FeatherFeed backend application.",
        subcommands: [Run.self],
        defaultSubcommand: Run.self
    )

    ...
}


extension FeatherFeed {
    struct Run : ParsableCommand {
        static var configuration = CommandConfiguration(
            abstract: "Runs the FeatherFeed application.",
            helpNames: [.long, .customShort("?")]
        )
        
        @Option(name: .shortAndLong, help: "The host the server will run on.")
        var host: String = "::1"
        
        @Option(name: .shortAndLong, help: "The port the server will run on.")
        var port: Int = 8080
    
        ...
    }
}
```

### Expected behavior

```sh
> swift run feather-feed run --help
OVERVIEW: Runs the FeatherFeed application.

USAGE: feather-feed run [--host <host>] [--port <port>]

OPTIONS:
  -h, --host <host>       The host the server will run on. (default: ::1)
  -p, --port <port>       The port the server will run on. (default: 8080)
  -?, --help              Show help information.
```

### Actual behavior

```sh
> swift run feather-feed run --help
OVERVIEW: Runs the FeatherFeed application.

USAGE: feather-feed run [--host <host>] [--port <port>]

OPTIONS:
  -h, --host <host>       The host the server will run on. (default: ::1)
  -p, --port <port>       The port the server will run on. (default: 8080)
  -h, --help              Show help information.
```

### Discussion

Apparently subcommands are inheriting the `helpNames` configuration from the parent command. If I change `helpNames` for the `FeatherFeed` command, the `Run` subcommand inherits the `-?` flag.

Issue 214 - Author: natecook1000
As of version 0.2.1, ArgumentParser can generate shell completion scripts for Bash and Zsh, but not yet Fish. It would be great to support Fish as well! 🐟

Issue 213 - Author: natecook1000


Issue 212 - Author: natecook1000
@swift-ci Please test

Issue 211 - Author: Wevah
Just fixes a nit from #209

<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Replace this paragraph with a description of your changes and rationale. Provide links to an existing issue or external references/discussions, if appropriate.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 210 - Author: sharplet
Since https://github.com/apple/swift-argument-parser/pull/207, property wrapper usage with no arguments can now use the more natural syntax without the `()`. Updates documentation and example code accordingly.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 209 - Author: Wevah
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Makes default values for `@Argument`s and `@Option`s whose values are arrays of `ExpressibleByArgument` use their elements' `defaultValueDescription` in the help text.

Fixes #208.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 208 - Author: Wevah
`defaultValueDescription` isn't used if the argument/option is declared as an array of an `ExpressibleByArgument` type, which means the values presented in help aren't valid values when provided by the user.

**ArgumentParser version:** `0.2.0`.
**Swift version:** `Apple Swift version 5.2.4 (swiftlang-1103.0.32.9 clang-1103.0.32.53)`

### Checklist
- [x] If possible, I've reproduced the issue using the `master` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
Example:

```swift
public enum Resolution: Int, ExpressibleByArgument {
    case normal = 1
    case retina = 2
    case retinaHD = 3

    public init?(argument: String) {
        guard let int = Int(argument) else { return nil }

        self.init(rawValue: int)
    }

    public var defaultValueDescription: String {
        return String(rawValue)
    }
}
```

And then in the `ParsableCommand`:

```swift
@Option(
    name: [.customLong("resolution"), .customShort("r")],
    help: ArgumentHelp("Resolutions to generate.", valueName: "scale")
)
var resolutions: [File.Resolution] = [.normal, .retina]
```

### Expected behavior
I'd expect `command --help` to show something like

```
Resolutions to generate. (default: [1, 2])
```

### Actual behavior
`command --help` instead shows

```
Resolutions to generate. (default: [command.Resolution.normal, command.Resolution.retina])
```

Issue 207 - Author: sharplet
Fixes #206, where unless the property wrapper types were used with empty parentheses, `ParsableArguments`-conforming types would not have a no-argument initializer synthesized and thus would unexpectedbly fail to
conform to `ParsableArguments`.

This is caused by [a limitation of the compiler's property wrapper support](https://bugs.swift.org/browse/SR-13295) where it fails to see initializers in extensions as candidates for property wrapper requirements.

By declaring a no-argument intializer in each type, but then marking it as unavailable, the no-parenthesis syntax now works, but selects the existing initializers in extensions anyway.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 206 - Author: sharplet
This example from the source documentation of `Argument` doesn't compile:

```swift
struct Options: ParsableArguments {
  @Argument var name: String
  @Argument var greeting: String?
}
```

The error is `Type 'ParsableArgumentsValidationTests.Options' does not conform to protocol 'ParsableArguments'`, and the missing requirement is the default initialiser, `init()`.

<img width="887" alt="Screen capture from Xcode showing the previously-described struct Options overlaid by a compiler error that reads 'Type ParsableArgumentsValidationTests.Options' does not conform to protocol 'ParsableArguments' and a Fix-it asking 'Do you want to add protocol stubs?'" src="https://user-images.githubusercontent.com/147686/88446603-77485000-cdf9-11ea-9d8b-2d62cbb99422.png">

The way to make this example compile, as found throughout the documentation, is to declare the `name` variable as follows:

```swift
@Argument() var name: String
```

This appears to convince Swift to synthesise both `init()` and `init(name: String, greeting: String?)` initialisers. I've read [SE-0258 Property Wrappers](https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md#detailed-design) and it's still unclear to me whether the proposal text offers an explanation for this difference in behaviour.

**ArgumentParser version:** `0.2.0`, `master`
**Swift version:**
```
Apple Swift version 5.3 (swiftlang-1200.0.22.4 clang-1200.0.25.1)
Target: x86_64-apple-darwin20.0.0
```

### Checklist
- [x] If possible, I've reproduced the issue using the `master` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
To reproduce the behaviour, declare a `ParsableArguments` type using `@Argument` on one of its properties (as opposed to `@Argument()`).

### Expected behavior
The Property Wrappers proposal doesn't have a single example of the "default initialiser" syntax — i.e., with empty parenthesis after the property wrapper annotation — and it's unclear to me whether this is an intended distinction or not.

Given that the `Argument` type is initialisable without any parameters, I'd expect, or at least quite like, for Swift to be able to generate a no-argument initialiser in this case. I don't understand why adding empty parenthesis causes that to happen.

It's syntactically "cleaner" to be able to write `@Argument` instead of `@Argument()`. It feels natural to write it that way, especially when prototyping a new command and help text is not important.

### Actual behavior
See description of the issue at the top of this post.


Issue 205 - Author: bitigchi
See #203.

This PR adds support for localising Swift Argument Parser. First contribution, please mention any mistakes/possible improvements.

- [x] Modify strings for `NSLocalizedString`
- [x] Have Swift 5.3 recognise `.lproj` files in bundle


### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 204 - Author: stherold
I build a command line tool for accessing the App Store Connect API. Therefore I have a bunch of parsable commands. I now need the `verbose` flag but I want to implement it only once, e.g. via `ParsableArguments`. The thing is I don't want to use this flag in each single command but rather set it globally to `MyNetworkLayer.verbosityLevel`. Apparently I didn't find a way to read this value after it has been set so that I now misused the following way:
```swift
    mutating func validate() throws {
        // Misusing validate to set the received flag globally
        Network.verbosityLevel = verbose
    }
```

I wonder if there is  better way for this?

Issue 203 - Author: bitigchi
ArgumentParser version: `0.2.0`
Apple Swift version 5.3 (swiftlang-1200.0.16.13 clang-1200.0.22.25)
Target: x86_64-apple-darwin19.6.0

### Checklist
- [x] If possible, I've reproduced the issue using the `master` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

Since we now have localised resources for Swift packages, standard help messages should be localised as well. Having both localised and English text within the same environment really gives an unprofessional look.

### Steps to Reproduce
Create a basic command-line utility with commands and help messages.

### Expected behavior
Text like `OVERVIEW`, `USAGE`, `SUBCOMMANDS`, `Show the version.` should be localised.

### Actual behavior
Text mentioned above are in English, even when the rest of the strings are localised.

Issue 202 - Author: erica
Is there anything preventing SAP from using 5.1 to enable Mojave compilation?

```
// swift-tools-version:5.2
```

Issue 201 - Author: schlagelk
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Proposes a slight optimization of `uniquified ` added in #179.  Using `contains` on the temporary `sequence` variable leads to quadratic performance because `.contains` runs in O(n) time.  

By instead creating a temporary variable that is a dictionary, we can filter on `self` and use the dictionary's [`.updateValue`](https://developer.apple.com/documentation/swift/dictionary/3127179-updatevalue) member, passing in each element. This keeps performance near O(n) - the tradeoff being that this requires elements to conform to `Hashable` (vs just `Equatable`).

Not sure if another test is needed as all tests continue to pass, but happy to add one if this is smiled upon.

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 200 - Author: artemnovichkov
Replace this paragraph with a short description of the incorrect incorrect behavior. If this is a regression, please note the last version that the behavior was correct in addition to your current version.

**ArgumentParser version:** 
0.2.0
**Swift version:**
Apple Swift version 5.2.4 (swiftlang-1103.0.32.9 clang-1103.0.32.53)
Target: x86_64-apple-darwin19.5.0

### Checklist
- [x] If possible, I've reproduced the issue using the `master` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
Add to a package:
```swift
.package(url: "https://github.com/apple/swift-argument-parser.git", .upToNextMajor(from: "0.0.0"))
```
Have an error:
`Value of type 'S' has no member 'uniquified'`

### Expected behavior
Have no build issues

### Actual behavior
SequenceExtensions.swift must be added to target
<img width="219" alt="Screenshot 2020-06-29 at 20 43 17" src="https://user-images.githubusercontent.com/5051597/86020002-2a1acd80-ba49-11ea-8601-5ae449d11cf5.png">


Issue 199 - Author: icanswiftabit
 As a follow up to pull request #198 

### TL:DR;
The motivation behind it was the desire to react to such an error with a beautiful message.

### Motivation
In our tool, we use SwiftNIO and ArgumentParser for handling slack commands. At one point a command can fail. For example when a user provides not expect a flag. This will produce `CommandError`. NIO's `mapIfError` will bring it to `Error` type. Hence at this moment, we can only print such error.

```
CommandError(commandStack: [SlackCommands.PR], parserError: ArgumentParser.ParserError.unknownOption(ArgumentParser.InputOrigin.Element.argumentIndex(0), ArgumentParser.Name.long("some-wrong-argument")))
```

Not very user friendly :(
But if `CommandError` and `MessageInfo` would be public. We could detect if the mapped error is a `CommandError` and use `MessageInfo` to print a much nicer message. Such as

```
Error: Missing expected argument '<project-name>'
Usage: Stats project <project-name> [--repository <repository>]
  See 'Stats project --help' for more information.
```


This is how we would use it
```
func handleWebHook(payload: SlackHookPayload) throws -> Future<String> {
    return commandDispatcher.dispatch(payload: payload).mapIfError { error -> String in
        guard let commandError = error as? ArgumentParser.CommandError, let commandType = commandError.commandStack.first.self else {
            return "Command failed with a message: \(error)"
        }
        return MessageInfo(error: commandError, type: commandType).fullText
    }
}
```


Issue 198 - Author: icanswiftabit
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Change `CommandError` and `MessageInfo` to `public`. 

### TL:DR;
The motivation behind it was the desire to react to such error with a beautiful message.

### Motivation
In our tool, we use SwiftNIO and ArgumentParser for handling slack commands. At one point a command can fail. For example when a user provides not expect a flag. This will produce `CommandError`. NIO's `mapIfError` will bring it to `Error` type. Hence at this moment, we can only print such error.

```
CommandError(commandStack: [SlackCommands.PR], parserError: ArgumentParser.ParserError.unknownOption(ArgumentParser.InputOrigin.Element.argumentIndex(0), ArgumentParser.Name.long("some-wrong-argument")))
```

Not very user friendly :(
But if `CommandError` and `MessageInfo` would be public. We could detect if the mapped error is a `CommandError` and use `MessageInfo` to print a much nicer message. Such as

```
Error: Missing expected argument '<project-name>'
Usage: Stats project <project-name> [--repository <repository>]
  See 'Stats project --help' for more information.
```


This is how we would use it
```
func handleWebHook(payload: SlackHookPayload) throws -> Future<String> {
    return commandDispatcher.dispatch(payload: payload).mapIfError { error -> String in
        guard let commandError = error as? ArgumentParser.CommandError, let commandType = commandError.commandStack.first.self else {
            return "Command failed with a message: \(error)"
        }
        return MessageInfo(error: commandError, type: commandType).fullText
    }
}
```


### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate // Not applicable
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary // Not applicable


Issue 197 - Author: NicFontana
This avoids the infinite recursion that causes a crash and shows the user a meaningful error message.

Fixes: https://github.com/apple/swift-argument-parser/issues/192

<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 196 - Author: MPLew-is
Un-deprecates (but changes the semantics of) the initializers for an array value type without a default, forcing the user to specify at least one value from the command line.

The motivation behind this is to allow users of this framework to force a user to provide at least one argument, without having to provide custom error handling. An example of a command that uses this argument setup is `cp`, which has a variant for one or more `source_file` arguments:
`cp [-R [-H | -L | -P]] [-fi | -n] [-apvX] source_file ... target_directory`

This unfortunately does un-do the deprecations done In #193 and also is a source-breaking change in a similar vein as the one in #170 (changing the semantics of the case where no default is provided) and so will need to wait for the next minor release as per the documentation. I'm happy to sit on this and occasionally re-integrate `master` into it until you're ready for a new release, but figured I'd at least get it in for review.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 195 - Author: natecook1000


Issue 194 - Author: natecook1000


Issue 193 - Author: natecook1000
### Description
This integrates the changes in #170 and #186, moving array default values to the normal syntax.

### Detailed Design
This kind of declaration is now permitted:

```swift
struct Example: ParsableCommand {
    @Argument(help: "Your lottery numbers")
    var lotto: [Int] = [4, 8, 15, 16, 23, 42]
}
```

### Documentation Plan
Updated symbol documentation and guides.

### Test Plan
Unit tests

### Source Impact
The new defaults in #170 haven't been included in a release yet, so there's no source breakage. Declarations of array options or arguments will have a deprecation warning indicating that users should specify an empty array literal as the property default.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 192 - Author: MaxDesiatov
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace each paragraph
    below with the relevant details for your bug, and complete
    the steps in the checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Specifying a command type as its own subcommand in `CommandConfiguration` causes segmentation fault instead of a proper error.

**ArgumentParser version:** `0.1.0`
**Swift version:** 
```
Apple Swift version 5.2.4 (swiftlang-1103.0.32.9 clang-1103.0.32.53)
Target: x86_64-apple-darwin19.5.0
```

### Checklist
- [x] If possible, I've reproduced the issue using the `master` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce

```swift
import ArgumentParser

struct Install: ParsableCommand {
  static var configuration = CommandConfiguration(
    abstract: "Install new thingy.",
    subcommands: [Install.self]
  )
}
```

### Expected behavior
This maybe could fail to compile (which is probably hard to express on the type system level), or at least the recursion should be detected and reported as an error at run time.

### Actual behavior

Running an application with this code crashes with no actionable errors, only with a "segmentation fault" message.


Issue 191 - Author: MPLew-is
This is intended to replace the `Bool` flag without an inversion, as it more closely matches the underlying usage model of a flag being provided vs. not provided on the command line.

This is mostly a proof-of-concept proposal as a discussion point, relating to [the discussion about no-inversion `Flag`s in #170](https://github.com/apple/swift-argument-parser/pull/170#discussion_r441395593). As a summary, this proposal is intended to address the behavior of flags without inversions:
```swift
struct SomeArguments: ParsableCommand {
    @Flag() var someFlag: Bool
    func run() throws {
        if someFlag {
            ...
        }
    }
}
```

As discussed in the comment linked above, in my opinion, a `Bool` doesn't represent the high-level usage model as well as an `Optional` type, especially with the usage of `Bool`s in flags that have inversions and can be set by the user to have both `true` and `false` as a value, not only `true`. This PR proposes to replace the above usage with:
```swift
struct SomeArguments: ParsableCommand {
    @Flag() var someFlag: Void?
    func run() throws {
        if someFlag != nil {
            ...
        }
    }
}
```

This gains us the following benefits:
- Sidesteps the potential confusion over a non-optional value having an implicit default value currently on `master`
- Sidesteps the need to force users to provide an explicit `false` for every flag as currently on #170, while doing so in a Swift-like manner (since optionals already default to `nil`, users will be familiar with this usage pattern)
- As mentioned, better represents the high-level usage of the command-line arguments, which is both a little cleaner and will probably help stave off future issues down the road (at least in my own experience, aligning the usage and the underlying model helps to prevent weird corner-cases as things are extended)
- Simplifies code that deals with flags with inversions, as the inversion can now be inferred from the type and defaulted to `.prefixedNo` for all `Bool`s

However, this does come at a cost:
- Using `Void?` may seem strange to users that aren't "cracking the hood" of this framework, so to speak, and will likely cause some confusion that needs to be sorted out in documentation
    - This cost could be reduced by using a better-named `typealias` or single-case `enum` as described in the initial discussion linked above, but I don't know of a great name for that either (`Unary`?)
- Adds some minor complexity to existing code (the addition of `!= nil` above)

I personally feel like those benefits are worth it, but I don't think there's an exceptionally strong case for it either like there was for the default property initialization syntax in #170. Mostly, I was just curious as to what it would take to implement this and provide a concrete implementation to start off dicussion.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 190 - Author: joetennant
In some cases, it is desirable to use a command parser without exiting the process and/or redirecting the printing of help messages.

Proposal (Printing)
A `TextOutputStream` would be optionally provided to `main()` or `parseAsRoot()` to handle the output from help. 

Proposal (Handling Exit)
A protocol would be created that would expose an exit handler. An implementation of an exit handler could be provided to `main()` or to `parseAsRoot()` and would be called to actually exit the process (or provide whatever functionality may be desirable).

For example (using a protocol)
```
protocol ExitHandler {
   func exit(exitCode: Int)
}
class CleanupBeforeExit: ExitHandler {
   func exit(exitCode: Int) {
      doSomethingImportant()
      sendSometNotifications()
      cleanUpResources()
      darwinExit(exitCode)
   }
}

Issue 189 - Author: owenv
Some of the SPM builders appear to be running CMake 3.15.4, so I'm back porting ArgumentParser to 3.15.1 to match SPM's minimum version. I haven't tested this on Windows yet to make sure the output directory workarounds behave as expected, I'm going to try to spin up a VM this weekend.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


cc @compnerd 

Issue 188 - Author: john-mueller
Allows negative numbers to be passed as options and arguments.

Fixes #31 

### Checklist
- [X] I've added at least one test that validates that my change is working, if appropriate
- [X] I've followed the code style of the rest of the project
- [X] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [X] I've updated the documentation if necessary (no need)


Issue 187 - Author: natecook1000
This pushes any errors indicated by unexpected arguments after parsing out to the same late position. We were previously stopping immediately when the command is a leaf node; that isn't necessary and created an awkward second error path.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 186 - Author: john-mueller
The adds the `default` parameter to `@Option` and `@Argument` initializers when the value type is an array. Default values are overridden when passing explicit values on the command line. Default is still an empty array if `default` parameter is omitted and no explicit values are passed.

Closes #107

### Checklist
- [X] I've added at least one test that validates that my change is working, if appropriate
- [X] I've followed the code style of the rest of the project
- [X] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [X] I've updated the documentation if necessary


Issue 185 - Author: compnerd
Add missing reference to `Utilities/SequenceExtensions.swift` which was failed to be updated with #179

<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Replace this paragraph with a description of your changes and rationale. Provide links to an existing issue or external references/discussions, if appropriate.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 184 - Author: sharplet
I'd like to be able to customise the command synopsis a little bit more. The current synopsis generator in `UsageGenerator` will collapse all options into a single `<options>` entry if there are more than twelve. My command has only 3 options, but with the long names being included in the synopsis, it's already unwieldy.

A few of ideas:

- Allow providing a manual synopsis.
- Similar to `.hidden`, allow hiding of options on a case-by-case basis.
- Collapse options with default values by default.

Issue 183 - Author: artemnovichkov
It would be useful to see default subcommand in help messages.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 182 - Author: artemnovichkov
I want to use dictionary as a parameter. Is it possible with current implementation?
```swift
@Option(help: "The output for the template.")
var parameters: [String: String]
```
It's not possible with current implementation as I understood:
```
Referencing initializer 'init(name:default:parsing:help:)' on 'Option' requires that '[String : String]' conform to 'ExpressibleByArgument'
```
Can we add something like:
```
--parameters key1:value1 key2:value2
```

Issue 181 - Author: natecook1000
Fixes #180.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 180 - Author: KyLeggiero
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace each paragraph
    below with the relevant details for your bug, and complete
    the steps in the checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

The README demonstrates old behavior, where attempting to erroneously run a command with no arguments would result in an error message and a usage line. Since #140, an error message and the help text would be shown.

**ArgumentParser version:** `master` branch, as of [3d79b2b5a2e5af52c14e462044702ea7728f5770](https://github.com/apple/swift-argument-parser/tree/3d79b2b5a2e5af52c14e462044702ea7728f5770)
**Swift version:** Any

### Checklist
- [x] If possible, I've reproduced the issue using the `master` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
Look at the README

### Expected behavior
README shows current behavior, where attempting to erroneously run a command with no arguments would result in an error message and the help text being shown.

### Actual behavior
README shows past behavior, where attempting to erroneously run a command with no arguments would result in an error message and a usage line.


Issue 179 - Author: ibrahimoktay
SortedNames for ArgumentDefinition has been changed.
NameSpecification now uses Array type for elements.

* Usage will choose the first long name, if available, or otherwise the first short name
* Help screen will show short names, then long names, in the order of their declaration.

Solves (#167)

<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Replace this paragraph with a description of your changes and rationale. Provide links to an existing issue or external references/discussions, if appropriate.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 178 - Author: natecook1000
This includes updating the examples of declaring the dependency, as well.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 177 - Author: natecook1000
This change converts the old `@Flag` initializers for `CaseIterable`/`String` enums from deprecated to unavailable, in preparation for the 0.1.0 release.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 176 - Author: natecook1000
### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 175 - Author: BradLarson
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

The CMakeLists.txt was missing `Parsable Types/ParsableArgumentsValidation.swift`. This adds that file to the CMakeLists.

### Checklist
- [X] I've added at least one test that validates that my change is working, if appropriate
- [X] I've followed the code style of the rest of the project
- [X] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [X] I've updated the documentation if necessary


Issue 174 - Author: BradLarson
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

The usage of `sqrt()` requires linking libm on Linux. This adds the appropriate CMake entry to allow for this.

### Checklist
- [X] I've added at least one test that validates that my change is working, if appropriate
- [X] I've followed the code style of the rest of the project
- [X] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [X] I've updated the documentation if necessary


Issue 173 - Author: natecook1000
### Description
This drops the `ExpressibleByArgument` conformance for `Optional`. This conformance doesn't quite make sense, and allowed property declarations like this:

```swift
@Option(default: 0) var count: Int?
```

The default value meant that `count` would never be `nil`, and therefore shouldn't be optional.

### Detailed Design
This change adds initializers specifically for when an `Option`'s or `Argument`'s value is optional, without a `default` parameter as well as deprecated versions that include a `default` parameter to guide clients to the correct declaration syntax.

### Documentation Plan
The new initializers are documented; related initializers have been updated. There is no change required in the guides.

### Test Plan
Existing tests exercise the functionality and verify the largely source-compatible nature of the change.

### Source Impact
While this is technically source-breaking, it should have minimal impact in regular usage. All the declaration sites for arguments and options with optional values are still supported, with deprecation warnings for declarations that combine a default value and an optional type. If a property is declared as optional but does not have a default value, there won't even be a deprecation notice.

Code that uses `Optional`'s conformance to `ExpressibleByArgument`, however, will break without warning. Users can work around this by adding an `Optional`-specific code path, or by other means.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 172 - Author: natecook1000
NFC. This adds compilation tests for all the property wrappers, including all the various permutations of their default parameter values.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 171 - Author: tesch
When initializing a custom option with a default value of a type that is different from the type of the actual option property, it is actually treated as a required argument.

```swift
enum Flag {

    case left, right

    init(_ value: String?) {
        self = (value == nil) ? .left : .right
    }

}

@Option(default: nil, transform: Flag.init)
var flag: Flag
```

In `--help` this option is presented as `--flag <flag>` instead of `[--flag <flag>]` and it is impossible to run without given and explicit argument to `--flag`. The default value is effectively ignored.

Issue 170 - Author: MPLew-is
This change allows the normal `var foo = "blah"` default initialization syntax for `Option`s, as a parallel initialization method as using the `default` parameter.

This syntax may feel more natural to some developers (myself included), but does not break any existing code using the original initialization method.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 169 - Author: Frizlab
My use case is an example from `git`.
Potentially linked discussion: https://forums.swift.org/t/supporting-subcommands-with-same-option-name-as-reused-parent-command

Let’s consider `git commit` specifically which has the `-C` option to specify a commit from which to reuse the log message and other.
`git` by itself also has a `-C` option, to change the repository path.

Thus, we can legally call git with:
```
git   -C my_path   commit   -C my_commit
```

If I’m not mistaken, this setup is currently impossible to describe using `ArgumentParser`.

Ideally, I think this:
```swift
struct GlobalOptions : ParsableArguments {
   @Option(name: .customShort("C"))
   var path: String
}

struct Git : ParsableCommand {
   static var configuration = CommandConfiguration(
      abstract: "…",
      subcommands: [
         GitCommit.self
      ]
   )

   @OptionGroup()
   var globalOptions: GlobalOptions
}

struct GitCommit : ParsableCommand {
   static var configuration = CommandConfiguration(abstract: "…")

   @OptionGroup()
   var globalOptions: GlobalOptions

   @Option(name: .customShort("C"))
   var commitFrom: String

   func run() throws {
      print(globalOptions.path)
      print(commitFrom)
   }
}
```
When called like this:
```
git -C path commit -C commit
```
Should print:
```
path
commit
```
Currently it says there is a missing `-C` argument.

Issue 168 - Author: natecook1000
This fixes #130 by (1) not consuming the `--` terminator while parsing, and (2) ignoring the terminator when checking to see that all the arguments have been used.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 167 - Author: erica
My help message (in part):

> When it's that time there: "now --remote 5PM Bath UK"
> USAGE: now [--local <local>] [--when <when>] [<location-info> ...]
> ...
>   -r, --remote, --remote-time, --there, --when <when>

My declaration:

```
name: [.short, .customLong("remote"),  .customLong("when"), .customLong("there")],
```

I'd like the SAP to prefer the first long specification, placing it at the end of the alphabetized items. That would allow my help message to look like this instead:

> When it's that time there: "now --remote 5PM Bath UK"
> USAGE: now [--local <local>] [--remote <remote>] [<location-info> ...]
> ...
>   -r, --there, --when, --remote <remote>



Issue 166 - Author: ibrahimoktay
When argument is an array and no input is given but “-h”, if you throw an Error in Validate function, it prints error and short usage instead of help message.

'command -h'

This patch checks built-in flags before throwing a validation error.

Solves #149

<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Replace this paragraph with a description of your changes and rationale. Provide links to an existing issue or external references/discussions, if appropriate.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 165 - Author: natecook1000
This adds some new messages to error and help output that guide users to find more information.

Validation errors now include a message about using `--help`:

```
$ roll --bad-flag
Error: Unknown option '--bad-flag'
Usage: roll [--times <n>] [--sides <m>] [--seed <seed>] [--verbose]
  See 'roll --help' for more information.
```

The help screen now shows a message about the implicit `help` subcommand when the help screen contains subcommands:

```
$ math --help
OVERVIEW: A utility for performing maths.

USAGE: math <subcommand>

OPTIONS:
  --version               Show the version.
  -h, --help              Show help information.

SUBCOMMANDS:
  add                     Print the sum of the values.
  multiply                Print the product of the values.
  stats                   Calculate descriptive statistics.

  See 'math help <subcommand>' for detailed help.
```

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 164 - Author: aciidb0mb3r
This can be helpful to write tooling that generates documentation files in various formats.

Issue 163 - Author: natecook1000
### Description
This changes `ParsableCommand`'s `run` requirement to be mutating. This allows for things like in-place sorting or filtering of arguments without making a mutable copy.

This change supersedes #33.

### Detailed Design
The only change here is the switch to mutating for the `run()` method.

```swift
protocol ParsableCommand: ParsableArguments {
    // other requirements

    /// ...
    mutating func run() throws
}
```

### Documentation Plan
We didn't previously mention the non-mutatingness of `run()`, so that doesn't require a change. All code samples have been updated to implement the new requirement.

### Test Plan
All existing tests pass with the change.

### Source Impact
~This **will require code changes** for every command that implements a `run()` method, since a non-mutating `run()` won't properly satisfy the new requirement. Since `ParsableCommand` provides a default implementation for `run()`, there unfortunately won't be any indication of this change at compile time.~

Apparently this _is_ in fact source-compatible with existing code. Clients can add `mutating` as they want, but existing non-mutating `run()` methods will be called correctly. 🎉

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 162 - Author: natecook1000
### Description
This brings the `main()` method in line with using the new `@main` attribute on the root
command type.

### Detailed Design
The changes here are to make `ParsableCommand.main()` a `Void`-returning function, to break out a separate no-argument version, and to remove the default parameter. The default-argument version doesn't satisfy the `() -> Void` requirement for `@main`.

The `main()` method now returns without exiting on successful execution of a 

### Documentation Plan
No real impact. Documentation for using `@main` with the library to follow.

### Test Plan
All existing tests continue to pass. SwiftPM will need an update to support `@main` in executable targets.

### Source Impact
Typical code should continue to behave as expected, but this is source-breaking if anyone has a strongly-typed usage of `ParsableCommand.main()`, e.g. `let mainFunction: ([String]?) -> Never = MyCommand.main`. Keeping the old version with a deprecation/unavailability annotation isn't possible, since there would be ambiguity between that and the new ones.

In addition, code that followed `MyCommand.main()` in `main.swift` is no longer dead code, and will be executed after successful execution of the command.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 161 - Author: erica
In the event a configuration has an empty abstract and non-empty discussion,
an extra line was generated. This patch removes that line.

ISSUE: SAP-156 https://github.com/apple/swift-argument-parser/issues/156

<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Replace this paragraph with a description of your changes and rationale. Provide links to an existing issue or external references/discussions, if appropriate.

### Checklist
- [x ] I've added at least one test that validates that my change is working, if appropriate
- [x ] I've followed the code style of the rest of the project
- [x ] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x ] I've updated the documentation if necessary


Issue 160 - Author: erica
Just as SAP creates and populates help from its property wrappers, I believe it would be useful to have a way to document exit codes produced by the command line utility and incorporate them into help.

Even though there are Unix standards like sysexit.h, the developer may wish to:

* Express _which_ exit codes are produced
* Document custom exit codes


Issue 159 - Author: erica
I know this one is a little tenuous but I thought I'd throw it out there and if you don't like it, it can be as easily closed as any other feature request:

A flag that allows the discussion text (`CommandConfiguration(discussion: "")`) to be displayed at the end of help instead of the beginning so the options are visible to the user in the first screen of `more`/`less`. The current output is heavily weighted towards the style of internal code comments instead of the tooling needs of the end-user, who often wants to review the flags, options, arguments (and okay subcommands) quickly, and then use the tool immediately. This is the pattern used for memory refresh.

Reading the full discussion is more typical for someone who is encountering an issue with the tooling and looking for deeper instruction material, and is more typically secondary to casual use. (see also: "full help")

Issue 158 - Author: erica
This feature request builds on the notion of a full help user-driven option.

Under such a feature, this request would allow the developer to specify how the abstract and discussion are presented, allowing either or both to be presented in full-help only or in both.

The goal is to provide a succinct default help and allow a deeper dive in full-help, controlling which items of the configuration are presented.

Issue 157 - Author: erica
Current: hidden items are excluded from help. This is particularly useful for backend features that can be dangerous and extraneous features that clutter the help message but ultimately defeats the purpose of a utility meant to be shared and well documented in itself rather than man pages.

Suggested approach: Allow dangerous or extraneous features to be shown in "full help" by extending hidden beyond a BOOL to an optional enumeration. (This does not address long help, which is discussed under other tickets):

`hidden: .always, // excludes from help as currently implemented` 
`hidden: .fullOnly, // allows participation in help in an extended "full help" output`

Notes:
* This _would_ affect USAGE participation
* This _does not_ address differing participation in the USAGE and ARGUMENTS/OPTIONS sections
* This _does not_ address how such help might be generated
* This _does not_ address how such help might be invoked

Issue 156 - Author: erica
`OVERVIEW: 

Check the time at a given location.

- For example: "now Sao Paolo" (diacriticals), "denver" (case), "20202"
  (postal codes), "Lincoln Memorial" (well known placemark) etc.
- Set a reference time with `at`, for example "now --at 5:45PM Bath UK".
- Valid times include: 5PM, 5P, 5:30PM, 5:30P, 17:30. (No spaces.)`

The material in the command summary uses a lot of excess white space, which fills up the vertical screen. Many users stick to 80x24 terminal geometries and won't necessarily use `more` or `less` to page output. Squeezing the vertical information by optionally eliminating the extra line after OVERVIEW, etc, would create more succinct output and prevent the user from having to search so much for the `USAGE` line.

Issue 155 - Author: erica
I'd like to be able to optionally control the USAGE for `.remaining` parsing to provide appropriate plurality. The screenshot below suggests that the user enters multiple location hints. They do not. With the `.remaining` parsing, the arguments become a single location hint.

_What I see:_

`USAGE: now [--time <time>] [<location-hint> ...]`

_What I want (ideas):_ 

`USAGE: now [--time <time>] [<location-hint...>]`
`USAGE: now [--time <time>] <...location-hint...>`

![image](https://user-images.githubusercontent.com/32688/82388997-32b6c780-99f8-11ea-85c9-7854e68e31da.png)


Issue 154 - Author: erica
Sometimes arguments are best handled in USAGE without needing their own section as in the following screen-shot.  I would like to be able to hide the ARGUMENTS section for the location hint(s).

![image](https://user-images.githubusercontent.com/32688/82388897-ecf9ff00-99f7-11ea-9350-739024064cbd.png)


Issue 153 - Author: erica
![Screen Shot 2020-05-18 at 2 57 25 PM](https://user-images.githubusercontent.com/32688/82259079-3bd06780-9918-11ea-884d-32505381bcaa.png)

```
% greet --points 10
Hello, World!!!!!!!!!!
% greet --points -10
Error: Missing value for '--points <points>'
Usage: greet [--points <points>] [--name <name> ...] [--single] [--double] [<greeting> ...]
% greet --points=-10
Error: Exclamation count must be positive
% 
```

The correct behavior is the error. There are times passing negative numbers is the desired outcome

Issue 152 - Author: erica
![image](https://user-images.githubusercontent.com/32688/82160840-42e27180-9855-11ea-8c6a-9c69a6d80dd8.png)

Expect: --single, --double (raw values)
Get: --single-quote, --double-quote (the member names)

Current workaround: use the wonderful `name(for:)` method but it would be better not to have to.

Issue 151 - Author: bdrelling
## Problem Statement

Given the following command:

```swift
struct List: ParsableCommand {
    private enum Filter: String, ExpressibleByArgument {
        case all
        case devices
        case deviceTypes
        case runtimes
        case pairs
    }
    
    @Option(default: .all, help: "Allows filtering of list output.")
    private var list: Filter
}
```

When I call `swift run list --help`, I only see the following:

```
OVERVIEW: Lists all simulator devices, device types, and runtimes available.

USAGE: list [--mode <mode>]

OPTIONS:
  --filter <filter>       Allows filtering of specific list output. (default: all)
```

## Proposed Solution

We could add the property `allowedValues: [Value]?` to the `Option` and `Argument` property wrappers, simply referenced as `allowed` in the initializer. Based on the previous example, it could be declarable like so:

```swift
@Option(default: .all, allowed: [.all, .devices, .deviceTypes], help: "Allows filtering of list output.")
```

If `@Option` happens to be applied to value that implements `CaseIterable`, we could default to `.allCases` for the value as well if it is left `nil`. That would further simplify the declaration.

The output of `swift run list --help` would now look something like:

```
  --filter <filter>       Allows filtering of specific list output. (default: all) (allowed: devices, deviceTypes, pairs, runtimes)
```

Notice also that it excludes the default value, so as to reduce unnecessary detail. I'm not sure if doing so would have any negative effects. I'm not really sold on adding it to the end versus surfacing it some other way that commands might (simple array syntax, showing it under the option, etc.).

## Additional Thoughts

I'm torn on whether or not we should specifically validate against this list--my gut says that if someone wants that functionality, they could simple use an enum-backed `Option`. I would also find it beneficial to continue to have "secret" options available--the `allowedValues` are the ones shown to the user, but the _actual_ validated values are still triggered when the command is sent and handled.

Issue 150 - Author: compnerd
This extends the CMake build to install the artifacts.  This is required
for redistribution of the build.

<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Replace this paragraph with a description of your changes and rationale. Provide links to an existing issue or external references/discussions, if appropriate.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 149 - Author: sharplet
My command accepts a list of paths as arguments, using `@Argument() var paths: [String]`. I couldn't find a built in way to validate that the array is non-empty, so I implemented `validate()` and throw a `ValidationError` in that case. Because CommandParser [validates commands before checking if help was requested](https://github.com/apple/swift-argument-parser/blob/223d62adc52d51669ae2ee19bdb8b7d9fd6fcd9c/Sources/ArgumentParser/Parsing/CommandParser.swift#L204), only a short usage string is ever displayed, instead of the full help text. 

**ArgumentParser version:** 0.0.6

**Swift version:**
```
Apple Swift version 5.2.2 (swiftlang-1103.0.32.6 clang-1103.0.32.51)
Target: x86_64-apple-darwin19.4.0
```

### Checklist
- [x] If possible, I've reproduced the issue using the `master` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce

Paste this into a new Swift package:

```swift
import ArgumentParser

struct Test: ParsableCommand {
  @Argument(help: "A list of paths.")
  var paths: [String]

  func validate() throws {
    if paths.isEmpty {
      throw ValidationError("At least one path must be specified.")
    }
  }

  func run() throws {
    for path in paths {
      print(path)
    }
  }
}

Test.main()
```

Then run `swift run test --help`.

### Expected behavior

Expected the command to output the help text.

### Actual behavior

Received this output instead:

```
Error: At least one path must be specified.
Usage: test [<paths>  . . .]
```

Issue 148 - Author: aleksey-mashanov
Every lines in option's discussion must be properly indented, even the short ones.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 147 - Author: aleksey-mashanov
Documentation for `Option.init(... transform:)` says: "If the property has an `Optional` type, or you provide a non-`nil` value for the `initial` parameter, specifying this option is not required."
Initializer works exactly this way but provides wrong synopsis for `Optional` type properties.


### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 146 - Author: natecook1000
I've been using this to generate the list of contributors for each release.

Issue 145 - Author: natecook1000
Preparing to tag the 0.0.6 release.

Issue 144 - Author: bdrelling
In addition to using flags like `--help`, I'd really love to have a flag like `--verbose` that exists in every one of my commands or subcommands without being defined over and over.

Currently, I could probably subclass `ParsableCommand` into something like `VerboseParsableCommand`, but I'm wondering if there would be a simpler way to have flags cascade downwards, specifically with regards to showcasing it in the help documentation.

If I have a command `format` with subcommands `autocorrect` and `analyze`, it would be nice if I could specify `--verbose` only within the `format` command and have it still cascade down to `autocorrect` and `analyze` without having to add it into each option every time.

Issue 143 - Author: bdrelling
Commands with default subcommands do not have discoverable usage information without digging into the subcommand itself. Below, I'll outline the structure of a simple project as well as two proposals for updating the help information for commands that have a default subcommand.

Simply put, a command with a default subcommand likely doesn't have any information it runs itself and, as such, should specify the information that is available by running the default subcommand.

## Structure

For ease of clarity, repeating the structure of my project here:

Command: `zinc`
Subcommands: `lint`, `sync`
Default Subcommand: `sync`

## Proposal 1 -  Highlighting the Default Subcommand

### Problem Statement

The output of `zinc --help` is such that the default subcommand is not made clear.

This is what prints:

```
SUBCOMMANDS:
  lint                    Performs basic linting against a Zincfile to identify issues and errors.
  sync                    Syncs local files with remote files as defined by a Zincfile.
```

### Proposed Solution

I'm proposing we highlight the default subcommand somehow:

```
SUBCOMMANDS:
  lint                    Performs basic linting against a Zincfile to identify issues and errors.
  sync                    (default) Syncs local files with remote files as defined by a Zincfile.
```

## Proposal 2 - Prefer Default Subcommand Usage

### Problem Statement

If I specify a default subcommand in my project, while I would allow someone to run `zinc sync <args>`, specifying a default subcommand likely implies that I'm happy with `zinc <args>`. As such, I think that the output of `<command> --help` should be refined.

Right now, here's what prints out when I run `zinc --help`:

```
OVERVIEW: Zinc is a command-line tool for keeping local files in sync with files hosted outside of your folder or
repository.

USAGE: zinc <subcommand>

OPTIONS:
  -h, --help              Show help information.

SUBCOMMANDS:
  lint                    Performs basic linting against a Zincfile to identify issues and errors.
  sync                    Syncs local files with remote files as defined by a Zincfile.
```

Here is the output of `zinc sync --help`:

```
OVERVIEW: Syncs local files with remote files as defined by a Zincfile.

USAGE: zinc sync [--file <file>] [--verbose]

OPTIONS:
  -f, --file <file>       The Zincfile to parse and use for syncing. (default: Zincfile)
  --verbose               Logs additional debug messages if enabled.
  -h, --help              Show help information.
```

### Proposed Solution

I'm not sure what the right answer is here, but I imagine we should see an example of the default command being run, along with additional subcommands still. 

I'm not sold on this, but here's an example:

```
OVERVIEW: Zinc is a command-line tool for keeping local files in sync with files hosted outside of your folder or
repository.

USAGE: 
  zinc --file <file>
  zinc <subcommand>

OPTIONS:
  -f, --file <file>       The Zincfile to parse and use for syncing. (default: Zincfile)
  --verbose               Logs additional debug messages if enabled.
  -h, --help              Show help information.

SUBCOMMANDS:
  lint                    Performs basic linting against a Zincfile to identify issues and errors.
  sync                    (default) Syncs local files with remote files as defined by a Zincfile.
```

## Additional Notes

I'd like some additional feedback on the proposed solutions. I'm poking around at a variety of commands that I use day-to-day in my Swift projects as well as some outside of the Swift ecosystem and there's a variety of answers, but almost all at least provide some help documentation for a default subcommand within the help documentation of the command itself if requested.

Issue 142 - Author: natecook1000
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your request, please replace each paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

### Description
This adds two methods for generating the help screen for a command or subcommand.

### Detailed Design
The additions includes two methods, one on `ParsableArguments` and one on `ParsableCommand`. The second method has a `subcommand` parameter, and is called on the root command to generate the help text for a subcommand:

```swift
let help = RootCommand.helpMessage(for: Subcommand.self)
```

The two new methods:

```swift
extension ParsableArguments {
    /// Returns the text of the help screen for this type.
    public static func helpMessage(columns: Int? = nil) -> String
}

extension ParsableCommand {
    /// Returns the text of the help screen for the given subcommand of this
    /// command.
    public static func helpMessage(
        for subcommand: ParsableCommand.Type,
        columns: Int? = nil
    ) -> String
}
```

### Documentation Plan
Documentation is included for the new methods, and I've added a section at the end of the guide about customizing help.

### Test Plan
I've added tests of these APIs wherever we've previously been testing the help screens.

### Source Impact
This is an additive change only.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 141 - Author: john-mueller
This fixes #132, by letting you separate a short option and its value with an equals sign.

The new tests are in EqualsEndToEndTests.swift for now, but arguably they belong in ShortNameEndToEndTests.swift. I can move them if necessary. I also omitted new tests for long argument names with equals sign, as that seems to be tested elsewhere.

I don't think there needs to be any further documentation, as this was already the documented behavior.

### Checklist
- [X] I've added at least one test that validates that my change is working, if appropriate
- [X] I've followed the code style of the rest of the project
- [X] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [X] I've updated the documentation if necessary


Issue 140 - Author: john-mueller
This implements the feature mentioned in #134. I think it would also remove the need for #135.

When a `ParserError` is thrown, check to see if there are zero arguments. If so, the error is wrapped in the new `.noArguments` case, which allows the original error to be reported, while also triggering the full help message instead of usage.

If there's a Swiftier/more concise way of writing the addition to MessageInfo.swift, I'd love to know.

I wasn't sure whether this needs explicit mention in the documentation, and if so, which section to add it to.

### Checklist
- [X] I've added at least one test that validates that my change is working, if appropriate
- [X] I've followed the code style of the rest of the project
- [X] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 139 - Author: owenv
This is a fairly early attempt at integrating this repo into the SwiftPM bootstrapped build, someone better at CMake than I am should probably review :)

Issue 138 - Author: owenv
### Checklist
- [x ] I've added at least one test that validates that my change is working, if appropriate
- [x ] I've followed the code style of the rest of the project
- [x ] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 137 - Author: armandgrillet
I have this option:
```
@Option(name: [.short], help: "Only search for files with a specific pattern")
var filenamesPattern: String
```

This results in this help:
```
OPTIONS:
  -f <f>                  Only search for files with a specific pattern
```

I would like to print `-f <pattern>` instead of `-f <f>` to make the help more descriptive. I have looked at the `NameSpecification` in swift-argument-parser but couldn't find a way to specify what the value should be (in my example: `pattern`). 

Note that `pattern` would also not be the name of the variable relating to this option.

Issue 136 - Author: erica
In the following example, the caller has substituted a single dash for a double in the `sound` key/value pair:

```
% remind -d 20 my reminder -sound tink
Error: The value 'tink' is invalid for '-d <days>'
```

The error should read:

```
Error: The value 'tink' is invalid for '-s <seconds>'
```


Issue 135 - Author: erica
Adds configuration option that allows a command to present help when
no other input is provided by the user at the command-line call.

### Description
This change introduces a hook so users can configure the command to
respond with a help message on the absence of arguments.

### Detailed Design

```swift
// CommandConfiguration:
// ...
  /// A Boolean value indicating whether this command should display help
  /// when executed without further user input.
  public var defaultToHelp: Bool
// ...
```

### Documentation Plan
Updated code doc in CommandConfiguration.swift

### Test Plan
Test with updated math.swift. Instead of returning 0 without arguments, it should return the help message.

### Source Impact
This is purely additive and optional, defaulting to `false`, the existing behavior.

### Checklist
- [x ] I've added at least one test that validates that my change is working, if appropriate
- [x ] I've followed the code style of the rest of the project
- [x ] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary 

I have not updated the documentation, but will amend this PR if the idea has a chance for moving forward.


Issue 134 - Author: natecook1000
When running a command-line tool, if the user doesn't specify any inputs at all it's a good bet that they aren't familiar with the command. If there are required arguments/options/flags, we should show the error message with the full help screen instead of just the abbreviated usage.

For example, if you run the example `repeat` command with no inputs, you get this:

```
$ swift run repeat
Error: Missing expected argument '<phrase>'
Usage: repeat [--count <count>] [--include-counter] <phrase>
```

Instead, it would be great to show this:

```
$ swift run repeat
Error: Missing expected argument '<phrase>'

USAGE: repeat [--count <count>] [--include-counter] <phrase>

ARGUMENTS:
  <phrase>                The phrase to repeat. 

OPTIONS:
  --count <count>         The number of times to repeat 'phrase'. 
  --include-counter       Include a counter with each repetition. 
  -h, --help              Show help information.
```

Issue 133 - Author: natecook1000


Issue 132 - Author: captainbarbosa
**ArgumentParser version:** `0.0.5`, `master`
**Swift version:** 

```
Apple Swift version 5.2.2 (swiftlang-1103.0.32.6 clang-1103.0.32.51)
Target: x86_64-apple-darwin19.4.0
```

### Checklist
- [x] If possible, I've reproduced the issue using the `master` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce

Defining an option with a `.customShort` name doesn't support an equal sign (`=`) between key-value pairs.

### Expected behavior
Specifying an option with an equal sign in between key-value pairs should succeed, as noted in the [documentation](https://github.com/apple/swift-argument-parser/blob/master/Documentation/02%20Arguments%2C%20Options%2C%20and%20Flags.md#declaring-arguments-options-and-flags):

>Options are named key-value pairs. Keys start with one or two dashes (- or --), and a user can separate the key and value with an equal sign (=) or a space.

### Actual behavior

The command line execution fails when `cool -r=4` is attempted:

```
Error: Unknown option '-r'
Usage: cool [--repeat-count <repeat-count>]
```

Here is a sample `main.swift` you can use to reproduce:

```swift
import Foundation
import ArgumentParser

struct BeCool: ParsableCommand {
    static let configuration = CommandConfiguration(
        commandName: "cool",
        abstract: "Be super cool",
        discussion: "Demonstrates how to be cool",
        version: "0.0.1",
        shouldDisplay: true)
    
    
    /** OPTIONS */
    // [FAIL]  -r=4
    // [OK]    -r 4
    // [OK]    --repeat-count=4
    @Option(
        name: [.customShort("r"), .long],
        help: "Number of times the word \"Cool\" is repeated. Defaults to 1."
    )
    var repeatCount: Int?
    
    func run() throws {
        
        let outputString = String(repeating: "Cool ", count: repeatCount ?? 1)
        
        print(outputString)
    }
}

BeCool.main()
```


Issue 131 - Author: richiwalt
There are several cases where double char values (i.e. a STRING) are useful as SHORT Options, I’ll give just one example:

Common in the world of HPC (High Performance Computing) is the qsub command to submit jobs to run on a supercomputer.  (Government, Industry, and Research HPC sites do this all the time) 

Common short flags for a qsub are:
-a for account, or, as we name it: projectID
-w for walltime holding HH:MM:SS string for the time requested to allow a job to run
-**nn** for number of backend compute nodes
-**np** for number of processes per node to run
-q for desired queue to run in 

I would love to have both short and long arguments available to me in Swift ArgumentParser (long arguments would be good for newbies entering HPC jobs, short values are what everyone uses in the long run) ... but there is no other good short names for number of nodes than -**nn**, likewise -**np** is common in this field for number of proc or nprocs ( we don’t even say out loud “number of processes per node” we say “nprocs” ).  

Please consider allowing a TWO-CHARACTER (or more) custom way to have SHORT VALUE TYPE ARGUMENTS.

I tried:  .customShort( “nn”) and was scolded that “nn” is not a Character.  I do understand the -vvvv argument that is is four singles ... etc ... but not every case needs that strict unbendable convention.  

——— my coding example follows ——-

I am working on translating my python qsub script to Swift qsub script.  A supercomputer can have many different backend compute nodes, and HPC resources are allocated to users by a job scheduler.  We are using the PBS job scheduler ... a qsub command looks like:

Prompt> qsub -A ProjectID -l walltime=HH:MM:SS -l select-{nNodes}:ncpus={fixedHardwareNumberofCPUPerNode}:mpiprocs{userDesiredNumberOfProcessesPerNode}{:optionalPBSNodeFlagString=keyNumber} -q {queueToRunJob}  {optional -I flag for interactive job}

It’s a pretty long command, and it is used all the time in the world of HPC. 

My utility program prints all available qsub job types that are available for the given supercomper where the script is executing.

It prints, for example,

<pre>
Athena standard qsub:
   qsub -A {-p ProjectID} -l walltime={-w HH:MM:SS} -l select={-nn nNodes}:ncpus=32:mpiprocs={-np nProcs} -q {-q queue} -I

Athena large qsub
   qsub -A {-p ProjectID} -l walltime={-w HH:MM:SS} -l select={-nn nNodes}:ncpus=32:mpiprocs={-np nProcs}:bigmem=1  -q {-q queue}. -I 

Athena gpu qsub
    qsub -A {-p ProjectID} -l walltime={-w HH:MM:SS} -l select={-nn nNodes}:ncpus=32:mpiprocs={-np nProcs}:ngpus=1 -q {-q queue} -I  

</pre>

The user is able to replace all values in the {} above (which is just a default string, including the braces) with the flags printed inside of the braces. 

For example, executing:
<pre>
Prompt>show_qsub_commands -a MYPROJECTID -w 00:10:00 -nn 4 -np 16 -q debug 
</pre>

Causes the output to print as follows:

<pre>
Athena standard qsub:
    qsub -A MYPROJECTID -l walltime=00:10:00 -l select=4:ncpus=32:mpiprocs=16 -q debug -I

Athena large qsub
   qsub -A MYPROJECTID -l walltime=00:10:00 -l select=4:ncpus=32:mpiprocs=16:bigmem=1 -q debug -I

Athena gpu qsub
  qsub -A MYPROJECTID -l walltime=00:10:00 -l select=4:ncpus=32:mpiprocs=16:ngpus=1 -q debug -I 

</pre>

Issue 130 - Author: JensAyton
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace each paragraph
    below with the relevant details for your bug, and complete
    the steps in the checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

As [documented](https://github.com/apple/swift-argument-parser/blob/master/Documentation/02%20Arguments%2C%20Options%2C%20and%20Flags.md#alternative-positional-argument-parsing-strategies), the `. unconditionalRemaining` parsing mode includes `--` and any following tokens, when used in a root command. However, in subcommands, the `--` is skipped (but the following arguments are included).

**ArgumentParser version:** `0.0.5` and master
**Swift version:** Apple Swift version 5.1.3 (swiftlang-1100.0.282.1 clang-1100.0.33.15)

### Checklist
- [x] If possible, I've reproduced the issue using the `master` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
This code is adapted from the section [Alternative positional argument parsing strategies](https://github.com/apple/swift-argument-parser/blob/master/Documentation/02%20Arguments%2C%20Options%2C%20and%20Flags.md#alternative-positional-argument-parsing-strategies) in the documentation. It adds `parsing: .unconditionalRemaining` and also wraps the example command so it acts as a subcommand.
```swift
import ArgumentParser

struct Example: ParsableCommand {
    @Flag() var verbose: Bool
    @Argument(parsing: .unconditionalRemaining) var files: [String]

    func run() throws {
        print("Verbose: \(verbose), files: \(files)")
    }
}

struct Wrapper: ParsableCommand {

    static let configuration = CommandConfiguration(
        abstract: "yes",
        subcommands: [
            Example.self
        ]
    )
}

Wrapper.main()
```

### Expected behavior
When invoked as `wrapper example --verbose file1.swift -- file2.swift --other`, it should print:
```Verbose: true, files: ["file1.swift", "--", "file2.swift", "--other"]```

### Actual behavior
It actually prints:
```Verbose: true, files: ["file1.swift", "file2.swift", "--other"]```

Note that if we replace `Wrapper.main()` with `Example.main()` (and remove `example` from the invocation), it works as expected.

Issue 129 - Author: natecook1000
Minor documentation fix.

Issue 128 - Author: natecook1000
### Description
This adds a new `ArgumentSource` type as the projected value for `@Argument`, `@Option`, and `@Flag` types. This way, you can access the original string and location in the command-line arguments that produced a value.

```swift
struct Example: ParsableCommand {
    @Argument()
    var name: String

    @Option()
    var age: Int

    func run() {
        print("Your name is \(name) and your age is \(age).")
        if $name.source.first!.position < $age.source.first!.position {
            print("You gave your name before your age.")
        } else {
            print("You gave your age before your name.")
        }
    }
}
```

```
$ example --age 43 Blake
Your name is Blake and your age is 43.
You gave your age before your name.
```

### Detailed Design
TK

### Documentation Plan
TK

### Test Plan
TK

### Source Impact
This would be an additive change only.

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 127 - Author: mergesort
I'm using Argument Parser to build an internal tool, so the names below are a bit obscured but practically one of the use cases is for updating debug keys and values.

My desired syntax for running my app is something akin to `swift internalTool update key value`, where the key and value are positional arguments.

It currently works if I use a `[String]` for the `@Argument` like so:
```
@Argument(help: "The key and value you wish to update")
var keyAndValue: [String]
```
The downside of this is manually parsing the first and second parameters in the `run` function of my subcommand, which isn't a safe procedure.

I think a cleaner syntax would be something like this:
```
@Argument(help: "The key and value you wish to update")
var keyAndValue: KeyValuePair
```
I'm not necessarily proposing creating a `KeyValuePair` type, but to extend `ExpressibleByArgument` to have an alternative initializer that allows for a `[String]` to be used instead of a `String`.

With the status quo I would have used something like this to create my construct:
```
struct KeyValuePair: ExpressibleByArgument {
    let first: String
    let second: String
    init?(argument: String) {
        print(argument)
        self.first = // parse the string for the first argument
        self.second = // parse the string for the second argument
    }
}
```

But that would require me to run the command as `swift internalTool update "key value"` instead of `swift internalTool update key value`, which is a cleaner variant.

Happy to provide any help as needed, thanks for the fantastic library!

Issue 126 - Author: nicolassrod
--help  should return types of @Argument and @Option 
By example in README.md --help return this

```
$ repeat --help
USAGE: repeat [--count <count>] [--include-counter] <phrase>

ARGUMENTS:
  <phrase>                The phrase to repeat.

OPTIONS:
  --include-counter       Include a counter with each repetition.
  -c, --count <count>     The number of times to repeat 'phrase'.
  -h, --help              Show help for this command.
```

I propose that this be returned
```
$ repeat --help
USAGE: repeat [--count <count: Int?>] [--include-counter] <phrase: String>

ARGUMENTS:
  <phrase: String>                The phrase to repeat.

OPTIONS:
  --include-counter       Include a counter with each repetition.
  -c, --count <count: Int?>     The number of times to repeat 'phrase'.
  -h, --help              Show help for this command.
```
It's very helpful when you don't know what Type is waiting

Issue 125 - Author: vidugloeck
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace the paragraph
    below with information about your proposed feature.
-->

I'd like to build an interactive CLI, but wasn't able to setup ArgumentParser in a way that I could prompt the user after a command is run. Is that feature not supported (yet) or am I missing something?

Issue 124 - Author: natecook1000
As pointed out in #120, there isn't any documentation describing how to manually create instances of `ParsableArguments` or `ParsableCommand` types, and the error message when using one created from calling the default init (e.g. `let command = MyCommand()`) indicates that the only way to create one is through parsing.

Instead, the [Manual Parsing and Testing](https://github.com/apple/swift-argument-parser/blob/master/Documentation/06%20Manual%20Parsing%20and%20Testing.md) guide should cover adding a memberwise init as a way to create testable instances of the type, and the error should be updated to indicate that possibility.

Issue 123 - Author: natecook1000
### Description
This adds support for generating shell completion scripts for tools built using `ArgumentParser`.

### Detailed Design
This adds a `CompletionKind` struct that you can specify when declaring an `@Option` property:

```swift
struct CompletionKind {
  static var `default`: CompletionKind
  static func file(extensions: [String] = []) -> CompletionKind
  static var directory: CompletionKind
  static func list([String]) -> CompletionKind
  static func shellCommand(_ command: String) -> CompletionKind
  static func custom((String) -> [String]) -> CompletionKind
}
```

Types that conform to `ExpressibleByArgument` can also provide a `static var defaultCompletionKind: CompletionKind` to provide the completion kind when it's omitted from the property wrapper declaration.

To generate completion scripts, you use the `--generate-completions` option on your command-line tool:

```
$ example --generate-completion-script
(generated completion script for autodetected shell)
$ example --generate-completion-script zsh
(generated completion script for zsh)
```

You can generate completion scripts programmatically by calling the `completionScript(for:)` method on the root `ParsableCommand` type for a command.

### Documentation Plan
Symbol documentation for all of the new additions, along with a new guide specifically about using, customizing, and installing completion scripts.

### Test Plan
I've added unit tests for generating completion scripts with different completion parameters, as well as an integration test for the `math` command. I've also been testing this feature in the context of [SwiftPM adoption of ArgumentParser](https://github.com/apple/swift-package-manager/pull/2653). Unfortunately, we don't have an automated way to test that the completion scripts actually work properly, so that verification has been manual.

### Source Impact
No source impact for existing code.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 122 - Author: iainsmith
### Description
As described in #120, there are use cases where you want to parse a ParsableArgument/PasrsableCommand without calling your custom `validate()` methods on your command and subcommand. Typically testing, but other complex scenarios are also conceivable.

### Detailed Design
Update parse & parseAsRoot to take `skipCustomValidation: Bool = false` parameter which is passed through to the Decoders where necessary. Added 2 tests that build on the existing test scenarios.

```swift
extension ParsableCommand {
  public static func parseAsRoot(
    _ arguments: [String]? = nil,
    skipCustomValidation: Bool = false
  ) throws -> ParsableCommand { }
}

extension ParsableArguments {
  public static func parse(
    _ arguments: [String]? = nil,
    skipCustomValidation: Bool = false
  ) 
}
```

### Alternative parameter names

* `skippingCustomValidation`
* `skipValidation`

Let me know if you'd like me to push a change for this.

### Documentation Plan
Added a brief paragraph to the docs

### Test Plan
2 new tests. Tested locally on 10.15 & against swift:latest docker image.

### Source Impact
Non breaking public API addition with default argument.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary

@natecook1000, is there anything obviously missing from the above?

Issue 121 - Author: compnerd
Windows does not have a `EX_USAGE`, use `ERROR_BAD_ARGUMENTS` instead.

<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Replace this paragraph with a description of your changes and rationale. Provide links to an existing issue or external references/discussions, if appropriate.

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [ ] I've followed the code style of the rest of the project
- [ ] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 120 - Author: iainsmith
Hi All. 

I think we can make it easier to write unit tests for ParsableArgument conforming types.

Over the weekend I ported [swift-docker](https://github.com/iainsmith/swift-docker) to use ArgumentParser 0.0.5. I've used computed properties on my `ParsableArguments` options as these are shared by many commands. To write unit tests that didn't trigger the filesystem validation methods. I needed to add a hidden `skipValidation: Bool` flag to the options. See the example below.

I think we could avoid this by providing a public `parseWithoutValidation() -> ParsableArguments` method that skips the call `public func validate() throws`. What do people think. Is this something the library should provide out of the box (even if just for testing)?

## Update

When implementing this in #122 I updated the `parse` and `parseAsRoot` methods to take an optional `skipCustomValidation: Bool = false` parameter.
 
---

## Minimal example

```swift
public struct CLIOptions: ParsableArguments {
  @Option(name: .shortAndLong, default: "latest", help: "swift tag found at https://hub.docker.com/_/swift \n  e.g latest, 5.2, 5.2.2-slim")
  var swift: String

  @Option()
  var image: String?

  @Flag(name: .customLong("skip-validation"), help: .hidden)
  var skipValidation: Bool

  var baseImage: DockerTag {
    DockerTag(version: swift, image: image)!
  }

  public func validate() throws {
    if skipValidation { return }
    // Some validation logic here that might depend on the current 
    // working directory / permissions / networking etc.
  }
}

extension CLIOptions {
  static func parseWithoutValidation(_ args: [String]? = nil) throws -> CLIOptions {
    let fullArgs = args ?? []
    return try parse(fullArgs + ["--skip-validation"])
  }
}

class CLIOptionTests: XCTestCase {
  func testDefaultDockerTag() throws {
    let options = try CLIOptions.parseWithoutValidation()
    XCTAssertEqual(options.baseImage, DockerTag.officialSwiftVersion("latest"))
  }
}

```

Issue 119 - Author: rjstelling
This is a very short PR that came out of some changes made in #115. Because it is an API change is was suggested this become a PR in its own right.

However, looking at the code I wanted to make sure the motivations are correct and consider some alternatives. 

### Do we need this change?
`ValidationError` conforms to `CustomStringConvertible`, `description` is `public` and it vends `message`. So client code can read the `message` value without this change.

### Alternative 1
Remove `message` value entirely and use `description`.

```swift
public struct ValidationError: Error, CustomStringConvertible {
  public internal(set) var description: String
  
  /// Creates a new validation error with the given message.
  public init(_ message: String) {
    self.description = message
  }
}
```

### Alternative 2
`message` should be `private(set)`. No library code (currently) changes the `message` string, and its internal by default.

```swift
public struct ValidationError: Error, CustomStringConvertible {
  public private(set) var message: String
  
  /// Creates a new validation error with the given message.
  public init(_ message: String) {
    self.message = message
  }
  
  public var description: String {
    message
  }
}
```

### Alternative 3

If we are making `message` `private` these is no need for it to be a `var`, so change it to a public `let`.

```swift
public struct ValidationError: Error, CustomStringConvertible {
  public let message: String
  
  /// Creates a new validation error with the given message.
  public init(_ message: String) {
    self.message = message
  }
  
  public var description: String {
    message
  }
}
```

### Checklist
- [x] I've updated the documentation if necessary
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- ~~I've added at least one test that validates that my change is working, if appropriate~~


Issue 118 - Author: toddthomas
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

### Abstract
Adds `ParsableArgumentsUniqueNamesValidator`, which conforms to `ParsableArgumentsValidator` and implements the validation requested in https://github.com/apple/swift-argument-parser/issues/112: ensuring that argument names aren't duplicated in a type conforming to `ParsableArguments` or `ParsableCommand`.

### Problem
Custom names can be used to give two or more options or flags the same name. For example:
```swift
import ArgumentParser

struct TwoOfTheSameName: ParsableCommand {
    @Option()
    var foo: String

    @Option(name: .customLong("foo"))
    var notActuallyFoo: String

    func run() throws {
        print("foo: \(foo)")
        print("notActuallyFoo: \(notActuallyFoo)")
    }
}

TwoOfTheSameName.main(["--foo thing"])
```
gives this output in `master`:
```
Error: Missing expected argument '--foo <foo>'
Usage: two-of-the-same-name --foo <foo> --foo <foo>
Program ended with exit code: 64
```

### Proposed solution
With the changes in this PR, the output is now
```
Fatal error: Validation failed for `TwoOfTheSameName`:
- Multiple (2) `Option` or `Flag` arguments are named "foo".
: file /Users/tthomas/Library/Developer/Xcode/DerivedData/argument-uniqueness-test-fuopasnbytbtladimilqpbwgllpu/SourcePackages/checkouts/swift-argument-parser/Sources/ArgumentParser/Parsable Types/ParsableArguments.swift, line 196
```
(The above is actually printed twice, for reasons I haven't yet investigated, but that also happens for the validators currently in `master`.)

### Discussion
I used the existing `ParsableArguments` validation implementation, but that means the reflection code used to obtain a `ParsableArguments`'s `ArgumentSet` is now duplicated four times in the code. I'd like to try a refactor to DRY that up if that's desirable.
 
### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 117 - Author: natecook1000
Preparing to tag the 0.0.5 release.

Issue 116 - Author: natecook1000


Issue 115 - Author: rjstelling
> This PR is an improved version after some feedback on #110. However, I wanted to to make sure this is still the right direction, and I'm happy for more feedback, especially because this PR is more substantial. 

## Rational

If an argument property supplies a `transform` closure, like so,

```swift
@Option(help: "Some string input please.", transform: { try convert($0) })
var input: String
```

...and if the function `convert(...)` throws, this error should be printed to standard error, the same way throwing from `run()` or `validate()` does.

I raised this issue on the [Swift Forums](https://forums.swift.org/t/throwing-from-a-transform-closure/35137) and it was suggested by @natecook1000 this was a bug.

## Changes

### tl;dr

Improves default error messages when `transform` closures throw errors. Adds the ability to print custom error messages when `transform` closures throw. 

### Detail
1. Added a file called TransformEndToEndTests.swift that test simple cases of using `transform` closures with `@Option`and `@Argument` properties.
2. Added error message tests for custom and default errors.
3. In the `init(...)` calls of `Option` and `Argument` any errors thrown by the `transform` closure care caught and converted into an `ParserError.unableToParseValue`
4. Added a `customMessage` associated value to `ParserError.unableToParseValue`, this is a `String` optional. When this is set the default error message is suppressed and `customMessage` is used.
5. Added a public protocol called `CustomParserErrorConvertible`. Errors can conform to this to provide there own custom messages. Added conformance to `ValidationError`.

## Before merging

1. Discuss the usage of `CustomParserErrorConvertible`. The only other alternative I considered was using `localizedDescription`. But this would require another mechanism to use the default error message.
3. Update documentation 

### Checklist

- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 114 - Author: natecook1000
Minor update.

Issue 113 - Author: shahmishal
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Replace this paragraph with a description of your changes and rationale. Provide links to an existing issue or external references/discussions, if appropriate.

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [ ] I've followed the code style of the rest of the project
- [ ] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 112 - Author: natecook1000
It's possible to define `ParsableCommand` and `ParsableArguments` type with colliding option and/or flag names. This should be an error that's surfaced by a `ParsableArgumentsValidator` type. For example, running this program should fail:

```swift
struct TwoOfTheSameName: ParsableCommand {
    @Option()
    var foo: String
    
    @Option(name: .customLong("foo"))
    var notActuallyFoo: String
}

TwoOfTheSameName.main()
```

Note that each option and flag can have more than one name. We'll eventually need to validate this same problem through the command hierarchy, but validating individual commands is a good first step.

Issue 111 - Author: sgl0v
The ArgumentParser dependency should be specified using the `target` block, not `product`.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 110 - Author: rjstelling
> This PR is probably incomplete, I just wanted some feedback that I was heading in the right direction before I spent any more time on it.

## Rational

If an argument property supplies a `transform` closure, like so,

```swift
@Option(help: "Some string input please.", transform: { try convert($0) })
var input: String
```

...and if the function `convert(...)` throws, this error should be printed to standard error, the same way throwing from `run()` or `validate()` does.

I raised this issue on the [Swift Forums](https://forums.swift.org/t/throwing-from-a-transform-closure/35137) and it was suggested by @natecook1000 this was a bug.

## Changes

1. I added a file called TransformEndToEndTests.swift that test simple cases of using `transform` closures with `@Option` properties. As far as I could tell there were no tests for `transform` closures.
2. I made a change to `parse(arguments: ...)` to catch any `ValidationError` and wrap it in a `ParserError.userValidationError`. The `ValidationError` is then printed as expected.
3. I updated the fail test to check for the `ValidationError` message.

## Before merging

1. Add tests (and implementation?) for `@Argument`
2. Discuss what errors can be thrown from a `transform` closure. Just `ValidationError` or should it support `CleanExit`, `ExitCode`?
3. Update documentation 

### Checklist

- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 109 - Author: danieleggert
### Description

This allows reading values for `@Option` and `Flag` from environment variables.

I started work on this before this repo was open sourced, and it was requested as #4

### Detailed Design

Flags can now be specified as
```swift
@Flag(name: [.environment, .long])
```
and similarly options as
```swift
@Option(name: [.environment, .long])
```

There are two new `NameSpecification` to support this:
```swift
    /// Read the value from an environment variable. The name is using the `THE_QUICK_BROWN_FOX` style.
    case environment
    
    /// Read the value from an environment variable with the specified name/
    case customEnvironment(String)
```

As one would expect, `.environment` picks a auto-genreated name based on on the flag / option name, similar to how for command line names are generated. But for environment variables, the generated strings are using the `THE_QUICK_BROWN_FOX` style.

TODO: I’d like to prefix the executable name to the auto-generated environment variable names. Need to funnel that through.

#### Example

If we have
```swift
enum Shape: String, CaseIterable {
  case round
  case square
  case oblong
}

struct Options: ParsableArguments {
  @Flag(name: [.environment, .long])
  var shape: Shape?
}
```
we can set an environment variable `ROUND` to make `shape = .round` — similar to the command line argument `--round`.

For options if we have
```swift
struct Options: ParsableArguments {
  @Option(name: [.environment, .long]) var name: String?
}
```
we can set the environment variable `NAME` to `Daniel`, and `name = "Daniel` — similar to the command line arguments `--name Daniel`.

#### Details

There’s a new `EnvironmentName` type that’s a `RawRepresentable` wrapping a `String` to give some type-safety. Environment variables get mapped to a `[EnvironmentName: String]`.

For flags and options that are exclusive, we still allow the command line to override any environment variables.

There’s a new `OriginalInput` type that’s using in a few places where we used to have a `[String]`. This would be the array of arguments passed to the executable. Now it’s type safe and holds both this array and the environment variables that are set. This cleans up the code in a few places.

The `InputOrigin` now can both represent an index into the arguments array or an environment variable name.

### Documentation Plan

TODO:
- [ ] update Documentation
- [ ] update the guide

### Test Plan

Updated the unit tests as applicable.

### Source Impact

Purely additional. Should not require any source changes by users.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary
- [ ] Added code to prefix the executable name to environment variable names


Issue 108 - Author: fblondiau
There is no unanimous agreement on the _right_ way to treat numbers while converting to snake cases.

`”PDF2Text".convertedToSnakeCase` could have been giving `pdf2text`, `pdf2_text` or `pdf_2_text`.

Today, the second option is used but, arguably, according to the development tools on the Mac platform, the last option seems to be more natural.

Indeed, when increasing, sub-word by sub-word, the selection of this camelCased formatted identifier (1), Xcode will detect 3 parts : `PDF`, `2` and `Text` — hence this modification proposal.

(1) check by placing the caret at the beginning of the identifier and, holding down the alternate and shift keys simultaneously, press the right arrow key.

<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Replace this paragraph with a description of your changes and rationale. Provide links to an existing issue or external references/discussions, if appropriate.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 107 - Author: fdiaz
There's currently no way that I've found to have a default option when an `@Option` is an array

```swift
@Option(parsing: .upToNextOption)
var foo: [String]
```

I'd like to do something like:

```swift
@Option(default: ["someValue"], parsing: .upToNextOption)
var foo: [String]
```

So even if this option is not set, we still get this information.

Issue 106 - Author: rsalesas
It would be good to be able to specify that an option should exclude catching trailing arguments. For example, it's quite common to have an option like:

`--option a b c`

but currently the only way to do this is to specify it should capture until the next `--` option is encountered. That means that if you have a trailing argument, like this:

`program command --option a b c filename.txt`

The trailing argument `filename.txt` will be captured by the option. This would be easy to implement by allowing any trailing arguments to capture "first", leaving the option to capture the remainder. In any case, if there are insufficient parameters, it will result in an error.

Issue 105 - Author: kennyyork
Its slightly annoying to add properties to a ParsableArgument that are not arguments.  For example:

```
struct Command : ParsableCommand {
    var someValue: String
   
    @Flag()
    var myFlag: Bool

    private enum CodingKeys: CodingKey {
      case myFlag
    }
  }
```

A use case I have for this is that I would like to have the `validate()` command create some objects or setup some state and store it on the Command object, but doing so requires adding the `CodingKeys` enum.

Would it make sense to add something like `@Ignored` or `@Excluded` that conform to `Decodable` to make it so that `CodingKeys` does not have to be declared?  


Issue 104 - Author: kennyyork
This change calls validate on every ParsableCommand in the command stack, instead of just the leaf command to fix issue #103 

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 103 - Author: kennyyork
When a subcommand is parsed and executed, its parent command arguments are parsed but `validate()` is never called.  It seems odd that the arguments are required for the command to be accepted, but are not validated.  

**ArgumentParser version:** `master`
**Swift version:** Apple Swift version 5.2

### Checklist
- [x] If possible, I've reproduced the issue using the `master` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
```
private struct BaseCommand: ParsableCommand {
  static var configuration = CommandConfiguration(
    commandName: "base",
    subcommands: [SubCommand.self]
  )

  @Option()
  var baseFlag: String

  mutating func validate() throws {
    throw HelpRequested
  }
}

extension BaseCommand {
  struct SubCommand : ParsableCommand {
    static var configuration = CommandConfiguration(commandName: "sub")

    @Flag()
    var subFlag: Bool

    mutating func validate() throws {
      print("Validated SubCommand")
    }
  }
}
```

### Expected behavior
Because `--base-flag` is required for the command to run, I would expect at the least that `BaseCommand.validate()` be called. 

### Actual behavior
`BaseCommand.validate()` is never called when invoking SubCommand


Issue 102 - Author: natecook1000
### Description
Adds built-in support for responding to a `--version` flag. This flag is only valid when a command provides a `version:` parameter in its configuration. Fixes #25.

### Detailed Design
If a command in the tree has specified a version, the `--version` flag is checked for only after evaluating any explicitly defined arguments. This allows commands to define their own `--version` flags or options and not have them be overridden by the auto-generated version.

Nested commands inherit their version from their parent commands, and can override their parent by providing their own version string.

`version` is added to the `CommandConfiguration` type and to the initializer:

```swift
  /// Creates the configuration for a command.
  ///
  /// - Parameters:
  ///   - commandName: The name of the command to use on the command line. If
  ///     `commandName` is `nil`, the command name is derived by converting
  ///     the name of the command type to hyphen-separated lowercase words.
  ///   - abstract: A one-line description of the command.
  ///   - discussion: A longer description of the command.
  ///   - version: The version number for this command. When you provide a
  ///     non-empty string, the arguemnt parser prints it if the user provides
  ///     a `--version` flag.
  ///   - shouldDisplay: A Boolean value indicating whether the command
  ///     should be shown in the extended help display.
  ///   - subcommands: An array of the types that define subcommands for the
  ///     command.
  ///   - defaultSubcommand: The default command type to run if no subcommand
  ///     is given.
  ///   - helpNames: The flag names to use for requesting help, simulating
  ///     a Boolean property named `help`.
  public init(
    commandName: String? = nil,
    abstract: String = "",
    discussion: String = "",
    version: String = "",
    shouldDisplay: Bool = true,
    subcommands: [ParsableCommand.Type] = [],
    defaultSubcommand: ParsableCommand.Type? = nil,
    helpNames: NameSpecification = [.short, .long]
  )
```

### Documentation Plan
How has the new feature been documented? Have the relevant portions of the guide been updated in addition to symbol-level documentation?

### Test Plan
- Unit tests for generating the version string.
- End-to-end tests to verify that the version is being rendered as the correct value when defined, and that commands that explicitly define `--version` get that behavior.
- Example tests with versions defined in `Math`.

### Source Impact
Because the `version:` parameter is defaulted, this has no source impact. In addition, since there's no change in behavior unless the command defines a version, there's no impact on existing tools' behavior.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary

Issue 101 - Author: YuAo
### Abstract

Continue restructuring the `ParsableArguments` validation layer. (Previous discussions: #91)

### Detail

- Move the "positional argument following an array of positional arguments" check to a new struct `PositionalArgumentsValidator`.

- Make `ParsableArguments._validation` throw a combination of validation errors, and add the proper error description.

- Add tests for `PositionalArgumentsValidator`

So a `ParsableArguments` with both coding key error and positional arguments error is now reported in the following form:
```
Fatal error: Validation failed for `Repeat`:
- Can't have a positional argument `phrase` following an array of positional arguments `items`.
- Arguments `includeCounter`,`items` are defined without corresponding `CodingKey`s.
: file /Users/***/Developer/swift-argument-parser/Sources/ArgumentParser/Parsable Types/ParsableArguments.swift, line 196
```


### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 100 - Author: pvieito
Adding a positional argument with `.unconditionalRemaining` strategy disables the help flag.

**ArgumentParser version:** `0.0.4` and `master` branch.
**Swift version:** Apple Swift version 5.2 (swiftlang-1103.0.32.1 clang-1103.0.32.29)
### Checklist
- [x] If possible, I've reproduced the issue using the `master` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Examples

- Example 1:

```swift
struct ExampleTool: ParsableCommand {
    @Argument(parsing: .unconditionalRemaining)
    var processArguments: [String]
    
    func run() throws {
        print(self.processArguments)
    }
}

ExampleTool.main()
```

```bash
$ example-tool --help
["--help"]
```

- Example 2:

```swift
struct ExampleTool: ParsableCommand {
    static var configuration: CommandConfiguration {
        return CommandConfiguration(helpNames: .customLong("x-help"))
    }

    @Argument(parsing: .unconditionalRemaining)
    var processArguments: [String]
    
    func run() throws {
        print(self.processArguments)
    }
}

ExampleTool.main()
```

```bash
$ example-tool --x-help
["--x-help"]
```

### Expected behavior
It should show the command help.



Issue 99 - Author: fblondiau
Properties wrapped by ``@Option`` with a ``.implicit`` name specification would be handled like those with ``@Argument`` and would allow command line tools like this one (inspired from sed).

```swift
import ArgumentParser

struct MySed: ParsableCommand {

//  my-sed 's/hello/world/' input.txt
//  my-sed -e 's/hello/world/' input.txt
//  my-sed --expression='s/hello/world/' input.txt

    @Option(name: [.implicit, .short, .long])
    var expression: [String]

    @Argument()
    var input: [String]

    func run() throws {
        print("expression: \(expression)")
        print("input: \(input)")
    }

}

MySed.main()
```

Help would show properties wrapped by ``@Option`` with an ``.implicit`` name specification into brackets
```
[[--expression] <expression>]
```

They would, like ``@Argument``, be order dependent and face identical limitations when used on array properties.

Only one ``.implicit`` would be allowed by property (even on array properties)... in order to let simple in/out command line tools like

```
inout [-i] <inputFile> [-o] <outputFile>
```
process two files without ambiguity.


Issue 98 - Author: kukushechkin
Fix for the https://github.com/apple/swift-argument-parser/issues/97.



Issue 97 - Author: rsalesas
I added the package to a new Swift Xcode project with rules of `0.0.3 to Major`, and on build I get an error of:

`Type of expression is ambiguous without more context`

in `parsePositionalValues` at this line:

`let extraValues: [(InputOrigin, String)] = argumentStack.map(\.0).map {`

Issue 96 - Author: natecook1000
We were incorrectly skipping over dash-prefixed inputs when looking for the next
subcommand. This means that input like `command sub1 --foo sub2` would match the
sub1 and sub2 subcommands, even if `--foo` wasn't defined by sub1. This manifested
in issues where a value expected by `--foo` would be eaten by the subcommand matcher.

Note that this changes a couple test fixtures where we were incorrectly specifying inputs.

Fixes #92.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 95 - Author: natecook1000
Because of the way we split out single-dash arguments into both the whole string and each individual character, we were capturing single-dash arguments multiple times. This fixes #88.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 94 - Author: griffin-stewie
- [x] I've completed this task

This PR fixes #87.

## Plan

Simply we can add `defaultValueDescription` in `ExpressibleByArgument` protocol

```
/// A type that can be expressed as a command-line argument.
public protocol ExpressibleByArgument {
  /// Creates a new instance of this type from a command-line-specified
  /// argument.
  init?(argument: String)

  /// Add this ↓
  var defaultValueDescription: String { get }
}
```

## Source Impact

Default behavior is given by default implementation declared in `ExpressibleByArgument` as Protocol Extensions.  Only users who want to customize need to override `defaultValueDescription`.

## Related Forum Thread

[How can I change the default value string displayed in Help? \- Related Projects / ArgumentParser \- Swift Forums](https://forums.swift.org/t/how-can-i-change-the-default-value-string-displayed-in-help/34527/3)

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 93 - Author: azamsharp
In the docs it says to run the tool using the following: 
`random 20 `

But in reality you have to type `swift run random 20` . Am I missing something or the docs assumed that I am in a special folder where I can just execute the executable.

If that is the case then the docs needs to be updated to reflect that. My students had a very hard time understanding the instructions in the doc, specially with running the executable. 

Issue 92 - Author: allevato
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace each paragraph
    below with the relevant details for your bug, and complete
    the steps in the checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Default subcommand argument handling doesn't work as expected when there is an `@Option` whose value is the same as another subcommand name at the same level and the option is passed using space-separated syntax.

**ArgumentParser version:** `master` branch
**Swift version:** Apple Swift version 5.1.2 (swiftlang-1100.0.278 clang-1100.0.33.9) Target: x86_64-apple-darwin19.2.0

### Checklist
- [x] If possible, I've reproduced the issue using the `master` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce

Originally discovered by https://github.com/apple/swift-format/pull/161, isolated repro case provided below:

```
git clone https://github.com/allevato/swift-argument-parser-default-subcommand-repro.git
cd swift-argument-parser-default-subcommand-repro
swift build
.build/debug/swift-argument-parser-default-subcommand-repro --mode=foo
.build/debug/swift-argument-parser-default-subcommand-repro --mode foo
.build/debug/swift-argument-parser-default-subcommand-repro -m foo
```

### Expected behavior

Expected output:
```
FooCommand executed
FooCommand executed
FooCommand executed
```

### Actual behavior

Actual output:
```
FooCommand executed
Error: Unknown option '--mode'
Usage: main foo
Error: Unknown option '-m'
Usage: main foo
```

### Additional info

Renaming or changing the raw values of the `Mode` enum cases so that they differ from the subcommand names causes the bug to go away (at the expense of changing the CLI). For example, changing the repro code to this:

```swift
  enum Mode: String, CaseIterable, ExpressibleByArgument {
    case foo = "foo_"
    case bar = "bar_"
  }
```

and then executing

```
.build/debug/swift-argument-parser-default-subcommand-repro -m foo_
```

produces the expected output:

```
FooCommand executed
```

Issue 91 - Author: YuAo
This PR add a validator to ensure each flag, option, argument of a `ParsableCommand` has the corresponding coding key.

For the following command:
```
struct Repeat: ParsableCommand {
    @Option(help: "The number of times to repeat 'phrase'.")
    var count: Int?

    @Flag(help: "Include a counter with each repetition.")
    var includeCounter: Bool

    @Argument(help: "The phrase to repeat.")
    var phrase: String
    
    enum CodingKeys: String, CodingKey {
        case includeCounter
        case phrase
        case count
    }

    func run() throws { /* ... */ }
}
```

### Current behavior

- If the command author forget to add the `includeCounter` to the `CodingKeys`. The command failed with fatal error: 

    `Can't read a value from a parsable argument definition.`

- If the command author forget to add the `count` key and the user supplies a `--count` option. The command failed with message: 

    `Error: Unknown option '--count'. Did you mean '--count'?` 🤔

- If the command author forget to add the `phrase` key. The command failed with message: 
    
    `Error: Unexpected argument 'Hello'`

### Proposed behavior

None of the current behaviors seems appropriate. This PR proposed a validator to ensure all parsable arguments have corresponding coding keys. If the coding key of a parsable argument is missing the command parser reports fatal error: `Can't find the coding key for a parsable argument.`

### Detail

It looks like there's no way to do the validation at compile time based on the current parser design. Create a runtime check is not straight forward too. 

The `ArgumentSet` uses reflection to get the names of the arguments, however we can't get a list of CodingKeys so we can't see if the `CodingKeys` contains all of the arguments.

The solution proposed by this PR uses a special `Decoder` to get the type of `CodingKey` then try to create instances of `CodingKey` using given argument names. If `CodingKey` can be created from all the argument names we know that the command passes the validation.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 90 - Author: azamsharp
Can you add a real example with Package.swift file and how to setup Package.swift file for ArgumentParser? 

Here is my Package.swift file: 
```

// swift-tools-version:4.0
import PackageDescription

let package = Package(
    name: "random",
    dependencies: [
        .package(url: "https://github.com/apple/swift-argument-parser", from: "0.0.1"),
    ],
    targets: [
        .target(name: "random", dependencies: []),
    ]
)

```

But what should I add for dependencies? 

Issue 89 - Author: YuAo


Issue 88 - Author: glessard
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace each paragraph
    below with the relevant details for your bug, and complete
    the steps in the checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

When using an `@Argument` that parses to a `[String]` using the `.unconditionalRemaining` parsing strategy, command-line arguments that start with "--", "/", "+" and such behave as expected. However an argument that starts with a single dash ("-") appears to be appended to the array as many times as it has characters &mdash; as long as the 2nd character isn't also "-".

**ArgumentParser version:**
`81b8064dbd99cf75a4734fa64efe5e680d0b4d9c`
**Swift version:** 
Apple Swift version 5.2 (swiftlang-1103.0.30 clang-1103.0.30)
Target: x86_64-apple-darwin19.3.0

### Checklist
- [x] If possible, I've reproduced the issue using the `master` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
Using this simple program:
```
import ArgumentParser
public struct Options: ParsableCommand {
  @Argument(parsing: .unconditionalRemaining) public var arguments: [String]
}

let options = Options.parseOrExit()
print(options.arguments)
```
```
$ swift run options
[]
$ swift run options blah -a
["blah", "-a"]
$ swift run options blah -a -bb -ccc --dddd
```

### Expected behavior
For the third command from above, I expected the output to be:
`["blah", "-a", "-bb", "-ccc", "--dddd"]`

### Actual behavior
The output is actually:
`["blah", "-a", "-bb", "-bb", "-bb", "-ccc", "-ccc", "-ccc", "-ccc", "--dddd"]`


Issue 87 - Author: griffin-stewie
## Sample code

Here is my sample code:

```swift
extension URL: ExpressibleByArgument {
    public init?(argument: String) {
        guard let url = URL(string: argument) else {
            return nil
        }
        self = url
    }
}
```

```swift
struct MySample: ParsableCommand {
    @Option(default: URL(string: FileManager.default.currentDirectoryPath)!, help: "Directory")
    var directory: URL
}
```

Produces output:

```
USAGE: sample [--directory <directory>]

OPTIONS:
  -v, --version           Print version 
  --directory <directory> Directory (default:
                          /Users/stewie/Library/Developer/Xcode/DerivedData/sample-blghzaivmncuwahbbafbmsweltpy/Build/Products/Debug)
  -h, --help              Show help information.
```

### Expected behavior

I would expect the following

```
  --directory <directory> Directory (default: current directory)
```

### Actual behavior

I get:

```
  --directory <directory> Directory (default:
                          /Users/stewie/Library/Developer/Xcode/DerivedData/sample-blghza
```

Current directory is common default value for file path like `ls` command. but 12941604a prints actual full path on help. Since `defaultValueDescription` is implemented 12941604a and it is not a protocol requirement.

## Plan

Simply we can add `defaultValueDescription` in `ExpressibleByArgument` protocol

```
/// A type that can be expressed as a command-line argument.
public protocol ExpressibleByArgument {
  /// Creates a new instance of this type from a command-line-specified
  /// argument.
  init?(argument: String)

  /// Add this ↓
  var defaultValueDescription: String { get }
}
```

## Source Impact

Default behavior is given by default implementation declared in `ExpressibleByArgument` as Protocol Extensions.  Only users who want to customize need to override `defaultValueDescription`.

## Environment

ArgumentParser: 12941604a

## Related Forum Thread

[How can I change the default value string displayed in Help? \- Related Projects / ArgumentParser \- Swift Forums](https://forums.swift.org/t/how-can-i-change-the-default-value-string-displayed-in-help/34527/3)

Issue 86 - Author: YuAo
When there's a subcommand with a long name and empty abstract, the help is generated with an extra new line below the command name.

For example:
```
USAGE: h <subcommand>

    OPTIONS:
      -h, --help              Show help information.

    SUBCOMMANDS:
      command-a
      command-with-very-long-name

      short-command           Test short command name.

```

This patch removes the extra new line in help.

```
USAGE: h <subcommand>

    OPTIONS:
      -h, --help              Show help information.

    SUBCOMMANDS:
      command-a
      command-with-very-long-name
      short-command           Test short command name.
```

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 85 - Author: weissi
when building as you would normally, it just errors:

```
$ docker run -it --rm --privileged -w /Users/johannes/devel/swift-argument-parser -v /Users/johannes/devel/swift-argument-parser:/Users/johannes/devel/swift-argument-parser swiftlang/swift:nightly-5.2-bionic swift build -c release 
error: missing LinuxMain.swift file in the Tests directory
```

I'd argue there should be a `LinuxMain.swift` file in the `Tests/` directory containing just

```swift
#error("Please test with `swift test --enable-test-disovery`")
```

to get a good error message.

Issue 84 - Author: weissi
5.1.5
```
$ docker run -it --rm --privileged -w /Users/johannes/devel/swift-argument-parser -v /Users/johannes/devel/swift-argument-parser:/Users/johannes/devel/swift-argument-parser swift:5.1.5 swift build -c release --enable-test-discovery
/Users/johannes/devel/swift-argument-parser/Sources/ArgumentParserTestHelpers/TestHelpers.swift:154:13: warning: 'launchPath' is deprecated: renamed to 'executableURL'
    process.launchPath = commandURL.path
            ^
/Users/johannes/devel/swift-argument-parser/Sources/ArgumentParserTestHelpers/TestHelpers.swift:154:13: note: use 'executableURL' instead
    process.launchPath = commandURL.path
            ^~~~~~~~~~
            executableURL
/Users/johannes/devel/swift-argument-parser/Sources/ArgumentParserTestHelpers/TestHelpers.swift:162:13: warning: 'launch()' is deprecated: renamed to 'run'
    process.launch()
            ^
/Users/johannes/devel/swift-argument-parser/Sources/ArgumentParserTestHelpers/TestHelpers.swift:162:13: note: use 'run' instead
    process.launch()
            ^~~~~~
            run
[8/8] Linking math
```

5.2

```
$ docker run -it --rm --privileged -w /Users/johannes/devel/swift-argument-parser -v /Users/johannes/devel/swift-argument-parser:/Users/johannes/devel/swift-argument-parser swiftlang/swift:nightly-5.2-bionic swift build -c release --enable-test-discovery
/Users/johannes/devel/swift-argument-parser/Sources/ArgumentParserTestHelpers/TestHelpers.swift:154:13: warning: 'launchPath' is deprecated: renamed to 'executableURL'
    process.launchPath = commandURL.path
            ^
/Users/johannes/devel/swift-argument-parser/Sources/ArgumentParserTestHelpers/TestHelpers.swift:154:13: note: use 'executableURL' instead
    process.launchPath = commandURL.path
            ^~~~~~~~~~
            executableURL
/Users/johannes/devel/swift-argument-parser/Sources/ArgumentParserTestHelpers/TestHelpers.swift:162:13: warning: 'launch()' is deprecated: renamed to 'run'
    process.launch()
            ^
/Users/johannes/devel/swift-argument-parser/Sources/ArgumentParserTestHelpers/TestHelpers.swift:162:13: note: use 'run' instead
    process.launch()
            ^~~~~~
            run
[8/8] Linking math
```

Issue 83 - Author: YuAo
### Description
PR for #82 

### Detailed Design
```swift
import Foundation
extension URL: ExpressibleByArgument {}
```

### Documentation Plan
The code is self-explanatory. Do we need to point out this conformance in one of the documentation?

### Test Plan
Added `URLArgumentTests`.

### Source Impact
There is no change to existing API. Additive change only.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary

Issue 82 - Author: YuAo
There are times a command line tool needs a local file URL or a remote URL as an argument.

For example `--build-path`, `--package-path` of the swift-package command. Of course one can use strings instead of URLs. But using URLs can benefit from validation, relative path handling, convenient path operations (like `appendingPathComponent`), etc.

A simple implementation would be something like

```
extension URL: ExpressibleByArgument {
  public init?(argument: String) {
    if let url = URL(string: argument), url.scheme != nil {
      self.init(string: argument)
    } else {
      // Assuming it is a file url.
      self.init(fileURLWithPath: argument)
    }
  }
}
```

`https://github.com` is parsed as a remote URL.
`.`, `folder`, `../`, `.build` are parsed as against current directory.
`file:///System`,  `file:///C:/Windows/` are parsed as file URL.

Things I'm not sure:
- ArgumentParser seems to use `@_implementationOnly import` for `Foundation`. This feature will break the `@_implementationOnly import` because it involves the `URL` type from `Foundation`. What's the story of the `@_implementationOnly import`?
- File paths on the Windows platform.

I've created a draft PR for this.

Issue 81 - Author: YuAo
- Simplified the implementation of `String.convertedToSnakeCase(separator:)` method. (Maybe with some performance improvements as well.)
- Added related tests.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 80 - Author: fappelman
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace each paragraph
    below with the relevant details for your bug, and complete
    the steps in the checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

I have completed an application that compiles and works. When I compile for release I get linker errors about `invalid redeclaration`.

**ArgumentParser version:** 0.0.2
**Swift version:** Apple Swift version 5.1.3 (swiftlang-1100.0.282.1 clang-1100.0.33.15)
Target: x86_64-apple-darwin19.3.0

### Checklist
- [X] If possible, I've reproduced the issue using the `master` branch of this package
- [X] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
The code needs to be spread over **two** files:

`main.swift`:
```
import Foundation
import ArgumentParser

struct MainCommand: ParsableCommand {
    static var configuration = CommandConfiguration(
        abstract: "An application to prove a bug",
        subcommands: [
            SubCommand.self
        ]
    )
}

extension MainCommand {
    struct GlobalOptions: ParsableCommand {
        @Flag(help: "Debug mode") var debug: Bool
    }
}

MainCommand.main()
```

`File2.swift`:
```
import Foundation
import ArgumentParser


extension MainCommand {
    struct SubCommand: ParsableCommand {
        static var configuration = CommandConfiguration(
            subcommands: [
                SubSubCommand1.self
            ]
        )

        struct SubSubCommand1: ParsableCommand {
            @OptionGroup()
            var globalOptions: MainCommand.GlobalOptions
        }
    }
}
```

This code compiles as expected using:
```bash
$ swift build
...
[65/65] Linking glr-bug-test
```

But then when the application is ready for distribution:

```bash
$ swift build -c release
<unknown>:0: error: invalid redeclaration of 'globalOptions'
<unknown>:0: note: 'globalOptions' previously declared here
```
The error seems to occur during linking.

### Expected behavior
I expect that the code can be compiled with `-c release` without an error.

### Actual behavior
The code does not compile. It provides an error which only shows when `-c release` is used and not in normal (debug) mode.



Issue 79 - Author: natecook1000
### Description
This provides a method on all `ParsableArguments`/`ParsableCommand` types that lets you retrieve the exit code associated with an error.

### Detailed Design
1) Add an `exitCode(for:)` method that converts an error to an `ExitCode` instance. 

```swift
extension ParsableArguments {
  /// Returns the exit code for the given error.
  ///
  /// - Parameter error: An error to generate a message for.
  /// - Returns: The exit code for the `error`.
  public static func exitCode(for error: Error) -> ExitCode
}
```

2) Upgrade the `ExitCode` type to be a bit more useful, making it `RawRepresentable` and  `Hashable`. The represented code is now available through the `rawValue` property.

### Documentation Plan
I included symbol documentation for the new APIs.

### Test Plan
I added unit tests for the `exitCode(for)` method and converted the integration test helper to use `ExitCode`s instead of plain `Int32`s.

### Source Impact
No source impact or deprecations.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 78 - Author: natecook1000
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Previously, we were only storing full-decoded ParsableCommand instances for subcommands to pick up with the @OptionGroup() wrapper. This change stores all decoded @OptionGroup() values as well, so that they can be shared from super- to subcommand.

In this example from the test, the `Sub` command would never actually see a value in its `options.name` property, since the `--name Tom` inputs get consumed the first time that `Options` is decoded:

```swift
struct Options: ParsableArguments {
    @Option() var name: String?
}

struct Super: ParsableCommand {
    static let configuration = CommandConfiguration(subcommands: [Sub.self])

    @OptionGroup() var options: Options

    struct Sub: ParsableCommand {
        @OptionGroup() var options: Options
    }
}
```

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 77 - Author: griffin-stewie
- [x] I've completed this task

I fixed a bug #76. The cause of the bug was that the option of `ArgumentDefinition.Help` was not correctly given only for `init(name:, default:, parsing:, help:, transform:)`.

I added tests HelpGenerationTests and UsageGenerationTests.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 76 - Author: fappelman
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace each paragraph
    below with the relevant details for your bug, and complete
    the steps in the checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

If an option has a default value **and** a transformation it is not listed as optional but as mandatory instead.

**ArgumentParser version:** `0.0.2`
**Swift version:** Apple Swift version 5.1.3 (swiftlang-1100.0.282.1 clang-1100.0.33.15)
Target: x86_64-apple-darwin19.3.0

### Checklist
- [X] I've reproduced the issue using the `master` branch of this package
- [X] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
```swift
import ArgumentParser
import Foundation

enum Mode {
    case mac
    case linux

    public static func mode(from: String) -> Mode? {
        switch from {
        case "mac":
            return .mac
        case "linux":
            return .linux
        default:
            return nil
        }
    }
}

struct Example: ParsableCommand {
    static let defaultMode: Mode = .mac
    static func toMode(_ string: String) throws -> Mode {
        Mode.mode(from: string)!
    }

    @Option(default: defaultMode, help: "Set mode, either linux or mac.", 
            transform: toMode)
    var mode: Mode
}

Example.main()
```

Produces output:

```log
USAGE: example --mode <mode>

OPTIONS:
  --mode <mode>           Set mode, either linux or mac. 
  -h, --help              Show help information.

Program ended with exit code: 0
```

### Expected behavior
I would expect the following USAGE line:

```log
USAGE: example [--mode <mode>]
```

### Actual behavior
I get:

```log
USAGE: example --mode <mode>
```



Issue 75 - Author: griffin-stewie
### Description

I added support default value for `@Argument` property wrapper.

Related issue is #64. and Swift Forums thread is [`Default Argument values?  - Related Projects / ArgumentParser`](https://forums.swift.org/t/default-argument-values/34174)

### Detailed Design

The way to implement is same as `@Option` property wrapper. Just add a optional `default` parameter on its `init` method and default value is nil. `ArgumentSet` and` ArgumentDefinition` do all the work in the `init` method.

### Documentation Plan

> How has the new feature been documented? 

I added documents on methods I changed.

> Have the relevant portions of the guide been updated in addition to symbol-level documentation?

I fixed a bit talking about `default` parameter on `02 Arguments, Options, and Flags.md`.

### Test Plan

> How is the new feature tested?

I added tests similar to the existing test code to `DefaultsEndToEndTests.swift`.

For example, if there is no argument when the `Default` value is given Whether the` Default` value is stored. If there is an argument when giving the `Default` value, whether the value will be overridden properly.

### Source Impact

> What is the impact of this change on existing users?

`default` value is Optional and default parameter is nil, so no impact on existing users.

> Does it deprecate or remove any existing API?

No it doesn't.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary

Issue 74 - Author: elliottwilliams
Similar to https://github.com/apple/swift-argument-parser/commit/d8fb6bdd63fa541e0ea52a99556093e1c3a60586 and #18.

Prior to Swift 5.2, test target names need to be unique throughout the entire package graph. This change adds ~"SAP"~ "ArgumentParser" to each test target to avoid ambiguities.

Context: I'm trying to use swift-argument-parser in a package repo which also depends on [Carthage](https://github.com/Carthage/Carthage), and they have [a nested dependency with a `UnitTests` target](https://github.com/Carthage/Carthage#carthagekit). Since the argument parser is under active development and I assume I'm not the only one in this situation, I figured I would propose the change here.

### Checklist
- [n/a] I've added at least one test that validates that my change is working, if appropriate
- [n/a] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [n/a] I've updated the documentation if necessary


Issue 73 - Author: miguelangel-dev
<!--
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Currently `HelpCommand` is launching a side-effect in `run` method (printing in the console the help). This PR fixes it and throw the effect to the next layer, who will catch it and treat the effect properly. Effects should be handled on the `main` method inside `exit(withError:)` or **let to the user decided how to manage them**

This change will let us write something like:
```swift
enum ParsableCommandError: Error {
    case general(String)
}

extension ParsableCommand {
    func parse(_ arguments: [String]? = nil) -> Result<ParsableCommand, ParsableCommandError> {
        do {
            let command = try Self.parseAsRoot(arguments)
            try command.run()
            return .success(command)
        } catch {
            let info = Self.fullMessage(for: error)
            return .failure(.general(info))
        }
    }
}
```

In the end, delegate the responsibility about when executing the effects and how handling

> I have tested it using ParsableCommand with subcommands and without them. It works properly in both cases.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary

Issue 72 - Author: iainsmith
### Description
Gardening: Make environment.sh executable so it's easy for newcomers to submit debug information.

### Detailed Design
chmod +x ./Scripts/environment.sh

### Documentation Plan
N/A

### Test Plan
N/A, but I did run the script 😄 

### Source Impact
N/A

### Checklist
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)


Issue 71 - Author: glessard
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Stop failing upon seeing a repeated value from a mutually-exclusive set of flags.

This adds an `Equatable` requirement to the `Flag` constructors from `CaseIterable` enums. Given the other requirements on those enums, `Equatable` conformance is automatic and therefore costs nothing.

The switch statement in `ArgumentSet.updateFlag` is also much simplified, by calling `values.element(forKey:)` only when it is needed.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary

This fixes https://github.com/apple/swift-argument-parser/issues/59
This supersedes https://github.com/apple/swift-argument-parser/pull/70

Issue 70 - Author: glessard
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

This change has no effect on functionality, documentation or testing.

The switch in `ArgumentSet.flagUpdate` (originally in one of the Flag constructors) switches on 3 items, one of which (the return value of `values.element(forKey:)`) is needed in only one of the 12 possibilities. This moves the call to `values.element(forKey:)` into the one `case` where it is needed. The function becomes slightly more efficient, and the `switch` is more readable (down to 6 possibilities), and no longer needs a `default` case. Note that the probably-impossible failure mode where `values.element(forKey: key` returns `nil` and `hasUpdated` is `true` still results in the same behaviour, namely the argument is unused and the function returns `true`; this eventually leads to a call to `ErrorMessageGenerator.unknownOptionMessage`.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 69 - Author: compnerd
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Replace this paragraph with a description of your changes and rationale. Provide links to an existing issue or external references/discussions, if appropriate.

### Checklist
- [ ] I've added at least one test that validates that my change is working, if appropriate
- [ ] I've followed the code style of the rest of the project
- [ ] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [ ] I've updated the documentation if necessary


Issue 68 - Author: jonathanpenn
When using option groups to bring options into subcommands that are also
used in parent commands, the help system duplicates the options in the
generated output.

For instance, in the `SubcommandEndToEndTest` example, the `--name`
argument is listed twice for both the subcommands `CommandA` and
`CommandB`, and expected by the test assertion.

It is annoying in a simple case like this but causes a lot of unhelpful
noise in help output when you share more and more options across a
command heirarchy.

To solve this we need to keep track of what
`HelpGenerator.Section.Element` values have already been processed from
parent commands in the command stack. I acheived this by making
`Element` conform to `Hashable` to track in a `Set`.

This assumes that we don't need to support re-using command names up and
down a command heirarchy. It doesn't work at all today (you get an error
when trying to use the exact same option in a parent and child
command). If we choose to support this eventually then we'll need to
augment this solution to keep track of where the `Element` was generated
in the heirarchy.

This also updates the test to properly assert that the `--name` option
is only output once for the subcommands in `SubcommandEndToEndTest`.
### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 67 - Author: glessard
<!--
    Thanks for contributing to the Swift Argument Parser!

    If this pull request adds new API, please add '?template=new.md'
    to the URL to switch to the appropriate template.

    Before you submit your request, please replace the paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Previously, using a set of flags declared with FlagExclusivity.chooseFirst would result in an error instead of choosing the first from the command line. (See https://github.com/apple/swift-argument-parser/issues/66).

### Detailed Design
Added a case handling repeating arguments in the `ArgumentSet.updateFlag` function.
The previous behaviour had the repeating-arguments-with-.chooseFirst situation going through the `default` case, which didn't add the current argument to the list of used arguments, which later caused an error due to the argument being incorrectly deemed to have not been used.

### Documentation Plan
No change to documentation is needed.

### Test Plan
Tests added to `FlagsEndToEndTests.testParsing_invert` and `FlagsEndToEndTests.testParsingCaseIterable_RepeatableFlags`.

### Source Impact
None.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary

This PR fixes https://github.com/apple/swift-argument-parser/issues/66

Issue 66 - Author: glessard
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your issue, please replace each paragraph
    below with the relevant details for your bug, and complete
    the steps in the checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

Repeated flags defined with `FlagExclusivity.chooseFirst` error instead of choosing first.

**ArgumentParser version:** `master` at https://github.com/apple/swift-argument-parser/commit/58660b05c444b6916df980e7ad1e8f047cf14977
**Swift version:** Apple Swift version 5.2 (swiftlang-1103.0.30 clang-1103.0.30)

### Checklist
- [x] If possible, I've reproduced the issue using the `master` branch of this package
- [x] I've searched for [existing GitHub issues](https://github.com/apple/swift-argument-parser/issues)

### Steps to Reproduce
Use this simple program:
```
enum Enum: String, CaseIterable { case s, t, u }

struct Options: ParsableCommand {
  @Flag(name: .short, exclusivity: .chooseFirst)
  var flag1: Enum
}

let options = Options.parseOrExit()
print(options.flag1)
```
```
$ options -s -t
```
### Expected behavior
It should print "s" by itself, on a line

### Actual behavior
```
$ options -s -t
Error: Unknown option '-t'
Usage: options -s -t -u
```


Issue 65 - Author: natecook1000
### Description
This addresses the need for providing name specifications for `enum` flags, since property wrappers can't be used for enumeration cases.

### Detailed Design
This includes a new `EnumerableFlag` protocol:

```swift
/// A type that represents the different possible flags to be used by a
/// `@Flag` property.
public protocol EnumerableFlag: CaseIterable {
  /// Returns the name specification to use for the given flag.
  static func name(for value: Self) -> NameSpecification

  /// Returns the help information to show for the given flag.
  static func help(for value: Self) -> ArgumentHelp?
}
```

As well as new `EnumerableFlag`-constrained `@Flag` initializers that replace the current ones that are constrained to `String`/`CaseIterable`.

### Documentation Plan
Wrote type- and symbol-level documentation for `EnumerableFlag`, revised docs for the new initializers, and updated the "Argument, Options, and Flags" guide.

### Test Plan
Modified unit tests to use the new protocol and added tests that use the original, deprecated versions.

### Source Impact
This deprecates the `@Flag` initializers that are constrained to `CaseIterable`/`RawRepresentable` and `RawValue == String`. These initializers will continue to work, and can be removed in a future version. 

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary


Issue 64 - Author: griffin-stewie
I hope `@ Argument` has a default value.

This is useful when a command needs a path argument to do some work on the path. The user can pass any path or omit it, in which case the current directory will be the path. It is similar to the `ls` command.

```swift
// pseudo code
@Argument(default: ".")
var path: URL
```

## Related thread

[Default Argument values? \- Related Projects / ArgumentParser \- Swift Forums](https://forums.swift.org/t/default-argument-values/34174)

Issue 63 - Author: glessard
This fixes https://github.com/apple/swift-argument-parser/issues/56

Issue 62 - Author: glessard
<!--
    Thanks for contributing to the Swift Argument Parser!

    Before you submit your request, please replace each paragraph
    below with the relevant details, and complete the steps in the
    checklist by placing an 'x' in each box:
    
    - [x] I've completed this task
    - [ ] This task isn't completed
-->

### Description
Constructors for Bool Flags with inverted pairs do not have a `FlagExclusivity` parameter (https://github.com/apple/swift-argument-parser/issues/60). This PR adds a `FlagExclusivity` parameter to two of the Flag constructors.

### Detailed Design
On `Flag`,
```
public init(name: NameSpecification = .long, default initial: Bool? = false,
            inversion: FlagInversion, help: ArgumentHelp? = nil)
```
becomes
```
public init(name: NameSpecification = .long, default initial: Bool? = false,
            inversion: FlagInversion, exclusivity: FlagExclusivity = .chooseLast,
            help: ArgumentHelp? = nil)
```

In the process, the logic to handle flag exclusivity collision was refactored to a new static function on `ArgumentSet`, and is used for `Bool` flags with inversions as well as flags built from `CaseIterable` enums.

### Documentation Plan
The new parameter has been documented in the doc comments.

### Test Plan
New tests are added to `FlagsEndToEndTests` and to `ErrorMessageTests`

### Source Impact
The parameter is additive with a default value, and therefore is source compatible.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary

This resolves https://github.com/apple/swift-argument-parser/issues/60 and https://github.com/apple/swift-argument-parser/issues/61

Issue 61 - Author: glessard
Here is a command with two flags whose type differs only by optionality (and spelling)
```
enum Enum: String, CaseIterable { case s, t, u }

struct Options: ParsableCommand {
  @Flag(name: .short, exclusivity: .exclusive) var flag1: Enum
  @Flag(name: .long,  exclusivity: .exclusive) var flag2: Enum?
}
let options = Options.parseOrExit()
```

The two flags will report errors rather differently:
```
$ options -s -t
Error: Value to be set with flag '-t' had already been set with flag '-s'
Usage: options -s -t -u [--s] [--t] [--u]
$ options --s --t
Error: Unexpected argument 't'
Usage: options -s -t -u [--s] [--t] [--u]
```

Cause: the two `Flag` instances use two very different constructors. Presumably they diverged during development.

Issue 60 - Author: glessard
```
struct Options: ParsableCommand {
  @Flag(inversion: .prefixedNo)
  var x: Bool
}
options = Options.parseOrExit()
print(options.x)
```

```
$ options --x --no-x
false
$ options --no-x --x
true
```

Implicitly, they behave as if one had passed `FlagExclusivity.chooseLast`, but this is not adjustable.

Issue 59 - Author: glessard
When repeating a flag defined from a mutually-exclusive set, one gets an error.
```
enum Enum: String, CaseIterable { case s, t, u }

struct Options: Parsable Command {
  @Flag(name: .short, exclusivity: .exclusive, help: "Help!")
  var flag: Enum
}

let options = Options.parseOrExit()
```
```
$ options -s -s
Error: Value to be set with flag '-s' had already been set with flag '-s'
Usage: options -s -t -u
```

Should repetition in such a case simply be ignored?

Issue 58 - Author: lantua
…onvertible`.

This extension provides default implementation for `ExpressibleByArgument` to types conforming to `LosslessStringConvertible`.
It should be restricted only to ones that wants to conform to `ExpressibleByArgument`.

Issue 57 - Author: lantua
When I tried to compile a clean git-clone, I hit an error

```
Invalid redeclaration of `options`,
```

with the pointer to declarations being blank.

I traced it down to `Tests/PackageManagerTests/PackageManager/Clean.swift`. If I change the name of `options` to other names, the error message follows.

This is probably a compiler bug rather than the package bug, but maybe we should also find a workaround.

Note that it works fine as part of other packages.

Note: Xcode Version 11.3.1 (11C504)

Issue 56 - Author: glessard
When using flags built from a `(String & CaseIterable)` enum, such as this:
```
enum OutputBehaviour: String, CaseIterable { case stats, count, list }

struct Options: ParsableCommand {
  @Flag(name: .short, default: .list, exclusivity: .chooseFirst, help: "Help!")
  var behaviour: OutputBehaviour
}

let options = Options.parseOrExit()
```

The corresponding line in the help message does not display the default value.

The Flag initializer passes the default value along to the ArgumentDefinition constructor, but when the array of ArgumentDefinition is read back in HelpGenerator, the `help.defaultValue` properties for these is `nil`.

Issue 55 - Author: glessard
The original logic assumed that flags would only be grouped in pairs.
Fixes https://github.com/apple/swift-argument-parser/issues/50

Still an issue: with a `@Flag` value typed as a `CaseIterable` enum, its default value doesn't appear. The latter is a new issue https://github.com/apple/swift-argument-parser/issues/56

Issue 54 - Author: dduan
### Description
Per [discussion][], add an initializer for `Flag<Optional<Bool>>` that
allows the default value to be `nil`, enabling capacity to distinguish
the lack of a supplied flag vs the default value from user.

[discussion]: https://forums.swift.org/t/flag-default-value-where-did-it-come-from/34204/10

### Detailed Design

Newly added initializer enables the following `Flag` declaration.

```swift
@Flag(inversion: .prefixedNo)
var throwingAwayMyShot: Bool?
```

When neither `--no-throwing-away-my-shot` nor `--throwing-away-my-shot` is supplied as command-line argument in this scenario, this flag value is `nil`. Otherwise it has same behavior as the non-optional variant.

### Documentation Plan
This is variant of the existing `Flag<Bool>` flag. Current documentation does not explicitly point out this new API. It may be reasonable to expect user to discover it organically when they try things out since the behavior is (IMO) natural.

### Test Plan

Unit tested.

### Source Impact

This adds a new API. No source impact to existing users.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary

Issue 53 - Author: Sajjon
Partial fix of #46 + some extra goodies. This PR is a version of https://github.com/apple/swift-crypto/pull/21 updated for this repo, copy pasting my description from that PR in here (we developers are a lazy bunch right?)

Upgrading ISSUE_TEMPLATE from single markdown to 4 option selection: Bug, Regression, Question, Feature Request

### Motivation:

Having this template where when user presses `NEW ISSUE` button she has to think about what she's doing might lead to better issues submitted. 

### Modifications:

1. Adding a `.github` directory containing four different issues types.
2. Added new script `./Scripts/environment.sh` which puts to together a summary of users environment and copies to pasteboard (asking first). The scripts output looks like this:

```bash
Swift version: Apple Swift version 5.2 (swiftlang-1103.0.22 clang-1103.0.22)
Target: x86_64-apple-darwin19.3.0
Unix version: Darwin Sajjode.local 19.3.0 Darwin Kernel Version 19.3.0: Thu Jan  9 20:58:23 PST 2020
 root:xnu-6153.81.5~1/RELEASE_X86_64 x86_64

macOS version: 10.15.3
Xcode-select path: '/Applications/Xcode.app/Contents/Developer
Xcode: Xcode 11.4 (Build version 11N111s)

```


### Result:

#### New-Issue alternatives
![new_issue_options](https://user-images.githubusercontent.com/864410/73887452-dfb36d00-486b-11ea-8975-363bfdf85c77.png)

#### Bug report
With having pasted output generated from `./Scripts/environment.sh`
![bug_report](https://user-images.githubusercontent.com/864410/73887500-f8bc1e00-486b-11ea-8fa0-fe45593a9e4d.png)

#### Feature request

![feature_request](https://user-images.githubusercontent.com/864410/73887602-2903bc80-486c-11ea-9e33-5b241b458d08.png)


Issue 52 - Author: glessard
This is an attempt to fix https://github.com/apple/swift-argument-parser/issues/49

Questions about this proposed fix:
- Would it be better to simply extract the strings at the point where the error is thrown?
  I touched every place where "duplicateExclusiveValues" appears, so it's not clear that error case would have another use than this one.
- Is the proposed replacement message any good?

Issue 51 - Author: natecook1000
### Description

This adds an `ExitCode` error type that stores an exit code, and updates the exit machinery (1) to use `ExitCode` as the source for exit codes, and (2) to silently exit when the provided error is an `ExitCode` instance.

New API:

```swift
/// An error type that only includes an exit code.
///
/// If you're printing custom errors messages yourself, you can throw this error
/// to specify the exit code without adding any additional output to standard
/// out or standard error.
public struct ExitCode: Error {
   /// Creates a new `ExitCode` with the given code.
   public init(_ code: Int32)

   /// An exit code that indicates successful completion of a command.
   public static let success

   /// An exit code that indicates that the command failed.
   public static let failure

   /// An exit code that indicates that the user provided invalid input.
   public static let validationFailure
}
```

### Documentation Plan
Included API documentation and expanded a section in the [Validation & Errors guide](https://github.com/apple/swift-argument-parser/pull/51/files#diff-d57fe4925b10ddced8a151a63627b3de).

### Test Plan
Added tests for failing silently and for exiting with each preset error code and a custom error code.

### Source Impact
The new type is an additive change. There's an additional behavior change that I'd call a bug fix, where errors that convert to an empty string now don't print the `"Error:"` prefix by itself.


Issue 50 - Author: glessard
I defined a set of mutually exclusive flags thusly:
```
enum OutputBehaviour: String, CaseIterable { case stats, count, list }

struct Options: ParsableCommand {
  @Flag(help: "Program output")
  var behaviour: OutputBehaviour
}

let options = Options.parseOrExit()
```

The help message that corresponds to these is not very helpful:
```
$ ./options --help
USAGE: options --stats --count --list

OPTIONS:
  --stats/--count         Program output 
  --list                  Program output 
  -h, --help              Show help information.
```

The help generator lists them in pairs whenever there are more than 2.
It's not clear that the three flags (stats, count, list) are a set.
It's not clear that they are mutually exclusive.

Issue 49 - Author: glessard
I defined a set of mutually exclusive flags thusly:
```
enum OutputBehaviour: String, CaseIterable { case stats, count, list }

struct Options: ParsableCommand {
  @Flag(default: .list, help: "Program output")
  var behaviour: OutputBehaviour
}

let options = Options.parseOrExit()
```

Upon misusing the command by using two of these flags, the error message is unhelpful:
```
$ ./options  --count --list
Error: Value at position InputOrigin(_elements: Set([ArgumentParser.InputOrigin.Element.argumentIndex(1)])) has already been set from value at position InputOrigin(_elements: Set([ArgumentParser.InputOrigin.Element.argumentIndex(0)])).
Usage: options [--stats] [--count] [--list]
```

The error message should print out the conflicting flag names instead.

Issue 48 - Author: sjavora
Fixes #26 

Issue 47 - Author: glessard
Previously, if one defined an option thusly:
```
  @Option(name: .long, default: "", help: "help text")
  var option: String
```

the corresponding line of help output would be:
```
  --option <option>       help text (default: )
```

After this patch, the output becomes:
```
  --option <option>       help text
```

This did not affect the tests.

Issue 46 - Author: natecook1000
The guide should cover pull request and testing expectations, coding style (re: [this note](https://github.com/apple/swift-argument-parser/pull/22#issuecomment-593087110)), and any platform-specific requirements.

Issue 45 - Author: Blackjacx
In my Package.swift I put: 
```
products: [
        .executable(name: "downloadmetadata", targets: ["DownloadMetadata"]),
        .executable(name: "playground", targets: ["Playground"]),
    ]
```

But the usage description showns the command name like the follwoing by entering the `-`
```
USAGE: download-metadata --project-root <project-root>
```

Issue 44 - Author: compnerd
Since swift-package-manager doesn't work on Windows yet, add a CMake
based build system.

Issue 43 - Author: compnerd


Issue 42 - Author: compnerd
This adjusts the imports to enable building for Windows.

The major change here is that `_terminalHeight` and `_terminalWidth`
have been merged into a `_terminalSize` which returns a tuple of the
width and the height.  This is then implemented for Windows as well.

Issue 41 - Author: thomasvl
Some tools/situations end up needing so many arguments that they can run in to the max command line length. This is usually handled via _argument files_ or _parameter files_ -- if an argument is prefixed with a marker (usually `@`), then the contents of the referenced file are read at that location in the command line as if the content were on the command line.  This also usually works recursively in that the read file could include another one of these directives to read yet another file.

There can be two types of "modes" that are supported for reading these files:
- _multiline_ : Every line of the files is a single argument.  This is the easy one, as it means spaces, etc. are part of the arg, there is no need to understand escaping, just split on newlines and handle things.
- _shell quoted_ : The files are parse like a Bourne shell would, this requires handing quotes and escapes.  `swift` and `clang` support files in this form.

Reference:
- Python ArgParse support: https://docs.python.org/3/library/argparse.html#fromfile-prefix-chars
- Bazel docs with notes about generating files for these two modes: https://docs.bazel.build/versions/2.0.0/skylark/lib/Args.html#set_param_file_format


Issue 40 - Author: glessard
`ParsableCommand.parseAsRoot()` drops the first item from `CommandLine.arguments` when it receives a `nil` array as a parameter, so it is necessary to do the same before pre-processing arguments to feed to any `ParsableCommand`.

Issue 39 - Author: thomasvl
Looks like some of the tests already confirm it, but the documentation doesn't seem to call out that the library does support the standard of taking an `--` argument to then map all following command line args to be Arguments (and never recognize them as Flags/Options).


Issue 38 - Author: glessard
fix typo in code example to configure the help flags.

Issue 37 - Author: ddunbar
By default, `ArgumentParser` currently uses a `ArgumentHelp.valueName` derived from the option name. While this is a nice standard default, I think it often leads to overly verbose --help text, and customizing with `ArgumentHelp` makes declaration a little verbose (super kudos for having it possible in v0.0.1 though!).

I think there is an argument to be made for having `ArgumentParser` use a default value name for well-known and common types, for example, using `N` for integral types.

One upside of this is that it helps communicate the expected type.

I can understand if this is perceived to be too much magic, though...

Issue 36 - Author: dduan
I see that when a subcommand's help text is generated, it's based on a stack, which eventually includes its ancestor's flags/options, etc. So the following definition

```swift
struct Math: ParsableCommand {
    static var configuration = CommandConfiguration(subcommands: [Add.self])

    @Flag()
    var version: Bool
}

extension Math {
    struct Add: ParsableCommand {}
}
```

means the help text for `add` will be the following:

```
USAGE: math add

OPTIONS:
  --version
  -h, --help              Show help information.
```

There should be a way to prevent `--version` to be included here IMO.

Issue 35 - Author: hadyhallak
The library always prints help for the root command.

Example:

`math add --help` prints help for `math` rather than `add`.

Issue 34 - Author: Blackjacx
Hey Paul, 

first of all: really cool project! Thanks a lot :-)

I have the following in my small (private) script which should specify the Xcode project root:

```
    @Option(name: .shortAndLong, help: "The root directory of your Xcode project.")
    var projectRoot: String
```

The running `swift build && swift run downloadmetadata --projectRoot .` gives me the error:

```
Fatal error: Trying to read value from definition.: file /Users/stherold/dev/projects/db/ios-tools/.build/checkouts/swift-argument-parser/Sources/ArgumentParser/Parsable Properties/Option.swift, line 48
[1]    55885 illegal hardware instruction  swift run downloadmetadata --projectRoot .
```

Any idea?

Issue 33 - Author: nuclearace
I noticed that I was allowed to mark the run method as mutating, however, this caused issues where it was always thinking it was expecting arguments... which is strange. 

But is there a reason to not mark this as possibly mutating?

Issue 32 - Author: PopFlamingo
Take the given program:
```swift
import ArgumentParser

struct ExampleCommand: ParsableCommand {
    @Argument()
    var arg1: String?
    
    @Argument()
    var arg2: String

    func run() {}
}

ExampleCommand.main()
```

Calling `./myProgram --help` shows:
```
USAGE: example-command [<arg1>] <arg2>

ARGUMENTS:
  <arg1>
  <arg2>

OPTIONS:
  -h, --help              Show help information.
```

Which would indicate `arg1` is optional, but omitting it:
```
`./myProgram isThisArg2??
```

Results in an error:
```
Error: Missing expected argument '<arg2>'
Usage: example-command [<arg1>] <arg2>
```

While optional arguments can easily cause ambiguous calls to your program, for instance if two arguments are optional and the program is only called with one argument, handling of such cases is probably improvable:
- Maybe non-ambiguous cases should be accepted, for instance, if in a total of `n` arguments there is a _single_ argument that's optional, accept calls with both `n` and `n-1` arguments, because we can suppose the "missing" argument is the optional one, this would make the above  example work.
- If there are other less obvious argument parsing strategies that enable avoiding ambiguities, they could be enabled through new options, for instance if in `some-command [<arg1>] [<arg2>] <arg3>` both `arg1` and `arg2` are restricted to two disjoint sets of acceptable values, its still possible to disambiguate a call with one **and** two arguments.
- In cases where we know there exists no way for the command to be called unambiguously, maybe it would be a good thing to crash as soon as possible in `.main()` (in debug builds) to let the code author know early there is something wrong with how they set the command arguments.

Issue 31 - Author: alexito4
Imagine a command like this

```swift
import ArgumentParser

struct Absolute: ParsableCommand {
    
    @Argument() var number: Int
    
    func run() throws {
        print(abs(number))
    }
}

Absolute.main()
```

you can run

```
command 5
```

and it works. but running

```
command -5
```

fails with `Error: Missing expected argument '<number>'` which makes sense. 

I would have expected being able to pass the argument as `"-5"` but that doesn't work either. 

Any advice on how to handle this?

Issue 30 - Author: sjavora
HelpGenerator currently filters out the default values for Bools. Fixes #16 

(replaces #20 which I can't reopen)

Issue 29 - Author: natecook1000
### Description
We don't currently have a way for `@Argument` arrays to capture command-line inputs that look like options. This capability is important for tools like SwiftPM that need to forward input to another command.

For example, the `swift-run` command needs to be able to parse all three of the arguments here into an array, including `--count`:

```
% swift run repeat --count 5 hello
``` 

### Detailed Design
This introduces an `ArgumentArrayParsingStrategy` enum with a `remaining` case that  matches the current behavior, as well as an `unconditionalRemaining` case that captures all remaining input.

```swift
/// The strategy to use when parsing multiple values from `@Option` arguments
/// into an array.
public enum ArgumentArrayParsingStrategy {
  /// Parse only unprefixed values from the command-line input, ignoring
  /// any inputs that have a dash prefix.
  ///
  /// For example, for a parsable type defined as following:
  ///
  ///     struct Options: ParsableArguments {
  ///         @Flag() var verbose: Bool
  ///         @Argument(parsing: .remaining) var words: [String]
  ///     }
  ///
  /// Parsing the input `--verbose one two` or `one two --verbose` would result
  /// in `Options(verbose: true, words: ["one", "two"])`. Parsing the input
  /// `one two --other` would result in an unknown option error for `--other`.
  ///
  /// This is the default strategy for parsing argument arrays.
  case remaining
  
  /// Parse all remaining inputs after parsing any known options or flags,
  /// including dash-prefixed inputs and the `--` terminator.
  ///
  /// For example, for a parsable type defined as following:
  ///
  ///     struct Options: ParsableArguments {
  ///         @Flag() var verbose: Bool
  ///         @Argument(parsing: .unconditionalRemaining) var words: [String]
  ///     }
  ///
  /// Parsing the input `--verbose one two --other` would include the `--other`
  /// flag in `words`, resulting in
  /// `Options(verbose: true, words: ["one", "two", "--other"])`.
  ///
  /// - Note: This parsing strategy can be surprising for users, particularly
  ///   when combined with options and flags. Prefer `remaining` whenever
  ///   possible, since users can always terminate options and flags with
  ///   the `--` terminator. With the `remaining` parsing strategy, the input
  ///   `--verbose -- one two --other` would have the same result as the above
  ///   example: `Options(verbose: true, words: ["one", "two", "--other"])`.
  case unconditionalRemaining
}
```

The two array-based `@Argument` initializers gain defaulted parameters for the parsing strategy:

```swift
  /// Creates a property that reads an array from zero or more arguments.
  ///
  /// The property has an empty array as its default value.
  ///
  /// - Parameters:
  ///   - parsingStrategy: The behavior to use when parsing multiple values
  ///     from the command-line arguments.
  ///   - help: Information about how to use this argument.
  public init<Element>(
    parsing parsingStrategy: ArgumentArrayParsingStrategy = .remaining,
    help: ArgumentHelp? = nil
  ) where Element: ExpressibleByArgument, Value == Array<Element>

  /// Creates a property that reads an array from zero or more arguments,
  /// parsing each element with the given closure.
  ///
  /// The property has an empty array as its default value.
  ///
  /// - Parameters:
  ///   - parsingStrategy: The behavior to use when parsing multiple values
  ///     from the command-line arguments.
  ///   - help: Information about how to use this argument.
  ///   - transform: A closure that converts a string into this property's
  ///     element type or throws an error.
  public init<Element>(
    parsing parsingStrategy: ArgumentArrayParsingStrategy = .remaining,
    help: ArgumentHelp? = nil,
    transform: @escaping (String) throws -> Element
  ) where Value == Array<Element>
```

### Documentation Plan
This includes documentation for the new enumeration and for the new parameters, as well as a new "Alternative positional argument parsing strategies" section in the _Arguments, Options, and Flags_ guide.

### Test Plan
End to end tests that use the `. unconditionalRemaining` strategy.

### Source Impact
This adds a defaulted parameter to two initializers, so it shouldn't have a significant source impact.

### Checklist
- [x] I've added at least one test that validates that my change is working, if appropriate
- [x] I've followed the code style of the rest of the project
- [x] I've read the [Contribution Guidelines](CONTRIBUTING.md)
- [x] I've updated the documentation if necessary

Issue 28 - Author: dduan
When generating help text, remove non-existent segments prior to joining
with an empty space. This ensures vertical visual alignment when
description for default value is the only segment.

Closes #27

Issue 27 - Author: dduan
If a user chooses to not include an abstract, the default value will begin with an extra space, resulting vertically unaligned descriptions, example:

```swift
struct Example: ParsableCommand {
    @Option(help: "The first option")
    var one: Bool
    @Option(default: "42")
    var two: String
    @Option(help: "The third option")
    var three: String
}
```

gets the following generated help text:

```
USAGE: example --one <one> [--two <two>] --three <three>

OPTIONS:
  --one <one>             The first option
  --two <two>              (default: 42)
  --three <three>         The third option
  -h, --help              Show help information.
```

Note description for `two` is unaligned vertically in relation to that of `one` and `three`

Issue 26 - Author: dduan
the following option

```swift
@Option(default: true)
var doStuff: Bool?
```

would result in the following default value description:

```
(default: Optional(true))
```

This is counterintuitive and requires user to workaround it.



Issue 25 - Author: griffin-stewie
Is there a way to balance the processing of the argument with the "--version" option?

Here is my sample code. This command is simple echo, prints argument and prints version number if `--version` flag is applied.

```swift
import ArgumentParser

struct MyEcho: ParsableCommand {

    @Flag(name: .shortAndLong)
    var version: Bool

    @Argument()
    var text: String

    func run() {
        if version {
            print("v1.0.0")
            return
        }

        print(text)
    }
}

MyEcho.main()
```

However this sample code does not work well when you run `myEcho --version` because default validation by parser detects no argument. Like this

```sh
% myEcho --version
Error: Missing expected argument '<text>'
Usage: my-echo <text> [--version]
```

If I change `var text: String` property as optional, then `myEcho --version` works well but I have to handle a situation that no argument applied.

Here is my current solution bellow. Is there a better way to handle this situation?

```swift
struct MyEcho: ParsableCommand {

    @Flag(name: .shortAndLong)
    var version: Bool

    @Argument()
    var text: String?

    func run() throws {
        if version {
            print("ver 1.0.0")
            return
        }

        guard let text = text else {
            throw ValidationError("need argument")
        }

        print(text)
    }
}
```

Issue 24 - Author: belkadan
ArgumentParser has nifty support for enums-as-flags:

```swift
enum Compression: String, CaseIterable {
  case gzip, bzip2
}

@Flag()
var compression: Compression?
```

But it doesn't have any way to change the NameSpecification for individual cases, if you wanted to use something other than the default names. Or the ArgumentHelp, for that matter.

Issue 23 - Author: klaaspieter
Given this argument parser:

```
fileprivate struct Qwz: ParsableArguments {
  @Option() var name: String?
}
```

When I call it with `--nm Name`, I expect `Unknown option '--nm'`, but I get `Unexpected argument 'Name'`.

Failing test case:

```
extension ErrorMessageTests {
  func testMispelledArgument_1() {
    AssertErrorMessage(Qwz.self, ["--nme", "Me"], "Unknown option '--nme'.")
  }
}
```

Issue 22 - Author: sjavora
This removes two types of redundant code:
- `internal` annotations (because they are the default)
- code that the compiler can synthesize, like memberwise initializers and `Equatable` conformances

Some `public init`s were removed, but those couldn't be accessed anyway, because they were nested in `internal` types - I've [complained](https://forums.swift.org/t/members-in-type-more-accessible-than-the-type-itself/24756) about the possibility of doing this before on the forums.

Issue 21 - Author: sjavora
This removes unused code from `InputOrigin` and replaces the lone `static func` with an `init` to better match the rest of the file.

Issue 20 - Author: sjavora
HelpGenerator currently filters out the default values for `Bool`s.

Closed in favor of #30 

Issue 19 - Author: griffin-stewie
I added parentheses after `@OptionGroup` on  `03 Commands and Subcommands.md`.

## Motivation

I faced compile error when I use `@OptionGroup` property wrapper. Eventually the reason was missing parentheses. 

We don't need to fix the living [example code](https://github.com/apple/swift-argument-parser/blob/f6ac7b8118ff5d1bc0faee7f37bf6f8fd8f95602/Examples/math/main.swift#L54), it works well.

Issue 18 - Author: dehengxu
As title mentioned

Issue 17 - Author: Wildchild9


Issue 16 - Author: jshier
I have a simple `ParsableCommand`:

```swift
struct Dragonfly: ParsableCommand {
    @Option(default: "127.0.0.1",
            help: "Hostname of the server.")
    var host: String
    
    @Option(name: [.customLong("logging"), .customShort("l")],
            default: false,
            help: "Whether logging is enabled.")
    var enableLogging: Bool
    
    @Option(default: 9999,
            help: "Port on which to run the server.")
    var port: Int
    
    
    func run() throws {
        DragonflyServer.run(host: host, port: port, enableLogging: enableLogging)
    }
}

Dragonfly.main()
```
Works great! Noticed that the customized `enableLogging` option doesn't show its default value in the help output:
```
./dragonfly -h
USAGE: dragonfly [--host <host>] [--logging <logging>] [--port <port>]

OPTIONS:
  --host <host>           Hostname of the server. (default: 127.0.0.1)
  -l, --logging <logging> Whether logging is enabled. 
  --port <port>           Port on which to run the server. (default: 9999)
  -h, --help              Show help information.
```

Intentional or bug?

Issue 15 - Author: IngmarStein
sysexits(3) documents the "preferable exit codes for programs". It defines

```
     EX_USAGE (64)         The command was used incorrectly, e.g., with the
                           wrong number of arguments, a bad flag, a bad syntax
                           in a parameter, or whatever.
```

So it seems to be a good choice for this use case.

Issue 14 - Author: buttaface
Should also get it working for the BSDs, Haiku, etc., as long as they have a working Swift toolchain. Tested with the Swift 5.1.4 package for Android, termux/termux-packages#4895, all 230 tests pass with the following commands:
```
swift build -j 5 --enable-test-discovery
swift test -j 5 --parallel --num-workers 3 --enable-test-discovery
```
Note the space required after `-j`, hopefully this library doesn't have the same problem.

Issue 13 - Author: Sajjon


Issue 12 - Author: Sajjon
Same contents as my [merged PR into swift-standard-library-preview
](https://github.com/apple/swift-standard-library-preview/pull/1), [merged PR into swift-crypto](https://github.com/apple/swift-crypto/pull/11) and my [merged PR into swift-numerics](https://github.com/apple/swift-numerics/pull/34), giving proper markdown rendering inside Xcode.

As seen in [Apple's ARKit demo (inside `/ARKitExample.xcodeproj/` directory)](https://developer.apple.com/sample-code/wwdc/2017/PlacingObjects.zip)

### Motivation:

Reading of markdown becomes easier. Extra important in Swift packages, where the `README` is the first file opened by Xcode when opening said package.

### Modifications:

Just adding the `.xcodesamplecode.plist` file (to the root).

### Result:


This effectively disables editing markdown files from Xcode - or at least I have not found a way of doing so.

The "workaround" is just to open markdown files with your favourite alternative text editor, e.g. emacs, VIM, VI, Sublime Text or whatever

#### Before:
<img width="1680" alt="before" src="https://user-images.githubusercontent.com/864410/75570992-9912f600-5a58-11ea-8760-7b584c72bbb0.png">

#### After:
<img width="1680" alt="after" src="https://user-images.githubusercontent.com/864410/75570974-91ebe800-5a58-11ea-9503-8ff369f94488.png">



Issue 11 - Author: KyleLeneau
I am thinking that Github Actions would be a good fit for this project to use CI and CD for PR validation, any objections?

Issue 10 - Author: klaaspieter
When an unknown option is encountered use levenshtein to find the closest matching option. Simply prints the error if there is no close match ([distance >= 7](https://github.com/git/git/blob/228f53135a4a41a37b6be8e4d6e2b6153db4a8ed/help.c#L592)).

Fixes #2

Issue 9 - Author: zntfdr
I've checked on both SPM master and the swift-5.2 branch: 
it seems that the `Package.Dependency.Requirement` name is always [`.upToNextMinor(..)`](https://github.com/apple/swift-package-manager/blob/f2318da4f96b0607ade27eff51558206f57c2f98/Sources/PackageDescription/PackageRequirement.swift#L95).

Issue 8 - Author: BasThomas
Like [the blog post](https://swift.org/blog/argument-parser/) mentions:

> Because `highValue` is defined as an `Int`, only valid inputs are recognized, with no manual parsing or casting necessary on your part:

```
> random ZZZ
Error: The value 'ZZZ' is invalid for '<high-value>'
Usage: random <high-value>
```

Would it be possible to give an indication that an `Int` is expected rather than the invalid `String`?

Issue 7 - Author: weissi
I suppose `swift-argument-parser` uses SemVer once 1.0.0 has been tagged. Before that happens however, people will still start depending on `swift-argument-parser` because it got at least one tagged release (`0.0.1`). Therefore I think the project should clearly specify what its versioning rules are and probably offer a copy & pasteable recommended dependency line.

There could be a few different strategies:

- no guarantees at all (ie. folks should use `.exact(...)`) which I wouldn't recommend because that can easily lead to clashes. Of course, most libraries don't depend on argument parsers because that's something executables do but still...
- compatible API within one minor version but API additions allowed in patch releases. Ie. all `0.1.x` releases would be API stable (so 0.1.2 might add new API over 0.1.1 but isn't allowed to break it. 0.2.0 however is allowed to make breaking changes over 0.1.x) (`.upToNextMinor(...)`)
- normal SemVer rules (breaking changes only in majors) starting right at 0.0.1 (probably not desirable because I would imagine you don't want to lock all API right at the start?) (`from: "..."`)

Issue 6 - Author: zntfdr
As the title says.

Great documentation by the way! 🎉 👏 👏 

Issue 5 - Author: gavineadie
Swift Package Manager incorporates a stand-alone 'swift-tools-support-core' which provides an argument parser which seems to have a very similar feature set to 'swift-argument-parser' (and, incidentally, includes bash/zsh command completion), and some web tutorials have described the use of this component for command line tools.

Would those in the know, recommended that using 'swift-argument-parser' is a better choice over the argument parser in 'swift-tools-support-core' for any new work and that, maybe, even existing use of the 'swift-tools-support-core' argument parser should be curtailed and migrated to the new library?

I do appreciate that neither option is a finished work, that the world changes, and that any such advice should depend on the specific case in question.  One specific case that would cast light on this is SwiftPM itself .. is 'swift-ap' expected to replace the current argument parsing done by 'swift-tsc' in SwiftPM (the Swift blog describes increasing incorporation of 'swift-ap' in various parts of the Swift Project)?

Issue 4 - Author: KyleLeneau
It would be super nice/helpful to parse an options value from an Environment variable value as well taking what is passed in the command line call as the priority over the ENV variable. For CLI's that run in CI or automated environments this is super helpful as it would allow not having to print the value in the ENV variable and could keep it hidden. Not only that but it would be very convenient for repeated uses on commands!

```swift
import ArgumentParser

struct MyCommand: ParsableCommand {
    @Option(name: .shortAndLong, help: "The API Secret.", env: "SERVICE_API_SECRET")
    var secret: String
}
```

**Usage:**
`mycommand --secret QWERTY12345`
or
`mycommand` (where `SERVICE_API_SECRET='QWERTY12345'`

Issue 3 - Author: AliSoftware
Also fixed some typos in the documentation

\<reverted> ~Also fixed protocol conformance part in README example because that surprised me that we declared conformance on type declaration but without implementing the conformance, and only implementing the conformance in extension later… which at least I thought would not compile… but now @harlanhaskins  made me doubt it was invalid 🤔)~ \</reverted>

Issue 2 - Author: natecook1000
If a user mistypes an option, flag, or command, the error message should include a suggestion for the near-miss.

Example:

```
% example --indx 5
Error: Unexpected argument '--indx'
       Did you mean '--index'?
Usage: example [--index <index>] [<values> ...]
```

Issue 1 - Author: natecook1000
`ArgumentParser` should have the ability to generate code-completion scripts for different shells. This should initially support `zsh` and `bash`, for feature parity with the SwiftPM's `completion-tool` command, but be extensible to other shell completion styles as well.

One design would be to mimic the automatically-provided `--help` flag with a `--generate-completion-tool` option, that would take the name of the shell as its value. We'll need to augment `ArgumentHelp` so that an author can indicate the kinds of completions that are available, such as filename or path completion.

